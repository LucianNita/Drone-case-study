{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Multi-UAV Planner","text":"<p>A modular Python toolkit for dynamic, real-time multi-UAV mission planning using Dubins paths. It provides scenario generation, clustering, assignment, path planning, simulation, visualization helpers, and post-processing. r\"\"\"Arc length: $\\(L = R \\cdot |\\Delta\\theta|\\)$.\"\"\"</p>"},{"location":"#highlights","title":"Highlights","text":"<ul> <li>Modular geometry: segments and paths with Dubins primitives (CS, CSC)</li> <li>Planning: shortest transit (straight/CS/CSC) and mission coverage per task</li> <li>Assignment: greedy, Hungarian, auction (optional), PRBDD/RBDD</li> <li>Scenario engine: tasks (Point/Line/Circle/Area), UAVs, events (NEW_TASK, UAV_DAMAGE)</li> <li>Simulation loop: event-driven, with hooks for logging/metrics</li> <li>Visuals: plotting helpers and demos (kept separate from logging)</li> <li>Post-processing: runtime profiling, run logs, metrics JSON/CSV</li> </ul> <p>Tip: Arc length uses $\\(L = R \\cdot |\\Delta \\theta|\\)$ and straight-line length uses $\\(L = \\sqrt{\\Delta x^2 + \\Delta y^2}\\)$.</p> <p>This project is a Python implementation of the algorithm described in:</p> <p>Dynamic real-time multi-UAV cooperative mission planning method under multiple constraints Chenglou Liu et al., 2025(arXiv:2506.02365)</p>"},{"location":"#quickstart","title":"Quickstart","text":"<p>Prerequisites: - Python 3.10+ - Recommended: virtual environment</p> <p>Install (editable):</p> <pre><code>pip install -e .\n# Optional for visuals/demos:\npip install matplotlib numpy scipy scikit-learn\n</code></pre> <p>Minimal simulation: </p> <pre><code># quickstart_sim.py\nfrom multi_uav_planner.world_models import World\nfrom multi_uav_planner.scenario_generation import ScenarioConfig, generate_scenario, AlgorithmType\nfrom multi_uav_planner.simulation import simulate_mission\n\ncfg = ScenarioConfig(n_uavs=3, n_tasks=12, alg_type=AlgorithmType.PRBDD, seed=42)\nscenario = generate_scenario(cfg)\nworld = World(tasks={}, uavs={})\nsimulate_mission(world, scenario, dt=0.2, max_time=1500.0)\nprint(\"Done:\", world.done(), \"At base:\", world.at_base(), \"Time:\", world.time)\n</code></pre> <p>Dubins path demo (CS shortest):</p> <pre><code># quickstart_dubins.py\nimport matplotlib.pyplot as plt\nfrom math import pi\nfrom multi_uav_planner.dubins import cs_segments_shortest\nfrom visuals.plotting import plot_path, finalize_axes\n\nstart = (50.0, 50.0, pi/6)\nend   = (220.0, 80.0)\nR = 40.0\np = cs_segments_shortest(start, end, R)\n\nfig, ax = plt.subplots(figsize=(7,6))\nplot_path(ax, p)\nfinalize_axes(ax, \"Dubins CS shortest\")\nplt.show()\n</code></pre>"},{"location":"#quick-links","title":"Quick links","text":"<ul> <li>Getting Started \u2013 installation &amp; running your first simulations</li> <li>Static Simulation Usage \u2013 how to run and interpret the static planner</li> <li>Architecture \u2013 how the code is organized and how it maps to the paper</li> </ul>"},{"location":"changelog/","title":"Changelog","text":"<p>TBD</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>TBD</p>"},{"location":"algorithms/assignment/","title":"Assignment","text":"<p>TBD</p>"},{"location":"algorithms/clustering/","title":"Clustering","text":"<p>TBD</p>"},{"location":"algorithms/dubins/","title":"Dubins","text":"<p>TBD</p>"},{"location":"api/multi_uav_planner/","title":"API Reference","text":""},{"location":"api/multi_uav_planner/#multi_uav_planner","title":"<code>multi_uav_planner</code>","text":"<p>multi_uav_planner</p> <p>Dynamic real-time multi-UAV cooperative mission planning under multiple constraints, based on Dubins paths and task allocation / clustering strategies.  Python reimplementation of the methods described in (Liu et al., 2025).  Package includes modular tools for path modeling and Dubins geometry, plus world models, scenarios, clustering, assignment, and simulation.</p>"},{"location":"api/multi_uav_planner/#multi_uav_planner--public-entry-points","title":"Public entry points","text":"<p>Typical usage pattern:</p> <pre><code>from multi_uav_planner import (\n    World,\n    UAV,\n    PointTask, LineTask, CircleTask, AreaTask,\n    ScenarioConfig, Scenario, generate_scenario, initialize_world,\n    simulate_mission,\n    AlgorithmType,\n)\n\n# 1) Build or generate a scenario\ncfg = ScenarioConfig()\nscenario = generate_scenario(cfg)\n\n# 2) Create an empty World and initialize it from the scenario\nworld = World(tasks={}, uavs={})\ninitialize_world(world, scenario)\n\n# 3) Run simulation\nsimulate_mission(world, scenario, dt=0.1)\n\n# 4) Analyze results with post_processing.RunLog, aggregate_metrics, etc.\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.AlgorithmType","title":"<code>AlgorithmType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Identifier for planner/algorithm selection; stored in scenario metadata.</p>"},{"location":"api/multi_uav_planner/#multi_uav_planner.AreaTask","title":"<code>AreaTask(id: int, position: Tuple[float, float], state: Literal[0, 1, 2] = 0, heading_enforcement: bool = False, heading: Optional[float] = None, worked_by_uav: Optional[int] = None, pass_length: float = 10.0, pass_spacing: float = 1.0, num_passes: int = 3, side: Literal['left', 'right'] = 'left')</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Task</code></p> <p>A rectangular/strip-style area coverage task. The planner is expected to produce multiple passes to cover the area.</p> <p>Attributes: - pass_length: length of each pass in meters (default: $\\(10.0\\)$). - pass_spacing: lateral spacing between passes in meters (default: $\\(1.0\\)$). - num_passes: number of passes required (default: $\\(3\\)$). - side: side to begin the first pass: $\\('left'\\)$ or $\\('right'\\)$.</p> <p>Note: - This data model does not include the actual polygon describing the area;   it merely encodes sweep parameters. Geometry generation is delegated to   higher-level components.</p>"},{"location":"api/multi_uav_planner/#multi_uav_planner.CircleTask","title":"<code>CircleTask(id: int, position: Tuple[float, float], state: Literal[0, 1, 2] = 0, heading_enforcement: bool = False, heading: Optional[float] = None, worked_by_uav: Optional[int] = None, radius: float = 10.0, side: Literal['left', 'right'] = 'left')</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Task</code></p> <p>A circular-turn task centered at the task position.</p> <p>Attributes: - radius: radius of the circle in meters (default: $\\(10.0\\)$). - side: which side to traverse first; either $\\('left'\\)$ or $\\('right'\\)$.</p>"},{"location":"api/multi_uav_planner/#multi_uav_planner.CurveSegment","title":"<code>CurveSegment(center: Point, radius: float, theta_s: float, d_theta: float)</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Segment</code></p> <p>A circular-arc segment.</p> <p>Attributes: - center: center point of the circle (xc, yc). - radius: positive radius $\\(R &gt; 0\\)$. - theta_s: start angle in radians (measured from the positive x-axis). - d_theta: signed angular sweep in radians; positive =&gt; CCW rotation,   negative =&gt; CW rotation.</p> <p>Notes and constraints: - The arc length is given by $\\(L = R \\cdot |\\Delta  heta|\\)$ where   $\\(\\Delta  heta =  ext{d\\_theta}\\)$. - The implementation validates that $\\(R &gt; 0\\)$. - By default the class disallows sweeps with absolute value greater than   one full revolution; i.e. it enforces   $\\(|       ext{d\\_theta}| \\le 2\\pi\\)$ (with a tiny tolerance). Adjust or remove   this guard if you need multi-revolution arcs. - Angles are handled in radians. Use angle_at(t) to interpolate the   angular position at normalized parameter $\\(t \\in [0,1]\\)$.</p>"},{"location":"api/multi_uav_planner/#multi_uav_planner.CurveSegment.angle_at","title":"<code>angle_at(t: float) -&gt; float</code>","text":"<p>Return the angular coordinate at normalized parameter $\\(t \\in [0,1]\\)$.</p> <pre><code>    The angle is interpolated linearly:\n    $$      heta(t) =       heta_s + t \\cdot \\Delta heta.$$\n\n    Raises:\n    - ValueError if $$t\n</code></pre> <p>otin [0,1]$$.</p> Source code in <code>src\\multi_uav_planner\\path_model.py</code> <pre><code>def angle_at(self, t: float) -&gt; float:\n    \"\"\"Return the angular coordinate at normalized parameter $$t \\in [0,1]$$.\n\n    The angle is interpolated linearly:\n    $$\\theta(t) = \\theta_s + t \\cdot \\Delta\\theta.$$\n\n    Raises:\n    - ValueError if $$t \\notin [0,1]$$.\n    \"\"\"\n    if not 0.0 &lt;= t &lt;= 1.0:\n        raise ValueError(\"t must be in [0,1]\")\n    return self.theta_s + t * self.d_theta\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.CurveSegment.end_point","title":"<code>end_point() -&gt; Point</code>","text":"<p>Return the point at $\\(t = 1\\)$ (end of the arc).</p> Source code in <code>src\\multi_uav_planner\\path_model.py</code> <pre><code>def end_point(self) -&gt; Point:\n    \"\"\"Return the point at $$t = 1$$ (end of the arc).\"\"\"\n    return self.point_at(1.0)\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.CurveSegment.length","title":"<code>length() -&gt; float</code>","text":"<p>Return arc length: $\\(L = R \\cdot |\\Delta        heta|\\)$.</p> Source code in <code>src\\multi_uav_planner\\path_model.py</code> <pre><code>def length(self) -&gt; float:\n    \"\"\"Return arc length: $$L = R \\cdot |\\Delta\\theta|$$.\"\"\"\n    return abs(self.radius * self.d_theta)\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.CurveSegment.point_at","title":"<code>point_at(t: float) -&gt; Point</code>","text":"<p>Return the Cartesian point on the arc at normalized parameter $\\(t\\)$.</p> <p>Uses: $\\(x = x_c + R \\cos(     heta(t)), \\quad y = y_c + R \\sin(       heta(t)).\\)$</p> Source code in <code>src\\multi_uav_planner\\path_model.py</code> <pre><code>def point_at(self, t: float) -&gt; Point:\n    \"\"\"Return the Cartesian point on the arc at normalized parameter $$t$$.\n\n    Uses:\n    $$x = x_c + R \\cos(\\theta(t)), \\quad y = y_c + R \\sin(\\theta(t)).$$\n    \"\"\"\n    a = self.angle_at(t)\n    x = self.center[0] + self.radius * cos(a)\n    y = self.center[1] + self.radius * sin(a)\n    return (x, y)\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.CurveSegment.sample","title":"<code>sample(n: int) -&gt; List[Point]</code>","text":"<p>Return $\\(n\\)$ points sampled along the circular arc, including endpoints.</p> <p>Samples are taken at uniformly spaced parameter values $\\(t\\)$ in $\\([0,1]\\)$, so the angular spacing is uniform in parameter, not necessarily uniform in arc-length for non-constant curvature (not applicable here since curvature is constant). Requires $\\(n \\ge 2\\)$.</p> <p>Raises: - ValueError if $\\(n &lt; 2\\)$.</p> Source code in <code>src\\multi_uav_planner\\path_model.py</code> <pre><code>def sample(self, n: int) -&gt; List[Point]:\n    \"\"\"Return $$n$$ points sampled along the circular arc, including endpoints.\n\n    Samples are taken at uniformly spaced parameter values $$t$$ in\n    $$[0,1]$$, so the angular spacing is uniform in parameter, not\n    necessarily uniform in arc-length for non-constant curvature (not\n    applicable here since curvature is constant).\n    Requires $$n \\ge 2$$.\n\n    Raises:\n    - ValueError if $$n &lt; 2$$.\n    \"\"\"\n    if n &lt; 2:\n        raise ValueError(\"n must be &gt;= 2\")\n    return [self.point_at(i / (n - 1)) for i in range(n)]\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.CurveSegment.start_point","title":"<code>start_point() -&gt; Point</code>","text":"<p>Return the point at $\\(t = 0\\)$ (start of the arc).</p> Source code in <code>src\\multi_uav_planner\\path_model.py</code> <pre><code>def start_point(self) -&gt; Point:\n    \"\"\"Return the point at $$t = 0$$ (start of the arc).\"\"\"\n    return self.point_at(0.0)\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.Event","title":"<code>Event(time: float, kind: EventType, id: int, payload: Payload)</code>  <code>dataclass</code>","text":"<p>A scheduled event in the simulation or planner timeline.</p> <p>Ordering: - Events are ordered by their $\\(time\\)$ field so they can be stored in   a priority queue or list and processed chronologically.</p> <p>Fields: - time: trigger time (float, seconds). - kind: an EventType value. - id: user-defined integer id for the event (for bookkeeping). - payload: additional data whose type depends on $\\(kind\\)$. The payload   is excluded from ordering comparisons.</p> <p>Post-initialization checks: - For $$    ext{EventType.NEW_TASK}$$, payload must be a non-empty $\\(List[Task]\\)$. - For $$    ext{EventType.UAV_DAMAGE}$$, payload must be an $\\(int\\)$ representing the UAV id.</p>"},{"location":"api/multi_uav_planner/#multi_uav_planner.Event.should_trigger","title":"<code>should_trigger(world_time: float) -&gt; bool</code>","text":"<p>Return True if the event should trigger at or before the given world_time.</p> <p>This simple check allows event processing loops to pop events in time order and decide whether they are ready to fire.</p> Source code in <code>src\\multi_uav_planner\\world_models.py</code> <pre><code>def should_trigger(self, world_time: float) -&gt; bool:\n    \"\"\"\n    Return True if the event should trigger at or before the given world_time.\n\n    This simple check allows event processing loops to pop events in time\n    order and decide whether they are ready to fire.\n    \"\"\"\n    return world_time &gt;= self.time\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.EventType","title":"<code>EventType</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Event kind enumeration used for discrete simulation scheduling. - UAV_DAMAGE: payload is a UAV id (int) indicating the UAV becomes damaged. - NEW_TASK: payload is a non-empty List[Task] which should be added to the world.</p>"},{"location":"api/multi_uav_planner/#multi_uav_planner.LineSegment","title":"<code>LineSegment(start: Point, end: Point)</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Segment</code></p> <p>A straight line segment between two points.</p> <p>Attributes: - start: starting point as (x, y). - end: ending point as (x, y).</p> <p>Semantics: - length() returns the Euclidean distance between start and end. - point_at(t) returns the linear interpolation at normalized parameter   $\\(t \\in [0,1]\\)$ such that:   $$        ext{point_at}(0) =     ext{start}, \\quad       ext{point_at}(1) =     ext{end}.$$ - sample(n) returns $\\(n\\)$ evenly spaced points along the segment,   including endpoints; requires $\\(n \\ge 2\\)$.</p>"},{"location":"api/multi_uav_planner/#multi_uav_planner.LineSegment.end_point","title":"<code>end_point() -&gt; Point</code>","text":"<p>Return the end point of the segment.</p> Source code in <code>src\\multi_uav_planner\\path_model.py</code> <pre><code>def end_point(self) -&gt; Point:\n    \"\"\"Return the end point of the segment.\"\"\"\n    return self.end\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.LineSegment.point_at","title":"<code>point_at(t: float) -&gt; Point</code>","text":"<p>Return the point at normalized parameter $\\(t \\in [0,1]\\)$.</p> <pre><code>    Uses linear interpolation:\n    $$x = x_0 + t (x_1 - x_0), \\quad y = y_0 + t (y_1 - y_0).$$\n\n    Raises:\n    - ValueError if $$t\n</code></pre> <p>otin [0,1]$$.</p> Source code in <code>src\\multi_uav_planner\\path_model.py</code> <pre><code>def point_at(self, t: float) -&gt; Point:\n    \"\"\"Return the point at normalized parameter $$t \\in [0,1]$$.\n\n    Uses linear interpolation:\n    $$x = x_0 + t (x_1 - x_0), \\quad y = y_0 + t (y_1 - y_0).$$\n\n    Raises:\n    - ValueError if $$t \\notin [0,1]$$.\n    \"\"\"\n    if not 0.0 &lt;= t &lt;= 1.0:\n        raise ValueError(\"t must be in [0,1]\")\n    x = self.start[0] + t * (self.end[0] - self.start[0])\n    y = self.start[1] + t * (self.end[1] - self.start[1])\n    return (x, y)\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.LineSegment.sample","title":"<code>sample(n: int) -&gt; List[Point]</code>","text":"<p>Return $\\(n\\)$ points sampled uniformly along the segment.</p> <p>The returned list contains the start and end points and requires $\\(n \\ge 2\\)$ to include both endpoints.</p> <p>Raises: - ValueError if $\\(n &lt; 2\\)$.</p> Source code in <code>src\\multi_uav_planner\\path_model.py</code> <pre><code>def sample(self, n: int) -&gt; List[Point]:\n    \"\"\"Return $$n$$ points sampled uniformly along the segment.\n\n    The returned list contains the start and end points and requires\n    $$n \\ge 2$$ to include both endpoints.\n\n    Raises:\n    - ValueError if $$n &lt; 2$$.\n    \"\"\"\n    if n &lt; 2:\n        raise ValueError(\"n must be &gt;= 2\")\n    return [self.point_at(i / (n - 1)) for i in range(n)]\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.LineSegment.start_point","title":"<code>start_point() -&gt; Point</code>","text":"<p>Return the start point of the segment.</p> Source code in <code>src\\multi_uav_planner\\path_model.py</code> <pre><code>def start_point(self) -&gt; Point:\n    \"\"\"Return the start point of the segment.\"\"\"\n    return self.start\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.LineTask","title":"<code>LineTask(id: int, position: Tuple[float, float], state: Literal[0, 1, 2] = 0, heading_enforcement: bool = False, heading: Optional[float] = None, worked_by_uav: Optional[int] = None, length: float = 10.0)</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Task</code></p> <p>A line-type task that indicates the UAV should traverse a short line segment centered at the task position. Typical fields: - length: length of the line in meters (default: $\\(10.0\\)$).</p> <p>Interpretation: - The task position can be considered the midpoint or an endpoint;   specific geometric handling is the responsibility of the planner.</p>"},{"location":"api/multi_uav_planner/#multi_uav_planner.Path","title":"<code>Path(segments: List[Segment])</code>  <code>dataclass</code>","text":"<p>A sequence of segments forming a continuous path.</p> <p>Attributes: - segments: ordered list of Segment instances.</p> <p>Methods: - length(): total length obtained by summing segment lengths. - sample(samples_per_segment): sample each segment with the given   number of samples and concatenate results. To avoid duplicate points   at segment boundaries the first point of each subsequent segment is   omitted (since it equals the previous segment's last point).</p> <p>Sampling details: - Each segment is sampled with exactly $$   ext{samples_per_segment}$$   points (requires $\\(\\ge 2\\)$). - The returned list length will be:   $$        ext{len} = N \\cdot S - (N - 1)$$ where $\\(N\\)$ is the number of   segments and $\\(S\\)$ is $$  ext{samples_per_segment}$$ because junction   points are deduplicated.</p>"},{"location":"api/multi_uav_planner/#multi_uav_planner.Path.length","title":"<code>length() -&gt; float</code>","text":"<p>Return the total length of the path (sum of segment lengths).</p> Source code in <code>src\\multi_uav_planner\\path_model.py</code> <pre><code>def length(self) -&gt; float:\n    \"\"\"Return the total length of the path (sum of segment lengths).\"\"\"\n    return sum(s.length() for s in self.segments)\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.Path.sample","title":"<code>sample(samples_per_segment: int) -&gt; List[Point]</code>","text":"<p>Sample each segment and concatenate results, removing duplicate junctions.</p> <p>Parameters: - samples_per_segment: integer $\\(S \\ge 2\\)$, number of samples per segment.</p> <p>Returns: - List[Point]: concatenated sampled points for the whole path.</p> <p>Behavior: - For segment index $\\(i &gt; 0\\)$ the first sampled point of that segment   is dropped to avoid duplicating the shared endpoint with the   previous segment.</p> Source code in <code>src\\multi_uav_planner\\path_model.py</code> <pre><code>def sample(self, samples_per_segment: int) -&gt; List[Point]:\n    \"\"\"Sample each segment and concatenate results, removing duplicate junctions.\n\n    Parameters:\n    - samples_per_segment: integer $$S \\ge 2$$, number of samples per segment.\n\n    Returns:\n    - List[Point]: concatenated sampled points for the whole path.\n\n    Behavior:\n    - For segment index $$i &gt; 0$$ the first sampled point of that segment\n      is dropped to avoid duplicating the shared endpoint with the\n      previous segment.\n    \"\"\"\n    pts: List[Point] = []\n    for i, seg in enumerate(self.segments):\n        pts_seg = seg.sample(samples_per_segment)\n        if i &gt; 0:\n            # drop the first point to avoid duplicating the junction\n            # (the first point of seg equals the last point of previous seg)\n            pts_seg = pts_seg[1:]\n        pts.extend(pts_seg)\n    return pts\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.PointTask","title":"<code>PointTask(id: int, position: Tuple[float, float], state: Literal[0, 1, 2] = 0, heading_enforcement: bool = False, heading: Optional[float] = None, worked_by_uav: Optional[int] = None)</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Task</code></p> <p>A task located at a single point. No additional fields beyond Task. Use for simple point-inspection or waypoint-style tasks.</p>"},{"location":"api/multi_uav_planner/#multi_uav_planner.RunLog","title":"<code>RunLog(snapshots: List[Snapshot] = list(), stages: Tuple[str, ...] = ('init', 'triggering_events', 'assignment', 'after_move', 'end_tick (post_coverage)', 'planned_return'))</code>  <code>dataclass</code>","text":"<p>Collect time-indexed snapshots during a simulation run.</p> <p>Use the <code>hook()</code> method to obtain a callable suitable for <code>simulate_mission(on_step=...)</code> which will append snapshots for the stages listed in <code>stages</code>.</p> <p>Attributes: - snapshots: list of Snapshot objects (in chronological order). - stages: tuple of stage tags accepted by the hook (default set matches simulate_mission tags).</p>"},{"location":"api/multi_uav_planner/#multi_uav_planner.RunLog.hook","title":"<code>hook() -&gt; Callable[[World, str], None]</code>","text":"<p>Return an <code>on_step(world, stage)</code> callback that appends snapshots.</p> <p>The callback copies current sets and per-UAV fields so that the RunLog contains stable historical data (not references into mutable objects).</p> Source code in <code>src\\multi_uav_planner\\post_processing.py</code> <pre><code>def hook(self) -&gt; Callable[[World, str], None]:\n    \"\"\"Return an `on_step(world, stage)` callback that appends snapshots.\n\n    The callback copies current sets and per-UAV fields so that the RunLog\n    contains stable historical data (not references into mutable objects).\n    \"\"\"\n    def on_step(world, stage: str):\n        if stage not in self.stages:\n            return\n        snap = Snapshot(\n            time=world.time,\n            unassigned=sorted(world.unassigned),\n            assigned=sorted(world.assigned),\n            completed=sorted(world.completed),\n            uav_positions={uid: u.position for uid, u in world.uavs.items()},\n            uav_states={uid: u.state for uid, u in world.uavs.items()},\n            uav_range={uid: u.current_range for uid, u in world.uavs.items()},\n        )\n        self.snapshots.append(snap)\n    return on_step\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.RunLog.to_json","title":"<code>to_json() -&gt; Dict[str, Any]</code>","text":"<p>Convert the collected snapshots into a JSON-serializable dict.</p> Source code in <code>src\\multi_uav_planner\\post_processing.py</code> <pre><code>def to_json(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert the collected snapshots into a JSON-serializable dict.\"\"\"\n    return {\n        \"snapshots\": [\n            {\n                \"time\": s.time,\n                \"unassigned\": s.unassigned,\n                \"assigned\": s.assigned,\n                \"completed\": s.completed,\n                \"uav_positions\": s.uav_positions,\n                \"uav_states\": s.uav_states,\n                \"uav_range\": s.uav_range,\n            } for s in self.snapshots\n        ]\n    }\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.Scenario","title":"<code>Scenario(config: ScenarioConfig, tasks: List[Task], uavs: List[UAV], base: Tuple[float, float, float], events: List[Event] = list(), alg_type: AlgorithmType = AlgorithmType.PRBDD)</code>  <code>dataclass</code>","text":"<p>Container holding the result of scenario generation.</p> <p>Attributes: - $\\(config\\)$: the ScenarioConfig used to produce this scenario. - $\\(tasks\\)$: list of Task objects created. - $\\(uavs\\)$: list of UAV objects created and initially located at the base. - $\\(base\\)$: base pose $\\((x,y,heading)\\)$ used to initialize UAVs. - $\\(events\\)$: sorted list of Event objects (may be empty). - $\\(alg\\_type\\)$: chosen AlgorithmType for later use by planners.</p>"},{"location":"api/multi_uav_planner/#multi_uav_planner.ScenarioConfig","title":"<code>ScenarioConfig(base: Tuple[float, float, float] = (0.0, 0.0, 0.0), area_width: float = 2500.0, area_height: float = 2500.0, n_uavs: int = 4, n_tasks: int = 20, max_time: float = 1000000.0, p_point: float = 0.6, p_line: float = 0.2, p_circle: float = 0.1, p_area: float = 0.1, uav_speed: float = 17.5, turn_radius: float = 80.0, total_range: float = 0.0, max_range: float = 10000.0, tolerances: Tolerances = Tolerances(), alg_type: AlgorithmType = AlgorithmType.PRBDD, scenario_type: ScenarioType = ScenarioType.NONE, n_new_task: int = 0, n_damage: int = 0, ts_new_task: float = 0.0, tf_new_task: float = 0.0, ts_damage: float = 0.0, tf_damage: float = 0.0, seed: int = 0)</code>  <code>dataclass</code>","text":"<p>Configuration options controlling random scenario generation.</p> <p>Key fields: - $\\(base\\)$: base pose as $\\((x, y, heading)\\)$ (heading in radians). - $\\(area\\_width\\)$, $\\(area\\_height\\)$: sampling rectangle size for task positions. - $\\(n\\_uavs\\)$, $\\(n\\_tasks\\)$: numbers of initial UAVs and tasks. - Task-type probabilities $\\(p\\_point\\)$, $\\(p\\_line\\)$, $\\(p\\_circle\\)$, $\\(p\\_area\\)$ sum to 1.0   (used by the random sampler to choose task kinds). - UAV dynamics: $\\(uav\\_speed\\)$, $\\(turn\\_radius\\)$, $\\(total\\_range\\)$, $\\(max\\_range\\)$. - Tolerances: defaults are provided and are propagated to the World on init. - Scenario dynamics: $\\(scenario\\_type\\)$ determines whether to create delayed   new-task or damage events; counts and time windows control event creation. - $\\(seed\\)$: RNG seed for reproducibility.</p>"},{"location":"api/multi_uav_planner/#multi_uav_planner.ScenarioType","title":"<code>ScenarioType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Kinds of dynamic scenario events supported.</p>"},{"location":"api/multi_uav_planner/#multi_uav_planner.Segment","title":"<code>Segment()</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract interface for a path segment.</p> <p>A Segment represents a contiguous piece of a geometric path. Concrete implementations must provide: - length(): length of the segment (non-negative float). - sample(n): an ordered list of $\\(n\\)$ points sampled along the segment,   including both endpoints. - start_point() and end_point(): coordinates of the segment endpoints.</p> <p>Implementations should accept the normalized parameter $\\(t \\in [0,1]\\)$ for point evaluation (if they expose such a method).</p>"},{"location":"api/multi_uav_planner/#multi_uav_planner.Snapshot","title":"<code>Snapshot(time: float, unassigned: List[int], assigned: List[int], completed: List[int], uav_positions: Dict[int, Tuple[float, float, float]], uav_states: Dict[int, int], uav_range: Dict[int, float])</code>  <code>dataclass</code>","text":"<p>Immutable data snapshot captured at a simulation stage.</p> <p>Fields: - time: simulation time for the snapshot. - unassigned, assigned, completed: sorted lists of task ids (copied at capture time). - uav_positions: map uav_id -&gt; (x, y, heading). - uav_states: map uav_id -&gt; state code (0 idle, 1 transit, 2 busy, 3 damaged). - uav_range: map uav_id -&gt; cumulative executed distance (meters) at snapshot time.</p>"},{"location":"api/multi_uav_planner/#multi_uav_planner.Task","title":"<code>Task(id: int, position: Tuple[float, float], state: Literal[0, 1, 2] = 0, heading_enforcement: bool = False, heading: Optional[float] = None, worked_by_uav: Optional[int] = None)</code>  <code>dataclass</code>","text":"<p>Base class for a task (work item) to be performed by a UAV.</p> <p>Common fields: - id: unique integer identifier for the task. - position: 2D coordinates $\\((x, y)\\)$ representing the task location. - state: task lifecycle state with values:     - $\\(0\\)$: unassigned     - $\\(1\\)$: assigned     - $\\(2\\)$: completed   The type is declared as a Literal for clarity. - heading_enforcement: if True, the task requires the UAV to arrive   with a specific heading; otherwise arrival heading is unconstrained. - heading: optional heading in radians that is meaningful only when   $\\(heading\\_enforcement\\)$ is True. - worked_by_uav: optional id of the UAV currently assigned or working the task.</p> <p>Note: - This class carries only lightweight metadata; task execution details   (e.g., how to traverse an AreaTask) are handled elsewhere.</p>"},{"location":"api/multi_uav_planner/#multi_uav_planner.TaskClusterResult","title":"<code>TaskClusterResult(clusters: Dict[int, List[Task]], centers: np.ndarray, task_to_cluster: Dict[int, int])</code>  <code>dataclass</code>","text":"<p>Result container for K-means task clustering.</p> <p>Attributes:</p> Name Type Description <code>clusters</code> <code>Dict[int, List[Task]]</code> <p>Mapping from cluster index -&gt; list of Task objects assigned to that cluster. Keys are integers in $\\([0, K-1]\\)$.</p> <code>centers</code> <code>ndarray</code> <p>Numpy array of shape $\\((K, 2)\\)$ containing cluster center coordinates $\\((x, y)\\)$ for each cluster index.</p> <code>task_to_cluster</code> <code>Dict[int, int]</code> <p>Mapping from task id (int) to the assigned cluster index.</p>"},{"location":"api/multi_uav_planner/#multi_uav_planner.TimeRegistry","title":"<code>TimeRegistry(wall: Dict[str, float] = dict(), cpu: Dict[str, float] = dict(), calls: Dict[str, int] = dict())</code>  <code>dataclass</code>","text":"<p>Collect and accumulate timing statistics across labeled operations.</p> <p>Use-case: register timings from many calls to the same labeled operation and later query aggregated totals and averages.</p> <p>Stored fields: - wall: map label -&gt; total wall-clock seconds. - cpu: map label -&gt; total CPU seconds. - calls: map label -&gt; number of times the label was recorded.</p> <p>Methods: - add(label, wall, cpu): add a single timing record. - summary(): return a dict keyed by label with aggregated totals and averages.</p>"},{"location":"api/multi_uav_planner/#multi_uav_planner.TimeRegistry.add","title":"<code>add(label: str, wall: float, cpu: float)</code>","text":"<p>Accumulate one timing measurement for the given label.</p> Source code in <code>src\\multi_uav_planner\\post_processing.py</code> <pre><code>def add(self, label: str, wall: float, cpu: float):\n    \"\"\"Accumulate one timing measurement for the given label.\"\"\"\n    self.wall[label] = self.wall.get(label, 0.0) + wall\n    self.cpu[label] = self.cpu.get(label, 0.0) + cpu\n    self.calls[label] = self.calls.get(label, 0) + 1\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.TimeRegistry.summary","title":"<code>summary() -&gt; Dict[str, Dict[str, float]]</code>","text":"<p>Return per-label aggregated stats including totals and averages.</p> <p>For each label the returned dict contains: - wall_total, cpu_total, calls, wall_avg, cpu_avg</p> Source code in <code>src\\multi_uav_planner\\post_processing.py</code> <pre><code>def summary(self) -&gt; Dict[str, Dict[str, float]]:\n    \"\"\"Return per-label aggregated stats including totals and averages.\n\n    For each label the returned dict contains:\n    - wall_total, cpu_total, calls, wall_avg, cpu_avg\n    \"\"\"\n    out = {}\n    for k in sorted(self.wall.keys()):\n        n = self.calls.get(k, 1)\n        out[k] = {\n            \"wall_total\": self.wall[k],\n            \"cpu_total\": self.cpu[k],\n            \"calls\": n,\n            \"wall_avg\": self.wall[k] / n,\n            \"cpu_avg\": self.cpu[k] / n,\n        }\n    return out\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.Timer","title":"<code>Timer(label: str = 'block')</code>  <code>dataclass</code>","text":"<p>Context manager that measures wall-clock and CPU time for a code block.</p> Usage <p>with Timer(\"label\") as t:...  # code to profile print(t.elapsed_wall, t.elapsed_cpu)</p> <p>Attributes: - label: user-supplied name to identify the timed block. - start_wall: wall-clock timestamp recorded on entry (perf_counter). - start_cpu: process CPU time recorded on entry (process_time). - elapsed_wall: wall-clock duration on exit (seconds). - elapsed_cpu: CPU time duration on exit (seconds).</p>"},{"location":"api/multi_uav_planner/#multi_uav_planner.Tolerances","title":"<code>Tolerances(pos: float = 0.001, ang: float = 0.001, time: float = 1e-06)</code>  <code>dataclass</code>","text":"<p>Numeric tolerances used across the planner.</p> <p>Attributes: - pos: position tolerance in meters (default: $\\(1\\mathrm{e}{-3}\\)$). - ang: angular tolerance in radians (default: $\\(1\\mathrm{e}{-3}\\)$). - time: time epsilon in seconds (default: $\\(1\\mathrm{e}{-6}\\)$).</p> <p>Use an instance of this class to centralize tolerance choices so that assertions and proximity checks remain consistent across modules.</p>"},{"location":"api/multi_uav_planner/#multi_uav_planner.UAV","title":"<code>UAV(id: int, position: Tuple[float, float, float] = (0.0, 0.0, 0.0), speed: float = 17.5, turn_radius: float = 80.0, state: Literal[0, 1, 2, 3] = 0, cluster: Optional[Set[int]] = set(), cluster_CoG: Optional[Tuple[float, float]] = None, current_task: Optional[int] = None, assigned_path: Optional[Path] = None, current_range: float = 0.0, max_range: float = 10000.0)</code>  <code>dataclass</code>","text":"<p>Represents the state and capabilities of a single UAV.</p> <p>Fields: - id: integer UAV identifier. - position: current pose as $\\((x, y, heading)\\)$; heading in radians. - speed: nominal cruise speed in meters per second. - turn_radius: minimum turning radius in meters (used for path generation). - state: integer UAV status:     - $\\(0\\)$: idle     - $\\(1\\)$: in-transit (moving to a target)     - $\\(2\\)$: busy (executing a task)     - $\\(3\\)$: damaged/unavailable - cluster: optional set of assigned task ids (useful for clustering-based planners). - cluster_CoG: optional center-of-gravity coordinates for the cluster. - current_task: optional id of the task currently being executed. - assigned_path: optional Path instance representing planned route. - current_range: current remaining range in meters. - max_range: maximum mission range in meters.</p> <p>Remarks: - Many fields are optional so the planner can annotate UAVs gradually   (e.g., assign a path only when planning is completed).</p>"},{"location":"api/multi_uav_planner/#multi_uav_planner.World","title":"<code>World(tasks: Dict[int, Task], uavs: Dict[int, UAV], base: Tuple[float, float, float] = (0.0, 0.0, 0.0), time: float = 0.0, events: List[Event] = list(), events_cursor: int = 0, unassigned: Set[int] = set(), assigned: Set[int] = set(), completed: Set[int] = set(), idle_uavs: Set[int] = set(), transit_uavs: Set[int] = set(), busy_uavs: Set[int] = set(), damaged_uavs: Set[int] = set(), tols: Tolerances = Tolerances())</code>  <code>dataclass</code>","text":"<p>Global container holding the planner simulation state.</p> <p>Responsibilities: - Maintain dictionaries of tasks and UAVs keyed by id. - Track base location and global time. - Hold pending events and a cursor for sequential event processing. - Maintain partitions of task and UAV id sets (unassigned/assigned/completed,   idle/transit/busy/damaged) to enable fast membership checks.</p> <p>Fields: - tasks: Dict[id, Task] containing all task objects in the world. - uavs: Dict[id, UAV] containing UAV state objects. - base: base pose as $\\((x, y, heading)\\)$ (heading used when returning to base). - time: current simulation/planner time (float seconds). - events: chronological list of scheduled Event objects. - events_cursor: index used when iterating events incrementally. - unassigned/assigned/completed: sets partitioning task ids. - idle_uavs/transit_uavs/busy_uavs/damaged_uavs: sets partitioning UAV ids. - tols: Tolerances instance controlling numeric comparisons.</p>"},{"location":"api/multi_uav_planner/#multi_uav_planner.World.at_base","title":"<code>at_base(p_tol: Optional[float] = None, a_tol: Optional[float] = None) -&gt; bool</code>","text":"<p>Return True if all non-damaged UAVs are within positional and (optionally) angular tolerance of the base.</p> <ul> <li>$\\(p\\_tol\\)$: optional override for the position tolerance (meters).             If None, uses $$    ext{tols.pos}$$.</li> <li>$\\(a\\_tol\\)$: optional override for angular tolerance (radians).             If None, uses $$    ext{tols.ang}$$.</li> </ul> <p>Notes: - Damaged UAVs (state == $\\(3\\)\\() are ignored in this check. - The angular comparison is present but commented out by default. The   commented code computes the minimal signed angular difference using   a standard wrap-to-\\)\\([-\\pi,\\pi]\\)$ formula:   $$     \\left| \big( (h - bh + \\pi) \bmod 2\\pi \big) - \\pi  ight|   $$   which yields the smallest absolute angular difference between   UAV heading $\\(h\\)$ and base heading $\\(bh\\)$. Uncomment those lines   if heading alignment to base should be enforced.</p> Source code in <code>src\\multi_uav_planner\\world_models.py</code> <pre><code>    def at_base(self, p_tol: Optional[float] = None, a_tol: Optional[float] = None) -&gt; bool:\n        \"\"\"\n        Return True if all non-damaged UAVs are within positional and (optionally)\n        angular tolerance of the base.\n\n        Parameters:\n        - $$p\\_tol$$: optional override for the position tolerance (meters).\n                    If None, uses $$\\text{tols.pos}$$.\n        - $$a\\_tol$$: optional override for angular tolerance (radians).\n                    If None, uses $$\\text{tols.ang}$$.\n\n        Notes:\n        - Damaged UAVs (state == $$3$$) are ignored in this check.\n        - The angular comparison is present but commented out by default. The\n          commented code computes the minimal signed angular difference using\n          a standard wrap-to-$$[-\\pi,\\pi]$$ formula:\n          $$\n            \\left| \\big( (h - bh + \\pi) \\bmod 2\\pi \\big) - \\pi \\right|\n          $$\n          which yields the smallest absolute angular difference between\n          UAV heading $$h$$ and base heading $$bh$$. Uncomment those lines\n          if heading alignment to base should be enforced.\n        \"\"\"\n        p_tol = self.tols.pos if p_tol is None else p_tol\n        a_tol = self.tols.ang if a_tol is None else a_tol\n\n        bx,by,bh = self.base\n        for u in self.uavs.values():\n            # Skip damaged UAVs when determining whether the fleet is at base.\n            if u.state == 3:\n                continue\n            x,y,h = u.position\n            # Positional check: ensure both x and y are within the tolerance.\n            if abs(x-bx)&gt;p_tol or abs(y-by)&gt;p_tol:\n                return False\n            # Angular check (disabled by default): use modulo arithmetic to\n            # compute the smallest absolute angular difference between the UAV\n            # heading and the base heading. The formula below maps the raw\n            # difference into $$[-\\pi,\\pi]$$ and takes the absolute value.\n            # Uncomment to enable heading verification.\n#            if abs((h-bh + pi)%(2*pi)-pi)&gt;a_tol:\n#                return False\n        return True\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.World.done","title":"<code>done() -&gt; bool</code>","text":"<p>Return True if there are no remaining tasks to assign or complete.</p> <p>The world is considered finished when both the unassigned and assigned task sets are empty (completed tasks may remain in the completed set).</p> Source code in <code>src\\multi_uav_planner\\world_models.py</code> <pre><code>def done(self) -&gt; bool:\n    \"\"\"\n    Return True if there are no remaining tasks to assign or complete.\n\n    The world is considered finished when both the unassigned and assigned\n    task sets are empty (completed tasks may remain in the completed set).\n    \"\"\"\n    return not self.unassigned and not self.assigned\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.World.is_initialized","title":"<code>is_initialized() -&gt; bool</code>","text":"<p>Sanity-check that the World has been initialized consistently.</p> <p>Checks performed: - If $\\(time &gt; 0\\)$ we assume initialization has happened (early-exit). - Both tasks and uavs dictionaries are non-empty. - Base pose is a 3-tuple. - Task id sets form a partition of the keys in tasks. - UAV id sets form a partition of the keys in uavs and are disjoint. - No overlapping ids across partitions.</p> <p>Returns True if all checks pass, False otherwise.</p> Source code in <code>src\\multi_uav_planner\\world_models.py</code> <pre><code>def is_initialized(self) -&gt; bool:\n    \"\"\"\n    Sanity-check that the World has been initialized consistently.\n\n    Checks performed:\n    - If $$time &gt; 0$$ we assume initialization has happened (early-exit).\n    - Both tasks and uavs dictionaries are non-empty.\n    - Base pose is a 3-tuple.\n    - Task id sets form a partition of the keys in tasks.\n    - UAV id sets form a partition of the keys in uavs and are disjoint.\n    - No overlapping ids across partitions.\n\n    Returns True if all checks pass, False otherwise.\n    \"\"\"\n    # If time has advanced, we treat the world as already initialized.\n    if self.time &gt; 0: \n        return True\n\n    # tasks and uavs must be present for a meaningful simulation.\n    if not self.tasks or not self.uavs:\n        return False\n\n    # Base must be a 3-tuple: (x, y, heading)\n    if not (isinstance(self.base, tuple) and len(self.base) == 3):\n        return False\n\n    task_ids = set(self.tasks.keys())\n    # Tasks partition check:\n    # Ensure the union of task sets equals the set of declared task ids.\n    if (self.unassigned | self.assigned | self.completed) != task_ids:\n        return False\n    # Ensure pairwise disjointness of task partitions:\n    if (self.unassigned &amp; self.assigned) or (self.unassigned &amp; self.completed) or (self.assigned &amp; self.completed):\n        return False\n\n    uav_ids  = set(self.uavs.keys())\n    # UAVs partition check: union should equal declared UAV ids\n    if (self.idle_uavs | self.transit_uavs | self.busy_uavs | self.damaged_uavs) != uav_ids:\n        return False\n    # Pairwise disjointness checks for UAV partitions:\n    if (self.idle_uavs &amp; self.transit_uavs) or (self.idle_uavs &amp; self.busy_uavs) or (self.transit_uavs &amp; self.busy_uavs) or (self.damaged_uavs &amp; (self.idle_uavs | self.transit_uavs | self.busy_uavs)):\n        return False\n\n    return True\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.aggregate_metrics","title":"<code>aggregate_metrics(world, runlog: RunLog) -&gt; Dict[str, Any]</code>","text":"<p>Convenience aggregator that bundles several key post-run metrics.</p> Source code in <code>src\\multi_uav_planner\\post_processing.py</code> <pre><code>def aggregate_metrics(world, runlog: RunLog) -&gt; Dict[str, Any]:\n    \"\"\"Convenience aggregator that bundles several key post-run metrics.\"\"\"\n    return {\n        \"world_summary\": summarize_world(world),\n        \"uav_distances\": compute_uav_distances(runlog),\n        \"uav_state_durations\": compute_uav_state_durations(runlog),\n        \"task_latencies\": compute_task_latencies(runlog, initial_time=0.0),\n    }\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.assign_clusters_to_uavs_by_proximity","title":"<code>assign_clusters_to_uavs_by_proximity(uavs: List[UAV], cluster_centers: np.ndarray) -&gt; Dict[int, int]</code>","text":"<p>Assign each cluster to a distinct UAV by approximate proximity.</p> <pre><code>This routine forms a cost matrix of squared Euclidean distances between\neach UAV position and each cluster center, then calls a greedy assignment\nroutine to produce a one-to-one mapping from clusters to UAVs.\n\nRequirements and behavior:\n- `cluster_centers` must be an array of shape $$(K, 2)$$.\n- The function currently expects $$K =      ext{len(uavs)}$$ (one cluster per UAV).\n  If the numbers differ a ValueError is raised.\n- Costs are squared Euclidean distances (no sqrt) so:\n  $$        ext{cost}_{i,j} = (x_{c_j} - x_{u_i})^2 + (y_{c_j} - y_{u_i})^2.$$\n- The greedy global assignment function `greedy_global_assign_int` is used to\n  select worker-task pairs (here UAV-cluster pairs) without reuse of UAVs\n  or clusters. The returned mapping is cluster_index -&gt; uav_id.\n\nArgs:\n    uavs: list of UAV objects; each `uav.position` is $$(x,y,heading)$$.\n    cluster_centers: numpy array of cluster centers shape $$(K,2)$$.\n\nReturns:\n    Dictionary mapping `cluster_index -&gt; uav.id`.\n\nRaises:\n    ValueError: if `cluster_centers` does not have shape $$(K,2)$$ or if\n                $$K\n</code></pre> <p>e       ext{len(uavs)}$$.</p> Source code in <code>src\\multi_uav_planner\\clustering.py</code> <pre><code>def assign_clusters_to_uavs_by_proximity(\n    uavs: List[UAV],\n    cluster_centers: np.ndarray,\n) -&gt; Dict[int, int]:\n    \"\"\"Assign each cluster to a distinct UAV by approximate proximity.\n\n    This routine forms a cost matrix of squared Euclidean distances between\n    each UAV position and each cluster center, then calls a greedy assignment\n    routine to produce a one-to-one mapping from clusters to UAVs.\n\n    Requirements and behavior:\n    - `cluster_centers` must be an array of shape $$(K, 2)$$.\n    - The function currently expects $$K = \\text{len(uavs)}$$ (one cluster per UAV).\n      If the numbers differ a ValueError is raised.\n    - Costs are squared Euclidean distances (no sqrt) so:\n      $$\\text{cost}_{i,j} = (x_{c_j} - x_{u_i})^2 + (y_{c_j} - y_{u_i})^2.$$\n    - The greedy global assignment function `greedy_global_assign_int` is used to\n      select worker-task pairs (here UAV-cluster pairs) without reuse of UAVs\n      or clusters. The returned mapping is cluster_index -&gt; uav_id.\n\n    Args:\n        uavs: list of UAV objects; each `uav.position` is $$(x,y,heading)$$.\n        cluster_centers: numpy array of cluster centers shape $$(K,2)$$.\n\n    Returns:\n        Dictionary mapping `cluster_index -&gt; uav.id`.\n\n    Raises:\n        ValueError: if `cluster_centers` does not have shape $$(K,2)$$ or if\n                    $$K \\ne \\text{len(uavs)}$$.\n    \"\"\"\n    cluster_centers = np.asarray(cluster_centers, dtype=float)\n    if cluster_centers.ndim != 2 or cluster_centers.shape[1] != 2:\n        raise ValueError(\"cluster_centers must have shape (K, 2)\")\n\n    K = cluster_centers.shape[0]\n    if K != len(uavs):\n        raise ValueError(\n            f\"Number of clusters ({K}) must equal number of UAVs ({len(uavs)}) \"\n            \"for this assignment rule.\"\n        )\n\n    # Build cost matrix: squared Euclidean distances between UAV i and cluster j\n    costs = np.zeros((K, K), dtype=float)\n    for i, uav in enumerate(uavs):\n        ux, uy, _ = uav.position  # heading ignored for clustering\n        for j in range(K):\n            cx, cy = cluster_centers[j]\n            dx = cx - ux\n            dy = cy - uy\n            costs[i, j] = dx * dx + dy * dy\n\n    # Greedy integer assignment returns a list `assignment` of length K where\n    # assignment[i] = j indicates UAV i -&gt; cluster j (or -1 if unassigned).\n    assignment = greedy_global_assign_int(costs)\n\n    # Convert assignment (indexed by UAV index) to mapping cluster_index -&gt; uav_id\n    cluster_to_uav: Dict[int, int] = {}\n    for i in range(K):\n        assigned_cluster = assignment[i]\n        if assigned_cluster is not None and assigned_cluster &gt;= 0:\n            # Map cluster index -&gt; UAV id\n            cluster_to_uav[assigned_cluster] = uavs[i].id\n    return cluster_to_uav\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.cluster_tasks","title":"<code>cluster_tasks(world: World) -&gt; Optional[Dict[int, Set[int]]]</code>","text":"<p>High-level clustering pipeline that assigns unassigned tasks to idle UAVs.</p> <p>Steps performed: 1. Collect unassigned Task objects from <code>world.unassigned</code>. 2. If there are no unassigned tasks or no idle UAVs, return None. 3. Choose $\\(K = \\min(\\#     ext{idle\\_uavs}, \\#     ext{unassigned\\_tasks})\\)$ clusters. 4. Run <code>cluster_tasks_kmeans</code> to partition tasks into $\\(K\\)$ clusters. 5. Map clusters to idle UAVs using <code>assign_clusters_to_uavs_by_proximity</code>. 6. For each assigned cluster <code>k -&gt; uid</code>, update:     - <code>world.uavs[uid].cluster</code> as the set of task ids in cluster <code>k</code>.     - <code>world.uavs[uid].cluster_CoG</code> as the cluster center coordinates (floats). 7. Return a dictionary mapping <code>uav_id -&gt; set(task_ids)</code> for the newly assigned clusters.</p> <p>Returns:</p> Type Description <code>Optional[Dict[int, Set[int]]]</code> <p>A mapping <code>uid -&gt; set(task_ids)</code> when clustering occurs, or None if no</p> <code>Optional[Dict[int, Set[int]]]</code> <p>clustering was performed (e.g., no idle UAVs or no unassigned tasks).</p> Source code in <code>src\\multi_uav_planner\\clustering.py</code> <pre><code>def cluster_tasks(world: World) -&gt; Optional[Dict[int, Set[int]]]:\n    \"\"\"High-level clustering pipeline that assigns unassigned tasks to idle UAVs.\n\n    Steps performed:\n    1. Collect unassigned Task objects from `world.unassigned`.\n    2. If there are no unassigned tasks or no idle UAVs, return None.\n    3. Choose $$K = \\min(\\#\\text{idle\\_uavs}, \\#\\text{unassigned\\_tasks})$$ clusters.\n    4. Run `cluster_tasks_kmeans` to partition tasks into $$K$$ clusters.\n    5. Map clusters to idle UAVs using `assign_clusters_to_uavs_by_proximity`.\n    6. For each assigned cluster `k -&gt; uid`, update:\n        - `world.uavs[uid].cluster` as the set of task ids in cluster `k`.\n        - `world.uavs[uid].cluster_CoG` as the cluster center coordinates (floats).\n    7. Return a dictionary mapping `uav_id -&gt; set(task_ids)` for the newly assigned clusters.\n\n    Returns:\n        A mapping `uid -&gt; set(task_ids)` when clustering occurs, or None if no\n        clustering was performed (e.g., no idle UAVs or no unassigned tasks).\n    \"\"\"\n    # Collect Task objects for unassigned task ids\n    unassigned_tasks = [world.tasks[tid] for tid in world.unassigned]\n    if not unassigned_tasks or not world.idle_uavs:\n        return None  # Nothing to cluster\n\n    result: Dict[int, Set[int]] = {}\n\n    # Choose number of clusters: at most the number of idle UAVs and the number of tasks\n    K = min(len(world.idle_uavs), len(unassigned_tasks))\n    clustering_result = cluster_tasks_kmeans(\n        unassigned_tasks,\n        n_clusters=K,\n        random_state=0,\n    )\n\n    # Map clusters to idle UAVs ordered arbitrarily as a list\n    idle_uavs_list = [world.uavs[uid] for uid in world.idle_uavs]\n    cluster_to_uav = assign_clusters_to_uavs_by_proximity(\n        idle_uavs_list,\n        clustering_result.centers,\n    )\n\n    # Update world.uavs for each assigned cluster\n    for k, uid in cluster_to_uav.items():\n        world.uavs[uid].cluster = {t.id for t in clustering_result.clusters[k]}\n        cx, cy = clustering_result.centers[k]\n        world.uavs[uid].cluster_CoG = (float(cx), float(cy))\n        result[uid] = world.uavs[uid].cluster\n\n    return result\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.cluster_tasks_kmeans","title":"<code>cluster_tasks_kmeans(tasks: List[Task], n_clusters: int, random_state: int = 42) -&gt; TaskClusterResult</code>","text":"<p>Cluster tasks into $\\(K\\)$ groups using K-means on their 2D positions.</p> <p>Parameters:</p> Name Type Description Default <code>tasks</code> <code>List[Task]</code> <p>list of Task objects (each must have a 2D <code>position</code>).</p> required <code>n_clusters</code> <code>int</code> <p>desired number of clusters $\\(K\\)$ (commonly equal to number of UAVs).</p> required <code>random_state</code> <code>int</code> <p>seed for KMeans initialization for reproducibility.</p> <code>42</code> <p>Returns:</p> Type Description <code>TaskClusterResult</code> <p>TaskClusterResult containing:</p> <code>TaskClusterResult</code> <ul> <li>clusters: dict mapping cluster index -&gt; List[Task]</li> </ul> <code>TaskClusterResult</code> <ul> <li>centers: $\\(K  imes 2\\)$ array with cluster centers</li> </ul> <code>TaskClusterResult</code> <ul> <li>task_to_cluster: mapping from task id -&gt; cluster index</li> </ul> <p>Raises:</p> Type Description <code>ValueError</code> <p>if <code>tasks</code> is empty, or if <code>n_clusters</code> is not in $\\([1, N]\\)$         where $\\(N\\)$ is the number of tasks.</p> Source code in <code>src\\multi_uav_planner\\clustering.py</code> <pre><code>def cluster_tasks_kmeans(\n    tasks: List[Task],\n    n_clusters: int,\n    random_state: int = 42,\n) -&gt; TaskClusterResult:\n    \"\"\"Cluster tasks into $$K$$ groups using K-means on their 2D positions.\n\n    Args:\n        tasks: list of Task objects (each must have a 2D `position`).\n        n_clusters: desired number of clusters $$K$$ (commonly equal to number of UAVs).\n        random_state: seed for KMeans initialization for reproducibility.\n\n    Returns:\n        TaskClusterResult containing:\n        - clusters: dict mapping cluster index -&gt; List[Task]\n        - centers: $$K \\times 2$$ array with cluster centers\n        - task_to_cluster: mapping from task id -&gt; cluster index\n\n    Raises:\n        ValueError: if `tasks` is empty, or if `n_clusters` is not in $$[1, N]$$\n                    where $$N$$ is the number of tasks.\n    \"\"\"\n    if not tasks:\n        raise ValueError(\"tasks list must be non-empty\")\n    if n_clusters &lt;= 0:\n        raise ValueError(\"n_clusters must be positive\")\n    if n_clusters &gt; len(tasks):\n        raise ValueError(\"n_clusters cannot exceed number of tasks\")\n\n    # Build data matrix for K-means: shape (N, 2)\n    X = _extract_task_positions(tasks)\n\n    kmeans = KMeans(\n        n_clusters=n_clusters,\n        n_init=10,\n        random_state=random_state,\n    )\n    labels = kmeans.fit_predict(X)\n    centers = kmeans.cluster_centers_\n\n    # Organize tasks by cluster label and construct id-&gt;cluster map\n    clusters: Dict[int, List[Task]] = {i: [] for i in range(n_clusters)}\n    task_to_cluster: Dict[int, int] = {}\n\n    for task, label in zip(tasks, labels):\n        label_int = int(label)\n        clusters[label_int].append(task)\n        task_to_cluster[task.id] = label_int\n\n    return TaskClusterResult(\n        clusters=clusters,\n        centers=centers,\n        task_to_cluster=task_to_cluster,\n    )\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.compute_cost","title":"<code>compute_cost(world: World, uav_ids: Iterable[int], task_ids: Iterable[int], use_dubins: bool)</code>","text":"<p>Construct a cost matrix for the specified UAV ids (rows) and task ids (cols).</p> Returns a tuple <ul> <li>$\\(C\\)$: list of lists representing the cost matrix (shape $\\(n    imes m\\)$).</li> <li>$\\(uav\\_ids\\_list\\)$: list mapping row index -&gt; uav_id.</li> <li>$\\(task\\_ids\\_list\\)$: list mapping column index -&gt; task_id.</li> <li>$\\(uav\\_index\\)$: dict mapping uav_id -&gt; row index.</li> <li>$\\(task\\_index\\)$: dict mapping task_id -&gt; column index.</li> </ul> <p>Cost semantics: - If $\\(use\\_dubins\\)$ is True the cost is the length of the Dubins-style path   returned by <code>plan_path_to_task(world, uid, (x_e, y_e,     heta_e))</code>. - Otherwise the cost is the Euclidean distance:   $$        ext{cost} = \\sqrt{(x_e - x_s)^2 + (y_e - y_s)^2}.$$</p> <p>Notes: - Returned matrix $\\(C\\)$ is a list-of-lists (row-major). The function does not   attempt to normalize or scale costs; callers should be aware of absolute scales.</p> Source code in <code>src\\multi_uav_planner\\assignment.py</code> <pre><code>def compute_cost(\n    world: World,\n    uav_ids: Iterable[int],\n    task_ids: Iterable[int],\n    use_dubins: bool,\n):\n    \"\"\"\n    Construct a cost matrix for the specified UAV ids (rows) and task ids (cols).\n\n    Returns a tuple:\n      - $$C$$: list of lists representing the cost matrix (shape $$n \\times m$$).\n      - $$uav\\_ids\\_list$$: list mapping row index -&gt; uav_id.\n      - $$task\\_ids\\_list$$: list mapping column index -&gt; task_id.\n      - $$uav\\_index$$: dict mapping uav_id -&gt; row index.\n      - $$task\\_index$$: dict mapping task_id -&gt; column index.\n\n    Cost semantics:\n    - If $$use\\_dubins$$ is True the cost is the length of the Dubins-style path\n      returned by `plan_path_to_task(world, uid, (x_e, y_e, \\theta_e))`.\n    - Otherwise the cost is the Euclidean distance:\n      $$\\text{cost} = \\sqrt{(x_e - x_s)^2 + (y_e - y_s)^2}.$$\n\n    Notes:\n    - Returned matrix $$C$$ is a list-of-lists (row-major). The function does not\n      attempt to normalize or scale costs; callers should be aware of absolute scales.\n    \"\"\"\n    uav_ids_list = list(uav_ids)\n    task_ids_list = list(task_ids)\n\n    uav_index = {uid: i for i, uid in enumerate(uav_ids_list)}\n    task_index = {tid: j for j, tid in enumerate(task_ids_list)}\n\n    n = len(uav_ids_list)\n    m = len(task_ids_list)\n\n    C = [[0.0 for _ in range(m)] for _ in range(n)]\n\n    for uid in uav_ids_list:\n        i = uav_index[uid]\n        for tid in task_ids_list:\n            j = task_index[tid]\n            if use_dubins:\n                # Use full path planner to compute a feasible/realistic cost (path length)\n                t = world.tasks[tid]\n                xe, ye = t.position\n                the = t.heading if t.heading_enforcement else None\n\n                p = plan_path_to_task(world, uid, (xe, ye, the))\n                C[i][j] = p.length()\n            else:\n                # Simple Euclidean distance (fast proxy cost)\n                xs, ys, _ = world.uavs[uid].position\n                xe, ye = world.tasks[tid].position\n                C[i][j] = math.hypot(xe - xs, ye - ys)\n\n    return C, uav_ids_list, task_ids_list, uav_index, task_index\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.compute_task_latencies","title":"<code>compute_task_latencies(runlog: RunLog, initial_time: float = 0.0) -&gt; Dict[int, Dict[str, float]]</code>","text":"<p>Compute per-task latency metrics using snapshots.</p> <p>For each task id, the returned dict contains:   - time_assigned: first timestamp the task appears in the <code>assigned</code> set.   - time_completed: first timestamp the task appears in the <code>completed</code> set.   - wait_to_assign = time_assigned - initial_time   - wait_to_complete = time_completed - initial_time</p> <p>Notes: - If a task never appears in <code>assigned</code> or <code>completed</code>, the corresponding value is NaN. - If NEW_TASK events occur mid-simulation, consider passing a task-specific   <code>initial_time</code> when interpreting waits.</p> Source code in <code>src\\multi_uav_planner\\post_processing.py</code> <pre><code>def compute_task_latencies(runlog: RunLog, initial_time: float = 0.0) -&gt; Dict[int, Dict[str, float]]:\n    \"\"\"\n    Compute per-task latency metrics using snapshots.\n\n    For each task id, the returned dict contains:\n      - time_assigned: first timestamp the task appears in the `assigned` set.\n      - time_completed: first timestamp the task appears in the `completed` set.\n      - wait_to_assign = time_assigned - initial_time\n      - wait_to_complete = time_completed - initial_time\n\n    Notes:\n    - If a task never appears in `assigned` or `completed`, the corresponding value is NaN.\n    - If NEW_TASK events occur mid-simulation, consider passing a task-specific\n      `initial_time` when interpreting waits.\n    \"\"\"\n    lat: Dict[int, Dict[str, float]] = {}\n    # Build first-appearance times\n    t_assigned: Dict[int, float] = {}\n    t_completed: Dict[int, float] = {}\n    for s in runlog.snapshots:\n        t = s.time\n        for tid in s.assigned:\n            t_assigned.setdefault(tid, t)\n        for tid in s.completed:\n            t_completed.setdefault(tid, t)\n    tids = set(t_assigned.keys()) | set(t_completed.keys())\n    for tid in tids:\n        ta = t_assigned.get(tid)\n        tc = t_completed.get(tid)\n        lat[tid] = {\n            \"time_assigned\": ta if ta is not None else float(\"nan\"),\n            \"time_completed\": tc if tc is not None else float(\"nan\"),\n            \"wait_to_assign\": (ta - initial_time) if ta is not None else float(\"nan\"),\n            \"wait_to_complete\": (tc - initial_time) if tc is not None else float(\"nan\"),\n        }\n    return lat\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.compute_time_series_metrics","title":"<code>compute_time_series_metrics(runlog: RunLog) -&gt; List[Dict[str, float]]</code>","text":"<p>Produce a list of per-snapshot aggregate metrics (time series).</p> <p>Each entry contains: - time - total_actual_distance: sum of all UAV executed distances at that snapshot - max_actual_distance: maximum per-UAV executed distance - unfinished_tasks: number of unassigned tasks</p> Source code in <code>src\\multi_uav_planner\\post_processing.py</code> <pre><code>def compute_time_series_metrics(runlog: RunLog) -&gt; List[Dict[str, float]]:\n    \"\"\"\n    Produce a list of per-snapshot aggregate metrics (time series).\n\n    Each entry contains:\n    - time\n    - total_actual_distance: sum of all UAV executed distances at that snapshot\n    - max_actual_distance: maximum per-UAV executed distance\n    - unfinished_tasks: number of unassigned tasks\n    \"\"\"\n    series = []\n    for s in runlog.snapshots:\n        distances = list(s.uav_range.values())\n        total = sum(distances)\n        max_dist = max(distances) if distances else 0.0\n        series.append({\n            \"time\": s.time,\n            \"total_actual_distance\": total,\n            \"max_actual_distance\": max_dist,\n            \"unfinished_tasks\": len(s.unassigned),\n        })\n    return series\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.compute_uav_distances","title":"<code>compute_uav_distances(runlog: RunLog) -&gt; Dict[int, float]</code>","text":"<p>Extract executed (actual) traveled distance per UAV from the latest snapshot.</p> <p>The function uses the last snapshot's <code>uav_range</code> which is expected to be a cumulative traveled distance measured during the simulation.</p> Source code in <code>src\\multi_uav_planner\\post_processing.py</code> <pre><code>def compute_uav_distances(runlog: RunLog) -&gt; Dict[int, float]:\n    \"\"\"Extract executed (actual) traveled distance per UAV from the latest snapshot.\n\n    The function uses the last snapshot's `uav_range` which is expected to be\n    a cumulative traveled distance measured during the simulation.\n    \"\"\"\n    dist = {}\n    if not runlog.snapshots:\n        return dist\n    last = runlog.snapshots[-1]\n    for uid, val in last.uav_range.items():\n        dist[uid] = float(val)\n    return dist\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.compute_uav_path_lengths","title":"<code>compute_uav_path_lengths(uav_paths: Dict[int, Path]) -&gt; Dict[int, float]</code>","text":"<p>Compute planned (pre-execution) path lengths for each UAV from Path objects.</p> <p>Returns a mapping uav_id -&gt; path.length().</p> Source code in <code>src\\multi_uav_planner\\post_processing.py</code> <pre><code>def compute_uav_path_lengths(uav_paths: Dict[int, Path]) -&gt; Dict[int, float]:\n    \"\"\"Compute planned (pre-execution) path lengths for each UAV from Path objects.\n\n    Returns a mapping uav_id -&gt; path.length().\n    \"\"\"\n    return {uav_id: path.length() for uav_id, path in uav_paths.items()}\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.compute_uav_state_durations","title":"<code>compute_uav_state_durations(runlog: RunLog) -&gt; Dict[int, Dict[int, float]]</code>","text":"<p>Compute per-UAV accumulated durations in each state (0 idle, 1 transit, 2 busy, 3 damaged).</p> <p>The algorithm: - Uses consecutive snapshots to obtain time intervals $\\(\\Delta t_i\\)$. - For each interval, it accumulates the duration into the state observed   at the interval start for each UAV.</p> <p>Returns: - dict: uav_id -&gt; {state_code -&gt; seconds}</p> Source code in <code>src\\multi_uav_planner\\post_processing.py</code> <pre><code>def compute_uav_state_durations(runlog: RunLog) -&gt; Dict[int, Dict[int, float]]:\n    \"\"\"Compute per-UAV accumulated durations in each state (0 idle, 1 transit, 2 busy, 3 damaged).\n\n    The algorithm:\n    - Uses consecutive snapshots to obtain time intervals $$\\Delta t_i$$.\n    - For each interval, it accumulates the duration into the state observed\n      at the interval start for each UAV.\n\n    Returns:\n    - dict: uav_id -&gt; {state_code -&gt; seconds}\n    \"\"\"\n    durations: Dict[int, Dict[int, float]] = {}\n    if len(runlog.snapshots) &lt; 2:\n        return durations\n    times = [s.time for s in runlog.snapshots]\n    dt = [times[i + 1] - times[i] for i in range(len(times) - 1)]\n    # initialize durations per UAV\n    for uid in runlog.snapshots[0].uav_states.keys():\n        durations[uid] = {0: 0.0, 1: 0.0, 2: 0.0, 3: 0.0}\n        for i in range(len(dt)):\n            st = runlog.snapshots[i].uav_states.get(uid, 0)\n            durations[uid][st] += dt[i]\n    return durations\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.cs_segments_shortest","title":"<code>cs_segments_shortest(start: Tuple[float, float, float], end: Tuple[float, float], radius: float) -&gt; Path</code>","text":"<p>Return the shortest feasible CS path among the two variants: $\\(LS\\)$ and $\\(RS\\)$.</p> <p>The function evaluates both $\\(\"LS\"\\)$ and $\\(\"RS\"\\)$ via cs_segments_single and returns the feasible one with minimal total length.</p> <p>Raises - ValueError if $\\(radius \\le 0\\)$. - ValueError if both $\\(LS\\)$ and $\\(RS\\)$ are infeasible (i.e., no tangent exists).</p> Source code in <code>src\\multi_uav_planner\\dubins.py</code> <pre><code>def cs_segments_shortest(\n    start: Tuple[float, float, float],\n    end: Tuple[float, float],\n    radius: float,\n) -&gt; Path:\n    \"\"\"\n    Return the shortest feasible CS path among the two variants: $$LS$$ and $$RS$$.\n\n    The function evaluates both $$\"LS\"$$ and $$\"RS\"$$ via cs_segments_single and\n    returns the feasible one with minimal total length.\n\n    Raises\n    - ValueError if $$radius \\le 0$$.\n    - ValueError if both $$LS$$ and $$RS$$ are infeasible (i.e., no tangent exists).\n    \"\"\"\n    if radius &lt;= 0.0:\n        raise ValueError(\"radius must be positive\")\n    if (start[0], start[1]) == end:\n        # degenerate: same position (no path required)\n        return Path([])\n    candidates = [cs_segments_single(start, end, radius, pt) for pt in (\"LS\", \"RS\")]\n    feasible = [p for p in candidates if p is not None]\n    if not feasible:\n        raise ValueError(\"No feasible CS-type Dubins path\")\n    return min(feasible, key=lambda p: p.length())\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.cs_segments_single","title":"<code>cs_segments_single(start: Tuple[float, float, float], end: Tuple[float, float], radius: float, path_type: PathType) -&gt; Optional[Path]</code>","text":"<p>Build a CS-type path composed of a single circular arc (C) followed by a straight line (S). The returned Path has the form [CurveSegment, LineSegment].</p> <p>The construction places a circle of radius $\\(R\\)$ tangent to the start configuration, then finds the tangency point to a straight line that reaches the target point.</p> <p>Parameters - $\\(start\\)$: $\\((x_0, y_0,   heta_0)\\)$ start configuration (position and heading, radians). - $\\(end\\)$: $\\((x_f, y_f)\\)$ goal position (heading at goal not used for CS). - $\\(radius\\)$: positive turning radius $\\(R &gt; 0\\)$. - $\\(path\\_type\\)$: either $\\(\"LS\"\\)$ (left-turn arc then straight) or $\\(\"RS\"\\)$   (right-turn arc then straight).</p> <p>Returns - A Path [arc, line] if a tangent straight-line exists. - $\\(None\\)$ if no tangent exists (i.e., the point is inside the circle of   tangency).</p> <p>Geometric summary and key formulas used: - The center of the start circle is obtained by offsetting the start   position laterally by $\\(\\pm       frac{\\pi}{2}\\)$ depending on left/right:   $$        heta_{center} =         heta_0 \\pm \frac{\\pi}{2}.$$   $\\(x_s = x_0 + R\\cos(      heta_{center}),\\quad y_s = y_0 + R\\sin( heta_{center}).\\)$ - Let $\\(d\\)$ be the distance from the circle center $\\((x_s,y_s)\\)$ to the   goal point $\\((x_f,y_f)\\)$. If $\\(d &lt; R\\)$ there is no external tangent,   so the CS path is infeasible. - The angle from the circle center to the goal is   $$        heta_{sf} = \\operatorname{atan2}(y_f-y_s,\\, x_f-x_s).$$ - For the right triangle between the center, tangency point, and goal:   $\\(\\sin(   heta_{mf}) = \frac{R}{d},\\quad   heta_{mf} = \u0007rcsin\\!\\left(\frac{R}{d} ight).\\)$ - The tangency angle on the circle (angle of the center-&gt;tangent point)   depends on path type; the code computes $$        heta_M$$ accordingly. - Arc sweep $\\(\\Delta        heta\\)$ (stored as $\\(d\\_theta\\)$) is normalized to the   appropriate signed interval in the implementation.</p> <p>Raises - ValueError if $\\(radius \\le 0\\)$.</p> Source code in <code>src\\multi_uav_planner\\dubins.py</code> <pre><code>def cs_segments_single(\n    start: Tuple[float, float, float],\n    end: Tuple[float, float],\n    radius: float,\n    path_type: PathType,\n) -&gt; Optional[Path]:\n    \"\"\"\n    Build a CS-type path composed of a single circular arc (C) followed by a\n    straight line (S). The returned Path has the form [CurveSegment, LineSegment].\n\n    The construction places a circle of radius $$R$$ tangent to the start\n    configuration, then finds the tangency point to a straight line that\n    reaches the target point.\n\n    Parameters\n    - $$start$$: $$(x_0, y_0, \\theta_0)$$ start configuration (position and heading, radians).\n    - $$end$$: $$(x_f, y_f)$$ goal position (heading at goal not used for CS).\n    - $$radius$$: positive turning radius $$R &gt; 0$$.\n    - $$path\\_type$$: either $$\"LS\"$$ (left-turn arc then straight) or $$\"RS\"$$\n      (right-turn arc then straight).\n\n    Returns\n    - A Path [arc, line] if a tangent straight-line exists.\n    - $$None$$ if no tangent exists (i.e., the point is inside the circle of\n      tangency).\n\n    Geometric summary and key formulas used:\n    - The center of the start circle is obtained by offsetting the start\n      position laterally by $$\\pm \\tfrac{\\pi}{2}$$ depending on left/right:\n      $$\\theta_{center} = \\theta_0 \\pm \\frac{\\pi}{2}.$$\n      $$x_s = x_0 + R\\cos(\\theta_{center}),\\quad y_s = y_0 + R\\sin(\\theta_{center}).$$\n    - Let $$d$$ be the distance from the circle center $$(x_s,y_s)$$ to the\n      goal point $$(x_f,y_f)$$. If $$d &lt; R$$ there is no external tangent,\n      so the CS path is infeasible.\n    - The angle from the circle center to the goal is\n      $$\\theta_{sf} = \\operatorname{atan2}(y_f-y_s,\\, x_f-x_s).$$\n    - For the right triangle between the center, tangency point, and goal:\n      $$\\sin(\\theta_{mf}) = \\frac{R}{d},\\quad \\theta_{mf} = \\arcsin\\!\\left(\\frac{R}{d}\\right).$$\n    - The tangency angle on the circle (angle of the center-&gt;tangent point)\n      depends on path type; the code computes $$\\theta_M$$ accordingly.\n    - Arc sweep $$\\Delta\\theta$$ (stored as $$d\\_theta$$) is normalized to the\n      appropriate signed interval in the implementation.\n\n    Raises\n    - ValueError if $$radius \\le 0$$.\n    \"\"\"\n    if radius &lt;= 0.0:\n        raise ValueError(\"radius must be positive\")\n\n    x0, y0, theta0 = start\n    xf, yf = end\n\n    # Center angle is start heading rotated left or right by 90 degrees:\n    # $$\\theta_{center} = \\theta_0 + (\\pi/2 \\text{ if 'LS' else } -\\pi/2)$$\n    theta_center = theta0 + (math.pi / 2.0 if path_type == \"LS\" else -math.pi / 2.0)\n\n    # Center coordinates of the start-turning circle:\n    # $$x_s = x_0 + R\\cos(\\theta_{center}), \\quad y_s = y_0 + R\\sin(\\theta_{center})$$\n    xs = x0 + radius * math.cos(theta_center)\n    ys = y0 + radius * math.sin(theta_center)\n\n    # --- 2. Angle $$\\theta_{SF}$$ and Euclidean distance $$d$$ from circle center to target ----\n    dx_sf = xf - xs\n    dy_sf = yf - ys\n    d = math.hypot(dx_sf, dy_sf)\n\n    # For a CS path the straight segment must be tangent to the circle:\n    # A tangent from the circle center to point F exists only if $$d \\ge R$$.\n    if d &lt; radius:\n        return None\n\n    # Angle from the circle center to F:\n    # $$\\theta_{sf} = \\operatorname{atan2}(dy_{sf}, dx_{sf})$$\n    theta_sf = math.atan2(dy_sf, dx_sf)  # \u03b8_SF in the paper\n\n    # --- 3. Angle $$\\theta_{mf}$$ between SF and the line from M to F -------\n    # From the right triangle: $$\\sin(\\theta_{mf}) = R / d$$\n    sin_theta_mf = min(1.0, max(-1.0, radius / d))\n    theta_mf = math.asin(sin_theta_mf)\n\n    # --- 4. Angle $$\\theta_M$$ of the tangent point M on the start circle ----\n    # For left-turn (LS): rotate $$\\theta_{sf}$$ CCW by $$\\theta_{mf} - \\pi/2$$.\n    # For right-turn (RS): rotate $$\\theta_{sf}$$ CW by $$-\\theta_{mf} + \\pi/2$$.\n    # The code also computes the start-angle on the circle (theta_s) based on start heading.\n    if path_type == \"LS\":\n        theta_M = theta_sf + theta_mf - math.pi / 2.0\n        theta_s=theta0-math.pi/2\n        # Normalize sweep to $$[0, 2\\pi)$$ for left arc (positive CCW sweep)\n        d_theta = (theta_M - theta_s)%(2*math.pi)\n    else:  # \"RS\"\n        theta_M = theta_sf - theta_mf + math.pi / 2.0\n        theta_s=theta0+math.pi/2\n        # Normalize sweep for right (negative / CW) arcs by shifting to negative range\n        d_theta = (theta_M - theta_s)%(2*math.pi)-2*math.pi\n\n    # Tangent point M on the circle:\n    # $$x_M = x_s + R\\cos(\\theta_M), \\quad y_M = y_s + R\\sin(\\theta_M)$$\n    xM = xs + radius * math.cos(theta_M)\n    yM = ys + radius * math.sin(theta_M)\n\n    arc = CurveSegment(center=(xs, ys), radius=radius, theta_s=theta_s%(2*math.pi), d_theta=d_theta)\n    line = LineSegment(start=(xM, yM), end=(xf, yf))\n\n    return Path([arc, line])\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.csc_segments_shortest","title":"<code>csc_segments_shortest(start: Tuple[float, float, float], end: Tuple[float, float, float], radius: float) -&gt; Path</code>","text":"<p>Return the shortest CSC path among the four canonical types: $$  ext{'LSL'},\\;   ext{'LSR'},\\;   ext{'RSL'},\\;   ext{'RSR'}$$.</p> <p>The function tries each CSC configuration using csc_segments_single and returns the feasible path with minimal total length.</p> <p>Raises - ValueError if $\\(radius \\le 0\\)$. - ValueError if all four CSC variants are infeasible.</p> Source code in <code>src\\multi_uav_planner\\dubins.py</code> <pre><code>def csc_segments_shortest(\n    start: Tuple[float, float, float],\n    end: Tuple[float, float, float],\n    radius: float,\n) -&gt; Path:\n    \"\"\"\n    Return the shortest CSC path among the four canonical types:\n    $$\\text{'LSL'},\\; \\text{'LSR'},\\; \\text{'RSL'},\\; \\text{'RSR'}$$.\n\n    The function tries each CSC configuration using csc_segments_single and\n    returns the feasible path with minimal total length.\n\n    Raises\n    - ValueError if $$radius \\le 0$$.\n    - ValueError if all four CSC variants are infeasible.\n    \"\"\"\n    if radius &lt;= 0.0:\n        raise ValueError(\"radius must be positive\")\n\n    candidates = [\n        csc_segments_single(start, end, radius, pt) for pt in (\"LSL\", \"LSR\", \"RSL\", \"RSR\")\n    ]\n    feasible = [p for p in candidates if p is not None]\n    if not feasible:\n        raise ValueError(\"No feasible CSC-type Dubins path\")\n    return min(feasible, key=lambda p: p.length())\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.csc_segments_single","title":"<code>csc_segments_single(start: Tuple[float, float, float], end: Tuple[float, float, float], R: float, path_type: CSCPathType) -&gt; Optional[Path]</code>","text":"<p>Build a CSC-type path consisting of two circular arcs separated by a straight line: [arc1, straight, arc2]. Returns $\\(None\\)$ if the requested tangent geometry is infeasible.</p> <p>Parameters - $\\(start\\)$: $\\((x_0, y_0,   heta_0)\\)$ start configuration (radians). - $\\(end\\)$: $\\((x_f, y_f,     heta_f)\\)$ end configuration (radians). - $\\(R\\)$: positive turning radius $\\(R &gt; 0\\)$. - $\\(path\\_type\\)$: one of $\\(\"LSL\"\\)$, $\\(\"LSR\"\\)$, $\\(\"RSL\"\\)$, $\\(\"RSR\"\\)$ describing the   turning directions of the first and second arcs.</p> <p>Returns - Path [arc1, line, arc2] when a valid tangent solution exists. - $\\(None\\)$ when no valid tangent exists (e.g., inner tangent missing).</p> <p>Notes on geometry and existence conditions: - Compute start circle center $\\(C_s\\)$ and end circle center $\\(C_f\\)$ by offsetting   the start and end positions laterally by $\\(\\pm    frac{\\pi}{2}\\)$ according to   the left/right choices for the first and second arc:   $\\(C_s = (x_0 + R\\cos(     heta_0 \\pm      frac{\\pi}{2}),\\; y_0 + R\\sin(   heta_0 \\pm      frac{\\pi}{2})),\\)$   $\\(C_f = (x_f + R\\cos(     heta_f \\pm      frac{\\pi}{2}),\\; y_f + R\\sin(   heta_f \\pm      frac{\\pi}{2})).\\)$ - Let $\\(d\\)$ be the distance between centers. For outer tangents (LSL, RSR)   an external tangent always exists for distinct centers. For inner tangents   (LSR, RSL) a tangent exists only if $\\(d \\ge 2R\\)$ because the circles must be   sufficiently separated. - The code computes tangent direction angles and arc sweeps $\\(\\Delta        heta\\)$   for the first and second arcs. These are normalized to represent the   appropriate signed rotations (positive for CCW, negative for CW).</p> Source code in <code>src\\multi_uav_planner\\dubins.py</code> <pre><code>def csc_segments_single(\n    start: Tuple[float, float, float],\n    end: Tuple[float, float, float],\n    R: float,\n    path_type: CSCPathType,\n) -&gt; Optional[Path]:\n    \"\"\"\n    Build a CSC-type path consisting of two circular arcs separated by a\n    straight line: [arc1, straight, arc2]. Returns $$None$$ if the requested\n    tangent geometry is infeasible.\n\n    Parameters\n    - $$start$$: $$(x_0, y_0, \\theta_0)$$ start configuration (radians).\n    - $$end$$: $$(x_f, y_f, \\theta_f)$$ end configuration (radians).\n    - $$R$$: positive turning radius $$R &gt; 0$$.\n    - $$path\\_type$$: one of $$\"LSL\"$$, $$\"LSR\"$$, $$\"RSL\"$$, $$\"RSR\"$$ describing the\n      turning directions of the first and second arcs.\n\n    Returns\n    - Path [arc1, line, arc2] when a valid tangent solution exists.\n    - $$None$$ when no valid tangent exists (e.g., inner tangent missing).\n\n    Notes on geometry and existence conditions:\n    - Compute start circle center $$C_s$$ and end circle center $$C_f$$ by offsetting\n      the start and end positions laterally by $$\\pm \\tfrac{\\pi}{2}$$ according to\n      the left/right choices for the first and second arc:\n      $$C_s = (x_0 + R\\cos(\\theta_0 \\pm \\tfrac{\\pi}{2}),\\; y_0 + R\\sin(\\theta_0 \\pm \\tfrac{\\pi}{2})),$$\n      $$C_f = (x_f + R\\cos(\\theta_f \\pm \\tfrac{\\pi}{2}),\\; y_f + R\\sin(\\theta_f \\pm \\tfrac{\\pi}{2})).$$\n    - Let $$d$$ be the distance between centers. For outer tangents (LSL, RSR)\n      an external tangent always exists for distinct centers. For inner tangents\n      (LSR, RSL) a tangent exists only if $$d \\ge 2R$$ because the circles must be\n      sufficiently separated.\n    - The code computes tangent direction angles and arc sweeps $$\\Delta\\theta$$\n      for the first and second arcs. These are normalized to represent the\n      appropriate signed rotations (positive for CCW, negative for CW).\n    \"\"\"\n    # Unpack start and end configurations\n    x0, y0, th0 = start\n    xf, yf, thf = end\n\n    # Compute center of start circle:\n    # $$\\theta_{rad\\_s} = \\theta_0 \\pm \\frac{\\pi}{2}$$ depending on first turn being L or R\n    th_rad_s = th0 + (math.pi / 2.0 if path_type[0] == \"L\" else -math.pi / 2.0)\n    xs = x0 + R * math.cos(th_rad_s)\n    ys = y0 + R * math.sin(th_rad_s)\n\n    # Compute center of end circle similarly:\n    th_rad_f = thf + (math.pi / 2.0 if path_type[-1] == \"L\" else -math.pi / 2.0)\n    xf_c = xf + R * math.cos(th_rad_f)\n    yf_c = yf + R * math.sin(th_rad_f)\n\n\n    # Vector between circle centers and its distance:\n    # $$d = \\|C_f - C_s\\|$$ and base angle $$\\theta_{sf} = \\operatorname{atan2}(dy, dx)$$\n    dx, dy = xf_c - xs, yf_c - ys\n    d = math.hypot(dx, dy)\n    th_sf = math.atan2(dy, dx)\n\n    # inner = True for LSR or RSL (these use inner tangents)\n    inner = path_type in {\"LSR\", \"RSL\"}\n\n    # Angle correction used for inner tangents:\n    theta_mn = 0.0\n    if inner: \n        # For inner tangents we need $$d \\ge 2R$$ because the tangent joins the\n        # near sides of the two circles. Compute:\n        # $$\\sin(\\theta_{mn}) = \\frac{2R}{d}$$ (derived from geometry)\n        ratio = 2 * R / d\n        if ratio &gt; 1.0:     # no inner tangent exists if centers are too close\n            return None\n        theta_mn = math.asin(min(1.0, max(-1.0, ratio)))\n\n    # Compute tangent angles and arc transitions depending on path_type.\n    # The code establishes angles of the tangent points on each circle (th_M, th_N)\n    # and the corresponding arc start angles and sweeps (delta1, delta2).\n    if path_type == \"LSL\":\n        th_M = th_sf - math.pi / 2.0\n        th_N = th_sf - math.pi / 2.0\n        theta_s1 = th0 - math.pi / 2.0\n        # Normalize to $$[0,2\\pi)$$ for left-turned arcs (CCW positive)\n        delta1 = (th_M - theta_s1)%(2*math.pi)\n        theta_f2 = thf - math.pi/2\n        delta2 = (theta_f2 - th_N)%(2*math.pi) \n    elif path_type == \"RSR\":\n        th_M = th_sf + math.pi / 2.0\n        th_N = th_sf + math.pi / 2.0\n        theta_s1 = th0+math.pi/2\n        # For right turns we represent CW rotation as a negative sweep:\n        delta1 = (th_M - theta_s1)%(2*math.pi)-(2*math.pi)\n        theta_f2=thf+math.pi/2\n        delta2 = (theta_f2 - th_N)%(2*math.pi)-(2*math.pi)\n    elif path_type == \"LSR\":\n        # inner tangent: connect left-turn start circle to right-turn end circle\n        th_M = th_sf + theta_mn - math.pi / 2.0\n        th_N = th_sf + theta_mn + math.pi / 2.0\n        theta_s1 = th0 - math.pi/2\n        delta1= (th_M-theta_s1)%(2*math.pi)\n        theta_f2= thf + math.pi/2\n        # second arc is right-turn (CW), normalize to negative sweep\n        delta2=(theta_f2 - th_N)%(2*math.pi)-(2*math.pi)\n    else: # \"RSL\"\n        # inner tangent: connect right-turn start circle to left-turn end circle\n        th_M = th_sf - theta_mn + math.pi / 2.0\n        th_N = th_sf - theta_mn - math.pi / 2.0\n        theta_s1 = th0 + math.pi/2\n        # First arc is a right turn (CW); represent CW as negative sweep\n        delta1= (th_M-theta_s1)%(2*math.pi)-(2*math.pi)\n        theta_f2= thf - math.pi/2\n        # Second arc is left turn (CCW); normalize to positive sweep\n        delta2=(theta_f2 - th_N) %(2*math.pi)\n\n    # Compute the tangent points on each circle using their angles:\n    # $$M = C_s + R[\\cos(\\theta_M), \\sin(\\theta_M)]$$\n    # $$N = C_f + R[\\cos(\\theta_N), \\sin(\\theta_N)]$$\n    xM = xs + R * math.cos(th_M)\n    yM = ys + R * math.sin(th_M)\n    xN = xf_c + R * math.cos(th_N)\n    yN = yf_c + R * math.sin(th_N)\n\n    # Construct the path segments:\n    # - arc1: CurveSegment for the initial turning arc around C_s\n    # - line: LineSegment connecting tangent points M-&gt;N\n    # - arc2: CurveSegment for the final turning arc around C_f\n    arc1 = CurveSegment(center=(xs, ys), radius=R, theta_s=theta_s1%(2*math.pi), d_theta=delta1)\n    line = LineSegment(start=(xM, yM), end=(xN, yN))\n    arc2 = CurveSegment(center=(xf_c, yf_c), radius=R, theta_s=th_N%(2*math.pi), d_theta=delta2)\n    return Path([arc1, line, arc2])\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.generate_scenario","title":"<code>generate_scenario(config: ScenarioConfig) -&gt; Scenario</code>","text":"<p>Generate a random Scenario from the provided config.</p> <p>The procedure is deterministic when $\\(config.seed\\)$ is fixed via $\\(random.seed(config.seed)\\)$, making it suitable for repeatable tests.</p> <p>Returns: - Scenario: container with fields populated (tasks, uavs, base, events, alg_type).</p> Source code in <code>src\\multi_uav_planner\\scenario_generation.py</code> <pre><code>def generate_scenario(config: ScenarioConfig) -&gt; Scenario:\n    \"\"\"\n    Generate a random Scenario from the provided config.\n\n    The procedure is deterministic when $$config.seed$$ is fixed via\n    $$random.seed(config.seed)$$, making it suitable for repeatable tests.\n\n    Returns:\n    - Scenario: container with fields populated (tasks, uavs, base, events, alg_type).\n    \"\"\"\n    random.seed(config.seed)\n\n    base = config.base\n\n    tasks: List[Task] = [\n        _generate_random_task(task_id=i + 1, config=config)\n        for i in range(config.n_tasks)\n    ]\n    uavs = _generate_uavs(config, base)\n\n    events = _generate_events(config)\n\n    alg_type = config.alg_type\n\n    return Scenario(\n        config=config,\n        tasks=tasks,\n        uavs=uavs,\n        base=base,\n        events=events,\n        alg_type=alg_type,\n    )\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.initialize_world","title":"<code>initialize_world(world: World, scenario: Scenario) -&gt; None</code>","text":"<p>Initialize a World instance using the data produced by generate_scenario().</p> <p>Side effects: - Overwrites world.tasks and world.uavs with dicts keyed by id. - Sets world.base and world.time (time reset to $\\(0.0\\)$). - Installs the scenario event list on world.events and resets the events cursor. - Clears and repopulates the task and UAV partition sets (unassigned/assigned/completed and idle/transit/busy/damaged). - Propagates tolerances from the scenario config into world.tols.</p> <p>Consistency checks and validation: - Validates $\\(UAV.assigned\\_path\\)$ types (must be a Path or None). - Raises ValueError for unknown task or UAV states. - At the end the function asserts that the declared partitions exactly cover   the respective id sets for tasks and UAVs.</p> Source code in <code>src\\multi_uav_planner\\scenario_generation.py</code> <pre><code>def initialize_world(world: World, scenario: Scenario) -&gt; None:\n    \"\"\"\n    Initialize a World instance using the data produced by generate_scenario().\n\n    Side effects:\n    - Overwrites world.tasks and world.uavs with dicts keyed by id.\n    - Sets world.base and world.time (time reset to $$0.0$$).\n    - Installs the scenario event list on world.events and resets the events cursor.\n    - Clears and repopulates the task and UAV partition sets (unassigned/assigned/completed and idle/transit/busy/damaged).\n    - Propagates tolerances from the scenario config into world.tols.\n\n    Consistency checks and validation:\n    - Validates $$UAV.assigned\\_path$$ types (must be a Path or None).\n    - Raises ValueError for unknown task or UAV states.\n    - At the end the function asserts that the declared partitions exactly cover\n      the respective id sets for tasks and UAVs.\n    \"\"\"\n    # Replace dictionaries and simple fields\n    world.tasks = {t.id: t for t in scenario.tasks}\n    world.uavs  = {u.id: u for u in scenario.uavs}\n    world.base = scenario.base\n    world.time = 0.0\n\n    # Install scheduled events\n    world.events = scenario.events\n    world.events_cursor = 0\n\n    # Clear partitions before repopulating\n    world.unassigned.clear(); world.assigned.clear(); world.completed.clear()\n    world.idle_uavs.clear(); world.transit_uavs.clear(); world.busy_uavs.clear(); world.damaged_uavs.clear()\n\n    world.tols = scenario.config.tolerances\n\n    # Populate task partitions from task.state\n    for tid, t in world.tasks.items():\n        if t.state == 0: world.unassigned.add(tid)\n        elif t.state == 1: world.assigned.add(tid)\n        elif t.state == 2: world.completed.add(tid)\n        else: raise ValueError(f\"Task {tid} has unknown state {t.state}\")\n\n    # Populate UAV partitions from u.state and validate assigned_path type\n    for uid, u in world.uavs.items():\n        if u.assigned_path is not None and not isinstance(u.assigned_path, Path):\n            raise TypeError(\"UAV.assigned_path must be a Path or None\")\n        if u.state == 0: world.idle_uavs.add(uid)\n        elif u.state == 1: world.transit_uavs.add(uid)\n        elif u.state == 2: world.busy_uavs.add(uid)\n        elif u.state == 3: world.damaged_uavs.add(uid)\n        else: raise ValueError(f\"UAV {uid} has unknown status {u.state}\")\n\n    # Final consistency assertions: partitions must exactly cover declared ids\n    assert world.unassigned | world.assigned | world.completed == set(world.tasks.keys())\n    assert world.idle_uavs | world.transit_uavs | world.busy_uavs | world.damaged_uavs == set(world.uavs.keys())\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.instrument_assignment","title":"<code>instrument_assignment(assignment_fn: Callable, registry: TimeRegistry, label: str = 'assignment')</code>","text":"<p>Return a wrapper around an assignment function that records wall and CPU time.</p> <p>Parameters: - assignment_fn: callable performing assignment (e.g., <code>assignment</code>). - registry: TimeRegistry instance used to accumulate timings. - label: label under which to record the timing (default: \"assignment\").</p> <p>The returned function has the same signature as <code>assignment_fn</code> and, in addition to forwarding its return value, will call <code>registry.add(label, wall, cpu)</code>.</p> Source code in <code>src\\multi_uav_planner\\post_processing.py</code> <pre><code>def instrument_assignment(assignment_fn: Callable, registry: TimeRegistry, label: str = \"assignment\"):\n    \"\"\"\n    Return a wrapper around an assignment function that records wall and CPU time.\n\n    Parameters:\n    - assignment_fn: callable performing assignment (e.g., `assignment`).\n    - registry: TimeRegistry instance used to accumulate timings.\n    - label: label under which to record the timing (default: \"assignment\").\n\n    The returned function has the same signature as `assignment_fn` and, in\n    addition to forwarding its return value, will call `registry.add(label, wall, cpu)`.\n    \"\"\"\n    def wrapped(*args, **kwargs):\n        start = time.perf_counter(); start_c = time.process_time()\n        res = assignment_fn(*args, **kwargs)\n        registry.add(label, time.perf_counter() - start, time.process_time() - start_c)\n        return res\n    return wrapped\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.instrument_cluster","title":"<code>instrument_cluster(cluster_fn: Callable, registry: TimeRegistry, label: str = 'cluster_tasks')</code>","text":"<p>Wrap the clustering routine to measure its runtime.</p> <p>Parameters: - cluster_fn: callable performing clustering (e.g., <code>cluster_tasks</code>). - registry: TimeRegistry instance used to accumulate timings. - label: label for the timing records (default: \"cluster_tasks\").</p> <p>Returned callable forwards all arguments to <code>cluster_fn</code> and records wall and CPU time.</p> Source code in <code>src\\multi_uav_planner\\post_processing.py</code> <pre><code>def instrument_cluster(cluster_fn: Callable, registry: TimeRegistry, label: str = \"cluster_tasks\"):\n    \"\"\"\n    Wrap the clustering routine to measure its runtime.\n\n    Parameters:\n    - cluster_fn: callable performing clustering (e.g., `cluster_tasks`).\n    - registry: TimeRegistry instance used to accumulate timings.\n    - label: label for the timing records (default: \"cluster_tasks\").\n\n    Returned callable forwards all arguments to `cluster_fn` and records wall and CPU time.\n    \"\"\"\n    def wrapped(*args, **kwargs):\n        start = time.perf_counter(); start_c = time.process_time()\n        res = cluster_fn(*args, **kwargs)\n        registry.add(label, time.perf_counter() - start, time.process_time() - start_c)\n        return res\n    return wrapped\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.instrument_planner","title":"<code>instrument_planner(plan_to_task_fn: Callable, registry: TimeRegistry, label: str = 'plan_path_to_task')</code>","text":"<p>Wrap a path planning function to collect runtime per invocation.</p> <p>Parameters: - plan_to_task_fn: callable (e.g., <code>plan_path_to_task</code>) to be wrapped. - registry: TimeRegistry instance to record timings. - label: label to record timings under (default: \"plan_path_to_task\").</p> Usage <p>planner = instrument_planner(plan_path_to_task, registry) path = planner(world, uav_id, target_pose)</p> Source code in <code>src\\multi_uav_planner\\post_processing.py</code> <pre><code>def instrument_planner(plan_to_task_fn: Callable, registry: TimeRegistry, label: str = \"plan_path_to_task\"):\n    \"\"\"\n    Wrap a path planning function to collect runtime per invocation.\n\n    Parameters:\n    - plan_to_task_fn: callable (e.g., `plan_path_to_task`) to be wrapped.\n    - registry: TimeRegistry instance to record timings.\n    - label: label to record timings under (default: \"plan_path_to_task\").\n\n    Usage:\n        planner = instrument_planner(plan_path_to_task, registry)\n        path = planner(world, uav_id, target_pose)\n    \"\"\"\n    def wrapped(*args, **kwargs):\n        start = time.perf_counter(); start_c = time.process_time()\n        res = plan_to_task_fn(*args, **kwargs)\n        registry.add(label, time.perf_counter() - start, time.process_time() - start_c)\n        return res\n    return wrapped\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.move_in_transit","title":"<code>move_in_transit(world: World, dt: float) -&gt; bool</code>","text":"<p>Advance UAVs currently in the <code>world.transit_uavs</code> set by time step $\\(dt\\)$.</p> <p>Behavior: - For each UAV id <code>j</code> in <code>world.transit_uavs</code>:     - If the UAV has no assigned path (<code>uav.assigned_path</code> is None) or       the path has no remaining segments, the UAV is considered to have       reached the assigned position. The UAV is moved from the transit       partition to the busy partition and a mission path for the assigned       task is generated via <code>plan_mission_path</code>.     - Otherwise, call <code>pose_update(uav, dt, world.tols.ang)</code> to advance       the UAV along its current active segment.       - If <code>pose_update</code> returns True it means the active segment was         completed during this update; in that case the completed segment         is removed from the path (<code>path.segments.pop(0)</code>). - The function returns True if any UAV had its pose advanced during this call.</p> <p>Notes: - The function iterates over a snapshot <code>list(world.transit_uavs)</code> to   permit safely removing/adding ids to the partition sets inside the loop.</p> Source code in <code>src\\multi_uav_planner\\stepping_fcts.py</code> <pre><code>def move_in_transit(world: World, dt: float) -&gt; bool:\n    \"\"\"\n    Advance UAVs currently in the ``world.transit_uavs`` set by time step $$dt$$.\n\n    Behavior:\n    - For each UAV id ``j`` in ``world.transit_uavs``:\n        - If the UAV has no assigned path (``uav.assigned_path`` is None) or\n          the path has no remaining segments, the UAV is considered to have\n          reached the assigned position. The UAV is moved from the transit\n          partition to the busy partition and a mission path for the assigned\n          task is generated via ``plan_mission_path``.\n        - Otherwise, call ``pose_update(uav, dt, world.tols.ang)`` to advance\n          the UAV along its current active segment.\n          - If ``pose_update`` returns True it means the active segment was\n            completed during this update; in that case the completed segment\n            is removed from the path (``path.segments.pop(0)``).\n    - The function returns True if any UAV had its pose advanced during this call.\n\n    Notes:\n    - The function iterates over a snapshot ``list(world.transit_uavs)`` to\n      permit safely removing/adding ids to the partition sets inside the loop.\n    \"\"\"\n    moved = False\n    for j in list(world.transit_uavs):\n        uav = world.uavs[j]\n        path = uav.assigned_path\n        if path is None or not path.segments:\n            # Path empty: arrive =&gt; switch to busy and create mission path\n            world.transit_uavs.remove(j)\n            world.busy_uavs.add(j)\n            uav.state = 2\n            tid = uav.current_task\n            if tid is not None:\n                # Generate intratask coverage path (may be empty for point tasks)\n                uav.assigned_path = plan_mission_path(uav, world.tasks[tid])\n            continue\n\n        # Advance along the current segment\n        flag = pose_update(uav, dt, world.tols.ang)\n        moved = True\n        if flag:\n            # The active segment completed: remove it from the path\n            path.segments.pop(0)\n    return moved\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.perform_task","title":"<code>perform_task(world: World, dt: float) -&gt; bool</code>","text":"<p>Advance UAVs that are executing a task (<code>world.busy_uavs</code>) by $\\(dt\\)$.</p> <p>Behavior: - For each UAV id <code>j</code> in <code>world.busy_uavs</code>:     - If the UAV has an assigned mission path with remaining segments,       call <code>pose_update</code> to advance along the active segment. If the       active segment completes, pop it from the path.     - If the UAV has no mission path or no remaining segments after the       advance, the task is considered finished:         - Move the UAV from <code>busy</code> to <code>idle</code> partition and clear its           assigned path and <code>current_task</code>.         - Mark the task as completed in the world partition sets:           move task id from <code>assigned</code> to <code>completed</code> and set           <code>world.tasks[tid].state = 2</code>.         - If the task belonged to the UAV's cluster, remove it; recompute           cluster CoG if tasks remain, else clear the CoG. - Returns True if any UAV had its pose advanced.</p> <p>Notes: - All updates mutate the World and UAVs in-place.</p> Source code in <code>src\\multi_uav_planner\\stepping_fcts.py</code> <pre><code>def perform_task(world: World, dt: float) -&gt; bool:\n    \"\"\"\n    Advance UAVs that are executing a task (``world.busy_uavs``) by $$dt$$.\n\n    Behavior:\n    - For each UAV id ``j`` in ``world.busy_uavs``:\n        - If the UAV has an assigned mission path with remaining segments,\n          call ``pose_update`` to advance along the active segment. If the\n          active segment completes, pop it from the path.\n        - If the UAV has no mission path or no remaining segments after the\n          advance, the task is considered finished:\n            - Move the UAV from ``busy`` to ``idle`` partition and clear its\n              assigned path and ``current_task``.\n            - Mark the task as completed in the world partition sets:\n              move task id from ``assigned`` to ``completed`` and set\n              ``world.tasks[tid].state = 2``.\n            - If the task belonged to the UAV's cluster, remove it; recompute\n              cluster CoG if tasks remain, else clear the CoG.\n    - Returns True if any UAV had its pose advanced.\n\n    Notes:\n    - All updates mutate the World and UAVs in-place.\n    \"\"\"\n    moved = False\n    for j in list(world.busy_uavs):\n        uav = world.uavs[j]\n        path = uav.assigned_path\n\n        if path and path.segments:\n            flag = pose_update(uav, dt, world.tols.ang)\n            moved = True\n            if flag:\n                path.segments.pop(0)\n\n        if path is None or not path.segments:\n            # Task finished: update partitions and bookkeeping\n            tid = uav.current_task\n            world.busy_uavs.remove(j)\n            world.idle_uavs.add(j)\n            uav.state = 0\n            uav.assigned_path = None\n            if tid is not None:\n                # Mark task completed\n                world.tasks[tid].state = 2\n                world.assigned.discard(tid)\n                world.completed.add(tid)\n                uav.current_task = None\n                # Maintain cluster membership and recompute CoG if needed\n                if tid in uav.cluster:\n                    uav.cluster.remove(tid)\n                    if uav.cluster:\n                        xs = [world.tasks[t].position[0] for t in uav.cluster]\n                        ys = [world.tasks[t].position[1] for t in uav.cluster]\n                        uav.cluster_CoG = (sum(xs) / len(xs), sum(ys) / len(ys))\n                    else:\n                        uav.cluster_CoG = None\n\n    return moved\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.plan_mission_path","title":"<code>plan_mission_path(uav: UAV, task: Task) -&gt; Optional[Path]</code>","text":"<p>Build the coverage path required to perform the given Task. The returned Path describes how the UAV should traverse the geometry inside the task.</p> <p>Summary per task type: - PointTask:     - No coverage path inside the task: returns an empty Path <code>[]</code>. - LineTask:     - Returns a single straight LineSegment of length <code>task.length</code> starting       at the task position and oriented along the mission heading. - CircleTask:     - Returns a single full-circle CurveSegment centered so the circle       passes through the task position and starts with the specified heading.       The sweep is $\\(\\pm 2\\pi\\)$ depending on the <code>side</code> ('left' =&gt; +2\u03c0, 'right' =&gt; -2\u03c0).       The start angle is computed so that the tangent/heading at the start       matches the requested mission heading. - AreaTask:     - Constructs a boustrophedon (back-and-forth) pattern consisting of       straight passes (LineSegment) and semicircular end-turns (CurveSegment).       The semicircle radius used for turns is $\\(r_{turn} = \frac{    ext{pass\\_spacing}}{2}\\)$.</p> <p>Parameters: - $\\(uav\\)$: UAV instance providing current pose and parameters (used for default heading). - $\\(task\\)$: Task instance describing the required coverage.</p> <ul> <li>Path containing the sequence of segments to cover the task area, or   an empty Path for tasks that need no intratask traversal (PointTask).</li> </ul> Source code in <code>src\\multi_uav_planner\\path_planner.py</code> <pre><code>def plan_mission_path(uav: UAV, task: Task) -&gt; Optional[Path]:\n    \"\"\"\n    Build the coverage path required to perform the given Task. The returned\n    Path describes how the UAV should traverse the geometry inside the task.\n\n    Summary per task type:\n    - PointTask:\n        - No coverage path inside the task: returns an empty Path `[]`.\n    - LineTask:\n        - Returns a single straight LineSegment of length `task.length` starting\n          at the task position and oriented along the mission heading.\n    - CircleTask:\n        - Returns a single full-circle CurveSegment centered so the circle\n          passes through the task position and starts with the specified heading.\n          The sweep is $$\\pm 2\\pi$$ depending on the `side` ('left' =&gt; +2\u03c0, 'right' =&gt; -2\u03c0).\n          The start angle is computed so that the tangent/heading at the start\n          matches the requested mission heading.\n    - AreaTask:\n        - Constructs a boustrophedon (back-and-forth) pattern consisting of\n          straight passes (LineSegment) and semicircular end-turns (CurveSegment).\n          The semicircle radius used for turns is $$r_{turn} = \\frac{\\text{pass\\_spacing}}{2}$$.\n\n    Parameters:\n    - $$uav$$: UAV instance providing current pose and parameters (used for default heading).\n    - $$task$$: Task instance describing the required coverage.\n\n    Returns:\n    - Path containing the sequence of segments to cover the task area, or\n      an empty Path for tasks that need no intratask traversal (PointTask).\n    \"\"\"\n    xe, ye = task.position\n    # Choose mission heading: if the task enforces a heading use it; otherwise use UAV heading\n    base_heading = task.heading if task.heading_enforcement else uav.position[2]\n\n    if isinstance(task, PointTask):\n        # No traversal required inside a point task\n        return Path([])\n\n    elif isinstance(task, LineTask):\n        # Create a straight pass starting at the task position in direction base_heading\n        assert isinstance(task, LineTask)\n        end_x = xe + task.length * math.cos(base_heading)\n        end_y = ye + task.length * math.sin(base_heading)\n        return Path([LineSegment(start=(xe, ye), end=(end_x, end_y))])\n\n    elif isinstance(task, CircleTask):\n        # Full-circle traversal: choose sweep sign by side and compute circle center\n        assert isinstance(task, CircleTask)\n        d_theta = +2 * math.pi if task.side == 'left' else -2 * math.pi\n        # Start angle: offset such that the circle tangent aligns with base_heading.\n        # We move start angle by +/- pi/2 depending on the sweep sign:\n        theta_s = base_heading - sgn(d_theta) * (math.pi / 2)\n        # Compute circle center so the circle of radius R passes through the task point (xe, ye).\n        # We place center on the ray from the task via angle (theta_s + pi).\n        xc = xe + task.radius * math.cos(theta_s + math.pi)\n        yc = ye + task.radius * math.sin(theta_s + math.pi)\n        return Path([CurveSegment(center=(xc, yc), radius=task.radius, theta_s=theta_s, d_theta=d_theta)])\n\n    elif isinstance(task, AreaTask):\n        # Boustrophedon pattern: alternating straight passes and semicircular turns.\n        assert isinstance(task, AreaTask)\n        segs: List[Segment] = []\n        # Semicircle radius used at pass ends:\n        r_turn = task.pass_spacing / 2.0\n        # Starting position for the first pass\n        x_curr, y_curr = xe, ye\n\n        for i in range(task.num_passes):\n            # Alternate pass direction: even -&gt; base_heading, odd -&gt; base_heading + pi\n            heading_i = base_heading if (i % 2 == 0) else (base_heading + math.pi)\n            # Straight pass end point\n            x_end = x_curr + task.pass_length * math.cos(heading_i)\n            y_end = y_curr + task.pass_length * math.sin(heading_i)\n            segs.append(LineSegment(start=(x_curr, y_curr), end=(x_end, y_end)))\n\n            if i == task.num_passes - 1:\n                # No turn after the last pass\n                break\n\n            # Determine turn side to shift laterally by pass_spacing.\n            # We alternate the turn side so that passes are offset correctly.\n            turn_side = task.side if (i % 2 == 0) else ('right' if task.side == 'left' else 'left')\n            # Normal direction relative to current heading: +pi/2 for left, -pi/2 for right\n            normal = math.pi / 2.0 if turn_side == 'left' else -math.pi / 2.0\n            # Semicircle center offset from the end point along the normal direction\n            cx = x_end + r_turn * math.cos(heading_i + normal)\n            cy = y_end + r_turn * math.sin(heading_i + normal)\n            # Angle from center to starting point of the turn (end of straight pass)\n            theta_s = math.atan2(y_end - cy, x_end - cx)\n            # Semicircle sweep: +pi for left-turn (CCW), -pi for right-turn (CW)\n            d_theta = +math.pi if turn_side == 'left' else -math.pi\n            segs.append(CurveSegment(center=(cx, cy), radius=r_turn, theta_s=theta_s, d_theta=d_theta))\n            # Update current point to the end of the semicircle (start of next pass)\n            theta_e = theta_s + d_theta\n            x_curr = cx + r_turn * math.cos(theta_e)\n            y_curr = cy + r_turn * math.sin(theta_e)\n\n        return Path(segs)\n\n    else:\n        raise ValueError(f\"Unknown task type: {type(task).__name__}\")\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.plan_path_to_task","title":"<code>plan_path_to_task(world: World, uid: int, t_pose: Tuple[float, float, float]) -&gt; Path</code>","text":"<p>Plan a feasible path (sequence of segments) that brings UAV <code>uid</code> from its current pose to the task entry pose <code>t_pose</code>.</p> <p>Policy summary (priority and fallbacks):   1) If the UAV is already co-located with the task position within positional tolerance:      - If the requested entry heading is unconstrained (None) or matches the UAV heading        within angular tolerance, return an empty Path (no motion required).      - Otherwise, perform an in-place heading adjustment using the shortest CSC path        (which reduces to a pure rotational maneuver when spatial displacement is zero).   2) Try a single straight-line (LineSegment) if headings permit:      - For unconstrained task entry heading (the is None), only the UAV's heading        must be aligned with the line to the target.      - For constrained task entry heading, both the UAV heading and the desired        task heading must be aligned with the line direction within angular tolerance.   3) Otherwise use Dubins-style constructions (turns of radius $\\(R\\)$):      - If the task entry heading is unconstrained: compute the shortest CS path        using <code>cs_segments_shortest</code>.      - If the task entry heading is constrained:          a) Try CS candidates (LS/RS) that end with a straight-line segment oriented             so that the straight segment's heading matches the desired task heading             within angular tolerance; pick the shortest feasible such CS if any.          b) If none of the CS candidates satisfy the heading constraint or are infeasible,             fall back to the shortest CSC path via <code>csc_segments_shortest</code>.</p> <p>Parameters: - $\\(world\\)$: World object giving UAV states and tolerances. - $\\(uid\\)$: UAV identifier (must be a key in $\\(world.uavs\\)$). - $\\(t\\_pose\\)$: target pose tuple $\\((x_e, y_e,       heta_e)\\)$ where $$      heta_e$$ may be $\\(None\\)$              if the entry heading is unconstrained.</p> <p>Returns: - Path instance representing the planned sequence of segments.</p> <p>Notes and assumptions: - UAV minimum turn radius $\\(R\\)$ is read from the UAV object and must be positive. - Angular comparisons use the world's tolerances $\\(world.tols.ang\\)$ and positional   comparisons use $\\(world.tols.pos\\)$.</p> Source code in <code>src\\multi_uav_planner\\path_planner.py</code> <pre><code>def plan_path_to_task(world: World, uid:int, t_pose: Tuple[float,float,float]) -&gt; Path:\n    \"\"\"\n    Plan a feasible path (sequence of segments) that brings UAV `uid` from its\n    current pose to the task entry pose `t_pose`.\n\n    Policy summary (priority and fallbacks):\n      1) If the UAV is already co-located with the task position within positional tolerance:\n         - If the requested entry heading is unconstrained (None) or matches the UAV heading\n           within angular tolerance, return an empty Path (no motion required).\n         - Otherwise, perform an in-place heading adjustment using the shortest CSC path\n           (which reduces to a pure rotational maneuver when spatial displacement is zero).\n      2) Try a single straight-line (LineSegment) if headings permit:\n         - For unconstrained task entry heading (the is None), only the UAV's heading\n           must be aligned with the line to the target.\n         - For constrained task entry heading, both the UAV heading and the desired\n           task heading must be aligned with the line direction within angular tolerance.\n      3) Otherwise use Dubins-style constructions (turns of radius $$R$$):\n         - If the task entry heading is unconstrained: compute the shortest CS path\n           using `cs_segments_shortest`.\n         - If the task entry heading is constrained:\n             a) Try CS candidates (LS/RS) that end with a straight-line segment oriented\n                so that the straight segment's heading matches the desired task heading\n                within angular tolerance; pick the shortest feasible such CS if any.\n             b) If none of the CS candidates satisfy the heading constraint or are infeasible,\n                fall back to the shortest CSC path via `csc_segments_shortest`.\n\n    Parameters:\n    - $$world$$: World object giving UAV states and tolerances.\n    - $$uid$$: UAV identifier (must be a key in $$world.uavs$$).\n    - $$t\\_pose$$: target pose tuple $$(x_e, y_e, \\theta_e)$$ where $$\\theta_e$$ may be $$None$$\n                 if the entry heading is unconstrained.\n\n    Returns:\n    - Path instance representing the planned sequence of segments.\n\n    Notes and assumptions:\n    - UAV minimum turn radius $$R$$ is read from the UAV object and must be positive.\n    - Angular comparisons use the world's tolerances $$world.tols.ang$$ and positional\n      comparisons use $$world.tols.pos$$.\n    \"\"\"\n\n    x0, y0, th0 = world.uavs[uid].position\n    R = world.uavs[uid].turn_radius\n    xe, ye, the = t_pose\n    tols = world.tols\n\n    if R &lt;= 0.0:\n        raise ValueError(\"UAV minimum turn radius must be positive!\")\n\n    # 1) Co-located check: if position difference within tolerance\n    if _distance((x0, y0), (xe, ye)) &lt;= tols.pos:\n        # If heading is unconstrained or matches within tolerance, no motion required\n        if the is None or abs(_angle_diff(th0, the)) &lt;= tols.ang:\n            return Path([])\n        # Else, adjust heading in place using CSC (degenerate straight length)\n        return csc_segments_shortest((x0, y0, th0), (xe, ye, the), R)\n\n    # 2) Straight-line feasibility check\n    dir_to_target = math.atan2(ye - y0, xe - x0)\n    # For unconstrained entry heading: only UAV heading must align with the line\n    if the is None and abs(_angle_diff(th0, dir_to_target)) &lt;= tols.ang:\n        return Path([LineSegment(start=(x0, y0), end=(xe, ye))])\n    # For constrained entry heading: both UAV and desired heading must align with the line\n    if the is not None:\n        if abs(_angle_diff(th0, dir_to_target)) &lt;= tols.ang and abs(_angle_diff(the, dir_to_target)) &lt;= tols.ang:\n            return Path([LineSegment(start=(x0, y0), end=(xe, ye))])\n\n    # 3) Dubins-style constructions\n    if the is None:\n        # Only a CS path is needed (final heading unconstrained)\n        return cs_segments_shortest((x0, y0, th0), (xe, ye), R)\n    else:\n        # Try CS candidates (LS, RS) and filter those whose final straight-line\n        # heading matches the requested task heading within tolerance.\n        cs_candidates = [\n            cs_segments_single((x0, y0, th0), (xe, ye), R, pt) for pt in (\"LS\", \"RS\")\n        ]\n        cs_feasible = [p for p in cs_candidates if p is not None]\n        # Filter by final-line heading\n        filtered: List[Path] = []\n        for p in cs_feasible:\n            last = p.segments[-1]\n            if isinstance(last, LineSegment):\n                line_h = _line_heading(last)\n                if abs(_angle_diff(line_h, the)) &lt;= tols.ang:\n                    filtered.append(p)\n        if filtered:\n            return min(filtered, key=lambda p: p.length())\n\n        # No CS candidate meets the heading requirement; use the shortest CSC path\n        return csc_segments_shortest((x0, y0, th0), (xe, ye, the), R)\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.return_to_base","title":"<code>return_to_base(world, use_dubins)</code>","text":"<p>Send all idle UAVs back to base.</p> <p>Parameters: - $\\(world\\)$: World instance whose <code>idle_uavs</code> set will be processed. - $\\(use\\_dubins\\)$: if True use <code>plan_path_to_task</code> (Dubins-aware planner)   to compute a feasible path to the base pose; otherwise assign a single   straight-line <code>LineSegment</code> path to the base.</p> <p>Side effects: - Moves each idle UAV into the <code>transit</code> partition and sets its state to 1. - Updates <code>uav.assigned_path</code> for each UAV accordingly.</p> Source code in <code>src\\multi_uav_planner\\stepping_fcts.py</code> <pre><code>def return_to_base(world, use_dubins):\n    \"\"\"\n    Send all idle UAVs back to base.\n\n    Parameters:\n    - $$world$$: World instance whose ``idle_uavs`` set will be processed.\n    - $$use\\_dubins$$: if True use ``plan_path_to_task`` (Dubins-aware planner)\n      to compute a feasible path to the base pose; otherwise assign a single\n      straight-line ``LineSegment`` path to the base.\n\n    Side effects:\n    - Moves each idle UAV into the ``transit`` partition and sets its state to 1.\n    - Updates ``uav.assigned_path`` for each UAV accordingly.\n    \"\"\"\n    for j in list(world.idle_uavs):\n        world.uavs[j].state = 1\n        world.idle_uavs.remove(j)\n        world.transit_uavs.add(j)\n        if use_dubins:\n            # Compute a Dubins-style path back to base (more realistic)\n            world.uavs[j].assigned_path = plan_path_to_task(world, j, world.base)\n        else:\n            # Simple straight-line return: single LineSegment from current position to base\n            world.uavs[j].assigned_path = Path(\n                segments=[LineSegment((world.uavs[j].position[0], world.uavs[j].position[1]),\n                                      (world.base[0], world.base[1]))]\n            )\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.save_csv_rows","title":"<code>save_csv_rows(path: str, header: List[str], rows: List[Tuple[Any, ...]])</code>","text":"<p>Write rows (sequence of tuples) to a CSV file with optional header.</p> <p>Parameters: - path: output file path. - header: list of column names. If empty, no header row is written. - rows: iterable of tuples representing CSV rows.</p> <p>Notes: - Uses newline='' when opening the file for cross-platform CSV writing. - Values are written verbatim using the default csv.writer formatting.</p> Source code in <code>src\\multi_uav_planner\\post_processing.py</code> <pre><code>def save_csv_rows(path: str, header: List[str], rows: List[Tuple[Any,...]]):\n    \"\"\"Write rows (sequence of tuples) to a CSV file with optional header.\n\n    Parameters:\n    - path: output file path.\n    - header: list of column names. If empty, no header row is written.\n    - rows: iterable of tuples representing CSV rows.\n\n    Notes:\n    - Uses newline='' when opening the file for cross-platform CSV writing.\n    - Values are written verbatim using the default csv.writer formatting.\n    \"\"\"\n    with open(path, \"w\", newline=\"\") as f:\n        w = csv.writer(f)\n        if header:\n            w.writerow(header)\n        for r in rows:\n            w.writerow(r)\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.simulate_mission","title":"<code>simulate_mission(world: World, scenario: Optional[Scenario], dt: float = 0.1, max_time: float = 100.0, N_stall: int = 30, on_step: Optional[Callable[[World, str], None]] = None) -&gt; None</code>","text":"<p>Run a discrete-time simulation of the multi-UAV mission until completion or timeout.</p> <p>Parameters - $\\(world\\)$: a World object that will be advanced in-place. If the world is not              initialized (<code>world.is_initialized()</code> returns False), the function              will initialize it using <code>scenario</code> or by synthesizing one. - $\\(scenario\\)$: optional Scenario used to initialize the world if necessary.                 If None, a default ScenarioConfig is used and a scenario is                 generated internally. - $\\(dt\\)$: simulation time step in seconds (default: $\\(0.1\\)$). - $\\(max\\_time\\)$: safety upper bound on simulation time in seconds; simulation                 aborts if exceeded (default: $\\(1    imes 10^2\\)$). - $\\(N\\_stall\\)$: number of consecutive ticks with no UAV movement after which                the simulation prints a stall warning and aborts (reserved). - $\\(on\\_step\\)$: optional callback <code>on_step(world, tag)</code> invoked at several                logical points; useful for logging or visualization. Tags used:                - <code>\"init\"</code>: after initialization,                - <code>\"triggering_events\"</code>: after event processing,                - <code>\"assignment\"</code>: after assignment step,                - <code>\"after_move\"</code>: after moving transit UAVs,                - <code>\"end_tick (post_coverage)\"</code>: end of tick,                - <code>\"planned_return\"</code>: after scheduling return-to-base.</p> <p>High-level loop (per tick):   1. Process pending events whose trigger time &lt;= world.time.   2. If using PRBDD, run clustering once at initialization.   3. If there are idle UAVs and unassigned tasks, run the selected assignment      algorithm to produce committed UAV-&gt;task assignments.   4. Advance UAVs that are in-transit (move_in_transit).   5. Advance UAVs that are executing tasks (perform_task).   6. Detect stalls (no UAV moved) and abort if they persist for $\\(N\\_stall\\)$ ticks.   7. Increment world.time by $\\(dt\\)$ and continue until all tasks are completed      and all UAVs have returned to base (see stopping condition below).</p> <p>Stopping condition: - The main loop continues while:     - not <code>world.done()</code> (i.e., there remain unassigned or assigned tasks)     OR     - not <code>world.at_base()</code> (i.e., UAVs are yet to be at base).   When the world has no pending tasks but UAVs are not at base, the   simulator triggers <code>return_to_base</code> for idle UAVs and continues until they   reach base or time limit / stall aborts the run.</p> <p>Side effects: - The function mutates <code>world</code> (tasks/UAVs/partitions/time) and may call   assignment and path-planning routines that set UAV assigned paths.</p> Source code in <code>src\\multi_uav_planner\\simulation_loop.py</code> <pre><code>def simulate_mission(\n    world: World,\n    scenario: Optional[Scenario],\n    dt: float = 0.1,\n    max_time: float = 1e2,\n    N_stall: int = 30,  # reserved for future stall detection\n    on_step: Optional[Callable[[World, str], None]] = None,  # recorder hook\n) -&gt; None:\n    \"\"\"\n    Run a discrete-time simulation of the multi-UAV mission until completion or timeout.\n\n    Parameters\n    - $$world$$: a World object that will be advanced in-place. If the world is not\n                 initialized (``world.is_initialized()`` returns False), the function\n                 will initialize it using `scenario` or by synthesizing one.\n    - $$scenario$$: optional Scenario used to initialize the world if necessary.\n                    If None, a default ScenarioConfig is used and a scenario is\n                    generated internally.\n    - $$dt$$: simulation time step in seconds (default: $$0.1$$).\n    - $$max\\_time$$: safety upper bound on simulation time in seconds; simulation\n                    aborts if exceeded (default: $$1 \\times 10^2$$).\n    - $$N\\_stall$$: number of consecutive ticks with no UAV movement after which\n                   the simulation prints a stall warning and aborts (reserved).\n    - $$on\\_step$$: optional callback ``on_step(world, tag)`` invoked at several\n                   logical points; useful for logging or visualization. Tags used:\n                   - ``\"init\"``: after initialization,\n                   - ``\"triggering_events\"``: after event processing,\n                   - ``\"assignment\"``: after assignment step,\n                   - ``\"after_move\"``: after moving transit UAVs,\n                   - ``\"end_tick (post_coverage)\"``: end of tick,\n                   - ``\"planned_return\"``: after scheduling return-to-base.\n\n    High-level loop (per tick):\n      1. Process pending events whose trigger time &lt;= world.time.\n      2. If using PRBDD, run clustering once at initialization.\n      3. If there are idle UAVs and unassigned tasks, run the selected assignment\n         algorithm to produce committed UAV-&gt;task assignments.\n      4. Advance UAVs that are in-transit (move_in_transit).\n      5. Advance UAVs that are executing tasks (perform_task).\n      6. Detect stalls (no UAV moved) and abort if they persist for $$N\\_stall$$ ticks.\n      7. Increment world.time by $$dt$$ and continue until all tasks are completed\n         and all UAVs have returned to base (see stopping condition below).\n\n    Stopping condition:\n    - The main loop continues while:\n        - not ``world.done()`` (i.e., there remain unassigned or assigned tasks)\n        OR\n        - not ``world.at_base()`` (i.e., UAVs are yet to be at base).\n      When the world has no pending tasks but UAVs are not at base, the\n      simulator triggers `return_to_base` for idle UAVs and continues until they\n      reach base or time limit / stall aborts the run.\n\n    Side effects:\n    - The function mutates ``world`` (tasks/UAVs/partitions/time) and may call\n      assignment and path-planning routines that set UAV assigned paths.\n    \"\"\"\n    # Initialize world if needed\n    if not world.is_initialized():\n        if scenario is None:\n            cfg = ScenarioConfig()\n            scenario = generate_scenario(cfg)\n        initialize_world(world, scenario)\n        if on_step:\n            on_step(world, \"init\")\n\n    # For PRBDD workflow, perform initial clustering to populate UAV clusters\n    if scenario.alg_type is AlgorithmType.PRBDD:\n        cluster_tasks(world)\n\n    stall = 0\n\n    # Main simulation loop: iterate until mission finished and UAVs are at base\n    while not world.done() or not world.at_base():\n        # -------------------------------\n        # 1) Process events (new tasks, UAV damage)\n        # -------------------------------\n        check_for_events(world, scenario.alg_type is AlgorithmType.PRBDD)\n        if on_step:\n            on_step(world, \"triggering_events\")\n\n        # -------------------------------\n        # 2) Assignment step (idle UAVs -&gt; unassigned tasks)\n        # -------------------------------\n        if world.idle_uavs and world.unassigned:\n            assignment(world, scenario.alg_type)\n        if on_step:\n            on_step(world, \"assignment\")\n\n        # -------------------------------\n        # 3) Advance UAVs in-transit along their assigned paths\n        # -------------------------------\n        transit_moved = move_in_transit(world, dt)\n        if on_step:\n            on_step(world, \"after_move\")\n\n        # -------------------------------\n        # 4) Advance UAVs that are executing tasks (coverage)\n        # -------------------------------\n        mission_moved = perform_task(world, dt)\n\n        # -------------------------------\n        # 5) Stall detection: abort if no UAV moved for N_stall ticks\n        # -------------------------------\n        if not transit_moved and not mission_moved:\n            stall += 1\n            if stall &gt;= N_stall:\n                print(\"Warning: Simulation is stalled, Simulation aborted\")\n                break\n        else:\n            stall = 0\n\n        # -------------------------------\n        # 6) Advance global simulation time and notify observers\n        # -------------------------------\n        world.time += dt\n        if on_step:\n            on_step(world, \"end_tick (post_coverage)\")\n\n        # Safety: abort if simulation time exceeds the configured limit\n        if world.time &gt; max_time:\n            print(\"Simulation aborted: time limit exceeded\")\n            break\n\n        # If all tasks are complete but UAVs are not yet at base and there are no\n        # active transit/busy UAVs, schedule a return-to-base for idle UAVs.\n        if world.done() and not world.at_base() and not world.transit_uavs and not world.busy_uavs:\n            return_to_base(world, scenario.alg_type in {AlgorithmType.PRBDD, AlgorithmType.RBDD})\n            if on_step:\n                on_step(world, \"planned_return\")\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.summarize_uav_path_lengths","title":"<code>summarize_uav_path_lengths(uav_paths: Dict[int, Path]) -&gt; Dict[str, float]</code>","text":"<p>Return summary statistics over planned path lengths.</p> <p>The returned dict contains <code>total</code>, <code>avg</code>, <code>max</code>, and <code>min</code> values. If no paths are provided, zeros are returned.</p> Source code in <code>src\\multi_uav_planner\\post_processing.py</code> <pre><code>def summarize_uav_path_lengths(uav_paths: Dict[int, Path]) -&gt; Dict[str, float]:\n    \"\"\"Return summary statistics over planned path lengths.\n\n    The returned dict contains `total`, `avg`, `max`, and `min` values. If no\n    paths are provided, zeros are returned.\n    \"\"\"\n    lengths = list(compute_uav_path_lengths(uav_paths).values())\n    if not lengths:\n        return {\"total\": 0.0, \"avg\": 0.0, \"max\": 0.0, \"min\": 0.0}\n    total = sum(lengths)\n    return {\n        \"total\": total,\n        \"avg\": total / len(lengths),\n        \"max\": max(lengths),\n        \"min\": min(lengths),\n    }\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.summarize_world","title":"<code>summarize_world(world) -&gt; Dict[str, Any]</code>","text":"<p>Return a small dictionary summarizing the final world state.</p> Source code in <code>src\\multi_uav_planner\\post_processing.py</code> <pre><code>def summarize_world(world) -&gt; Dict[str, Any]:\n    \"\"\"Return a small dictionary summarizing the final world state.\"\"\"\n    return {\n        \"time_final\": world.time,\n        \"n_tasks_total\": len(world.tasks),\n        \"n_unassigned\": len(world.unassigned),\n        \"n_assigned\": len(world.assigned),\n        \"n_completed\": len(world.completed),\n        \"n_uavs\": len(world.uavs),\n        \"n_idle\": len(world.idle_uavs),\n        \"n_transit\": len(world.transit_uavs),\n        \"n_busy\": len(world.busy_uavs),\n        \"n_damaged\": len(world.damaged_uavs),\n        \"at_base\": world.at_base(),\n        \"done\": world.done(),\n    }\n</code></pre>"},{"location":"dev/architecture/","title":"Architecture","text":"<p>TBD</p>"},{"location":"dev/contributing/","title":"Contributing","text":"<p>TBD</p>"},{"location":"dev/profiling/","title":"Profiling","text":"<p>TBD</p>"},{"location":"tutorials/clustering_assignment/","title":"Clustering_Assignment","text":"<p>TBD</p>"},{"location":"tutorials/full_mission/","title":"Full_Mission","text":"<p>TBD</p>"},{"location":"tutorials/path_model_and_dubins/","title":"Path_Model_And_Dubins","text":"<p>TBD</p>"},{"location":"user-guide/plotting/","title":"Plotting","text":"<p>TBD</p>"},{"location":"user-guide/scenarios/","title":"User Guide \u00b7 Scenarios","text":"<p>This page explains how to configure, generate, and inspect mission scenarios. Scenarios define the mission area, UAV fleet, task mix, and optional runtime events (new tasks, UAV damage). They are reproducible via a single seed and can be used directly with the simulation loop.</p>"},{"location":"user-guide/scenarios/#what-is-a-scenario","title":"What is a Scenario?","text":"<p>A Scenario bundles: - Mission geometry: area width/height and base pose - Fleet configuration: number of UAVs and their kinematics (speed, turn radius, range) - Task set: a random mix of Point/Line/Circle/Area tasks - Events: optional NEW_TASK and UAV_DAMAGE arrivals over time - Algorithm choice: assignment/planning strategy selector</p> <p>You primarily interact with: - <code>ScenarioConfig</code> \u2014 declarative configuration - <code>generate_scenario(cfg)</code> \u2014 deterministic generator - <code>Scenario</code> \u2014 the resulting object (tasks, uavs, base, events, alg_type) - <code>initialize_world(world, scenario)</code> \u2014 load into <code>World</code></p>"},{"location":"user-guide/scenarios/#scenarioconfig-fields-and-semantics","title":"ScenarioConfig \u00b7 Fields and Semantics","text":"<p>Core geometry - <code>base: (x, y, heading)</code> \u2014 swarm start pose - <code>area_width</code>, <code>area_height</code> \u2014 rectangular mission bounds (meters)</p> <p>Fleet - <code>n_uavs</code> \u2014 number of UAVs - <code>uav_speed</code> \u2014 meters/second - <code>turn_radius</code> \u2014 minimum turn radius - <code>max_range</code> \u2014 per-UAV distance budget; tracked as <code>current_range</code> during simulation</p> <p>Task mix - <code>n_tasks</code> \u2014 number of initial tasks - Probabilities for task types:   - <code>p_point</code>, <code>p_line</code>, <code>p_circle</code>, <code>p_area</code>   - Must satisfy $\\(p_\\text{point} + p_\\text{line} + p_\\text{circle} + p_\\text{area} = 1\\)$</p> <p>Events (optional dynamics) - <code>scenario_type: NONE | NEW_TASKS | UAV_DAMAGE | BOTH</code> - New tasks:   - <code>n_new_task</code>, <code>ts_new_task</code>, <code>tf_new_task</code> \u2014 number and time window - Damage:   - <code>n_damage</code>, <code>ts_damage</code> \u2014 number and earliest time   - Constraint: $\\(n_\\text{damage} &lt; n_\\text{uavs}\\)$</p> <p>Algorithm - <code>alg_type</code> \u2014 selects assignment/planning approach (e.g., <code>PRBDD</code>, <code>HBA</code>, etc.)</p> <p>Reproducibility - <code>seed</code> \u2014 fixed seed for all random draws</p>"},{"location":"user-guide/scenarios/#creating-a-scenario","title":"Creating a Scenario","text":"<p>Minimal example: <pre><code>from multi_uav_planner.scenario_generation import ScenarioConfig, generate_scenario, AlgorithmType, ScenarioType\n\ncfg = ScenarioConfig(\n    base=(0.0, 0.0, 0.0),\n    area_width=300.0, area_height=250.0,\n    n_uavs=3, n_tasks=20,\n    p_point=0.6, p_line=0.2, p_circle=0.1, p_area=0.1,\n    scenario_type=ScenarioType.BOTH,\n    n_new_task=5, ts_new_task=10.0, tf_new_task=120.0,\n    n_damage=2, ts_damage=30.0,\n    alg_type=AlgorithmType.PRBDD,\n    seed=42\n)\n\nscenario = generate_scenario(cfg)\n</code></pre></p>"},{"location":"user-guide/scenarios/#load-into-a-world","title":"Load into a world:","text":"<pre><code>from multi_uav_planner.world_models import World\nfrom multi_uav_planner.scenario_generation import initialize_world\n\nworld = World(tasks={}, uavs={})\ninitialize_world(world, scenario)\n</code></pre>"},{"location":"user-guide/scenarios/#task-types-geometry-defaults","title":"Task Types \u00b7 Geometry Defaults","text":"<ul> <li>PointTask</li> <li>Position: uniform in area</li> <li>Heading: optional (30% constrained in default generator)</li> <li>Intrinsic length: $\\(0\\)$</li> <li>LineTask</li> <li>Length: random in a configured range</li> <li>Coverage segment aligned with heading</li> <li>Intrinsic length: $\\(L\\)$</li> <li>CircleTask</li> <li>Radius: random in a configured range</li> <li>Side: <code>left or right</code> \u21d2 sweep $\\(\\pm 2\\pi\\)$</li> <li>Intrinsic length: $\\(2\\pi R\\)$</li> <li>AreaTask</li> <li>Zigzag passes: <code>num_passes</code>, <code>pass_length</code>, <code>pass_spacing</code>, first turn <code>side</code></li> <li>Approx coverage (without min-turn adjustment): $\\(N \\cdot L + (N - 1) \\cdot \\pi \\cdot \\frac{S}{2}\\)$</li> </ul> <p>Note: Actual mission path length depends on UAV minimum turn radius and may exceed intrinsic approximations.</p>"},{"location":"user-guide/scenarios/#events-behavior","title":"Events \u00b7 Behavior","text":"<ul> <li>NEW_TASK</li> <li>Arrives uniformly in $\\([t_s, t_f]\\)$</li> <li>Payload is a list with at least one <code>Task</code></li> <li>Inserted into <code>world.unassigned</code>; if clustering is active, task may be placed into nearest cluster</li> <li>UAV_DAMAGE</li> <li>Occurs uniformly in $\\([t_s, \\text{max\\_time}]\\)$</li> <li>Marks UAV as damaged, cancels its current assignment, and returns its task(s) to <code>unassigned</code></li> </ul> <p>Ordering - Events are sorted deterministically by <code>(time, kind, id)</code> given the <code>seed</code>.</p>"},{"location":"user-guide/scenarios/#algorithm-choice","title":"Algorithm Choice","text":"<p>Set via <code>cfg.alg_type</code>. Examples: - <code>PRBDD</code>: cluster-first greedy per UAV (proximity to cluster centers) - <code>HBA</code>: Hungarian (global optimal on a given cost matrix) - <code>GBA</code> or <code>RBDD</code>: greedy variants (global/nearest)</p> <p>Assignment cost can be Euclidean or Dubins path length, depending on planner use.</p>"},{"location":"user-guide/scenarios/#reproducibility-tips","title":"Reproducibility Tips","text":"<ul> <li>Fix <code>seed</code> in <code>ScenarioConfig</code> to reproduce task positions, headings, and event times.</li> <li>Keep code versions consistent; changes to sampling ranges or logic alter outcomes.</li> <li>For experiments, store <code>{ScenarioConfig and seed}</code> alongside logs/metrics.</li> </ul>"},{"location":"user-guide/scenarios/#visualizing-scenarios-optional","title":"Visualizing Scenarios (Optional)","text":"<p>Use plotting helpers in <code>visuals/scenario_plotting.py</code> (kept separate from core):</p> <pre><code>import matplotlib.pyplot as plt\nfrom visuals.scenario_plotting import plot_scenario_overview\n\nfig, ax = plt.subplots(figsize=(8,6))\nplot_scenario_overview(ax, scenario, title=\"Scenario Overview\")\nplt.show()\n</code></pre> <p>To inspect event timing:</p> <pre><code>from visuals.events_plotting import plot_event_timeline\nplot_event_timeline(plt.gca(), scenario.events, title=\"Events Timeline\")\n</code></pre>"},{"location":"user-guide/scenarios/#common-pitfalls-checks","title":"Common Pitfalls &amp; Checks","text":"<ul> <li>Probabilities must sum to $\\(1\\)$; otherwise the last branch absorbs the remainder.</li> <li>Damage count must satisfy $\\(n_\\text{damage} &lt; n_\\text{uavs}\\)$.</li> <li>Always initialize a <code>World</code> with <code>initialize_world(world, scenario)</code> before simulation.</li> <li>If using cluster-based assignment, ensure clustering is run before assignment (PRBDD does this automatically at simulation init).</li> </ul>"},{"location":"user-guide/scenarios/#advanced-custom-generators","title":"Advanced: Custom Generators","text":"<p>You can supply your own task generator for specific distributions.</p> <pre><code>from multi_uav_planner.world_models import PointTask\n\ndef make_custom_tasks(cfg, n=20):\n    tasks = []\n    for i in range(n):\n        x = 0.5 * cfg.area_width + 0.5 * cfg.area_width * i / n\n        y = cfg.area_height * (i % 10) / 10.0\n        tasks.append(PointTask(id=i+1, position=(x, y), state=0))\n    return tasks\n</code></pre> <p>Then construct a <code>Scenario</code> using your lists and pass it to <code>initialize_world</code>.</p>"},{"location":"user-guide/simulation/","title":"Simulation","text":"<p>TBD</p>"}]}