{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Multi-UAV Planner","text":"<p>A modular Python toolkit for dynamic, real-time multi-UAV mission planning using Dubins paths. It provides scenario generation, clustering, assignment, path planning, simulation, visualization helpers, and post-processing.</p>"},{"location":"#highlights","title":"Highlights","text":"<ul> <li>Modular geometry: segments and paths with Dubins primitives (CS, CSC)</li> <li>Planning: shortest transit (straight/CS/CSC) and mission coverage per task</li> <li>Assignment: greedy, Hungarian, auction (optional), PRBDD/RBDD</li> <li>Scenario engine: tasks (Point/Line/Circle/Area), UAVs, events (NEW_TASK, UAV_DAMAGE)</li> <li>Simulation loop: event-driven, with hooks for logging/metrics</li> <li>Visuals: plotting helpers and demos (kept separate from logging)</li> <li>Post-processing: runtime profiling, run logs, metrics JSON/CSV</li> </ul> <p>Tip: Arc length uses  $$ L = R \\cdot |\\Delta \\theta| $$  and straight-line length uses  $$ L = \\sqrt{\\Delta x^2 + \\Delta y^2} $$.</p> <p>This project is a Python implementation of the algorithm described in:</p> <p>Dynamic real-time multi-UAV cooperative mission planning method under multiple constraints Chenglou Liu et al., 2025(arXiv:2506.02365)</p>"},{"location":"#quickstart","title":"Quickstart","text":"<p>Prerequisites: - Python 3.10+ - Recommended: virtual environment</p> <p>Install (editable):</p> <pre><code>pip install -e .\n# Optional for visuals/demos:\npip install matplotlib numpy scipy scikit-learn\n</code></pre> <p>Minimal simulation: </p> <pre><code># quickstart_sim.py\nfrom multi_uav_planner.world_models import World\nfrom multi_uav_planner.scenario_generation import ScenarioConfig, generate_scenario, AlgorithmType\nfrom multi_uav_planner.simulation import simulate_mission\n\ncfg = ScenarioConfig(n_uavs=3, n_tasks=12, alg_type=AlgorithmType.PRBDD, seed=42)\nscenario = generate_scenario(cfg)\nworld = World(tasks={}, uavs={})\nsimulate_mission(world, scenario, dt=0.2, max_time=1500.0)\nprint(\"Done:\", world.done(), \"At base:\", world.at_base(), \"Time:\", world.time)\n</code></pre> <p>Dubins path demo (CS shortest):</p> <pre><code># quickstart_dubins.py\nimport matplotlib.pyplot as plt\nfrom math import pi\nfrom multi_uav_planner.dubins import cs_segments_shortest\nfrom visuals.plotting import plot_path, finalize_axes\n\nstart = (50.0, 50.0, pi/6)\nend   = (220.0, 80.0)\nR = 40.0\np = cs_segments_shortest(start, end, R)\n\nfig, ax = plt.subplots(figsize=(7,6))\nplot_path(ax, p)\nfinalize_axes(ax, \"Dubins CS shortest\")\nplt.show()\n</code></pre>"},{"location":"#quick-links","title":"Quick links","text":"<ul> <li>Getting Started \u2013 installation &amp; running your first simulations</li> <li>Static Simulation Usage \u2013 how to run and interpret the static planner</li> <li>Architecture \u2013 how the code is organized and how it maps to the paper</li> </ul>"},{"location":"changelog/","title":"Changelog","text":"<p>TBD</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>TBD</p>"},{"location":"algorithms/assignment/","title":"Algorithms \u00b7 Assignment","text":"<p>This page documents the task assignment strategies used in the planner, the cost models behind them (Euclidean vs Dubins), how they map to the code, and when to use each method.</p>"},{"location":"algorithms/assignment/#problem-formulation","title":"Problem formulation","text":"<p>Given a set of idle UAVs $\\(\\mathcal{U}=\\{1,\\dots,n\\}\\)$ and a set of candidate unassigned tasks $\\(\\mathcal{T}=\\{1,\\dots,m\\}\\)$, we build a cost matrix $$ C \\in \\mathbb{R}^{n \\times m}, \\quad C_{i,j} \\ge 0 $$ where $\\(C_{i,j}\\)$ is the cost of assigning UAV $\\(i\\)$ to task $\\(j\\)$ (conceptually interpreted as the path length between UAV $\\(i\\)$ and task $\\(j\\)). The canonical objective is the linear assignment problem: $$ \\min_{x \\in {0,1}^{n \\times m}} \\ \\sum_{i=1}^n \\sum_{j=1}^m C_{i,j} \\, x_{i,j} $$ subject to: - Each UAV is assigned to at most one task: $\\(\\sum_{j} x_{i,j} \\le 1\\)$. - Each task is assigned to at most one UAV: $\\(\\sum_{i} x_{i,j} \\le 1\\)$. - When $\\(m \\ge n\\)$, one can enforce $\\(\\sum_{j} x_{i,j} = 1\\)$ (every UAV gets a task); when $\\(m &lt; n\\)$, some UAVs remain unassigned.</p> <p>In practice, we solve a single round of assignment at each simulation tick for idle UAVs and unassigned tasks.</p>"},{"location":"algorithms/assignment/#cost-models","title":"Cost models","text":"<p>Two distance models are available:</p> <ul> <li> <p>Euclidean distance (fast):   $$   C_{i,j} = |p_j - u_i| = \\sqrt{(x_j - x_i)^2 + (y_j - y_i)^2}.   $$   Use this for quick preselection or global algorithms where exact Dubins-aware planning isn\u2019t required in the cost.</p> </li> <li> <p>Dubins path length (feasible, kinematic-aware):   $$   C_{i,j} = L^\\star(i \\to j),   $$   where $\\(L^\\star\\)$ is the length of the shortest feasible transit path (straight/CS/CSC as needed). This respects the UAV\u2019s minimum turn radius and entry-heading constraints for the task.</p> </li> </ul> <p>In code, <code>compute_cost(..., use_dubins: bool)</code> selects the model.</p>"},{"location":"algorithms/assignment/#methods","title":"Methods","text":"<p>The project includes multiple assignment strategies:</p>"},{"location":"algorithms/assignment/#gba-greedy-best-available","title":"GBA \u2014 Greedy Best-Available","text":"<ul> <li>Global greedy selection of the single lowest cost pair (worker, task) among remaining pairs, iterated until exhaustion.</li> <li>Complexity: $\\(O(nm + \\min(n,m)\\cdot nm)\\)$ in practice; simple and fast.</li> <li>Pros: very fast, simple code.</li> <li>Cons: may be far from optimal; sensitive to cost geometry.</li> </ul>"},{"location":"algorithms/assignment/#hba-hungarian-kuhnmunkres","title":"HBA \u2014 Hungarian (Kuhn\u2013Munkres)","text":"<ul> <li>Finds an optimal assignment (for the given cost matrix), uses SciPy\u2019s <code>linear_sum_assignment</code>.</li> <li>Handles rectangular matrices: all workers get an assignment when $\\(m \\ge n\\)$; when $\\(m &lt; n\\)$, some workers remain unassigned.</li> <li>Complexity: $\\(O(k^3)\\)$ with $\\(k=\\max(n,m)\\)$; good for moderate sizes.</li> <li>Pros: globally optimal on the input cost matrix.</li> <li>Cons: heavier than greedy; quality depends on the cost model.</li> </ul>"},{"location":"algorithms/assignment/#aa-auction-bertsekas","title":"AA \u2014 Auction (Bertsekas)","text":"<ul> <li>Distributed-style algorithm that approximately optimizes the linear assignment via bidding/prices.</li> <li>Pads rectangular matrices to square with dummy tasks; workers assigned to dummy return unassigned.</li> <li>Pros: simple, scalable; tunable $\\(\\epsilon\\)$\u2011scaling controls accuracy/speed trade-off.</li> <li>Cons: parameter tuning; may be slower than Hungarian for small matrices.</li> </ul>"},{"location":"algorithms/assignment/#sa-simulated-annealing-heuristic","title":"SA \u2014 Simulated Annealing (heuristic)","text":"<ul> <li>Meta-heuristic that explores assignment space via swaps and (optionally) moves to unassigned tasks; accepts uphill moves probabilistically while temperature is high.</li> <li>Uses greedy initialization and proposals (swap/move-to-unassigned).</li> <li>Pros: can escape local minima; flexible.</li> <li>Cons: may be slow; parameters (temperature schedule) matter; solution quality varies.</li> </ul>"},{"location":"algorithms/assignment/#rbddg-reduced-assignment-with-dubins-aware-globally","title":"RBDDG \u2014 Reduced assignment with Dubins-aware globally","text":"<ul> <li>\u201cReduced by Dubins Distance Global\u201d: runs a classic assignment (e.g., greedy) using Dubins costs; transit path is planned with Dubins as well.</li> <li>Pros: kinematically consistent distances in cost; robust; faster than full PRBDD in some cases.</li> <li>Cons: more expensive than Euclidean; still global (no preprocessing).</li> </ul>"},{"location":"algorithms/assignment/#prbddg-preprocessed-reduced-by-dubins-distance-with-greedy","title":"PRBDDG \u2014 Preprocessed Reduced by Dubins Distance with Greedy","text":"<ul> <li>Cluster-first (KMeans) to reduce decision space; then assign per-UAV within its cluster with Dubins-aware costs, typically greedy.</li> <li>Pros: very fast after clustering; close to optimal in many spatial distributions; demonstrated in the paper to perform best on average distance/speed trade-offs.</li> <li>Cons: preprocessing adds logic; quality depends on cluster quality; suboptimal in rare cluster pathologies.</li> </ul>"},{"location":"algorithms/assignment/#where-these-live-in-code","title":"Where these live in code","text":"<ul> <li>Core API: <code>multi_uav_planner.assignment</code></li> <li><code>assignment(world, algo: AlgorithmType) -&gt; Dict[int,int]</code>:<ul> <li>Executes the selected algorithm and immediately updates the world with chosen assignments (moves UAVs to transit, creates transit path for RBDDG; other methods may use a straight line by default for performance).</li> </ul> </li> <li> <p><code>compute_cost(world, uav_ids, task_ids, use_dubins)</code>:</p> <ul> <li>Builds the cost matrix and id-index mappings.</li> </ul> </li> <li> <p>AlgorithmType values (examples): <code>GBA</code>, <code>HBA</code>, <code>AA</code>, <code>RBDD</code>, <code>PRBDD</code>, <code>SA</code>.</p> </li> <li> <p>Supporting utilities:</p> </li> <li><code>greedy_global_assign_int(cost, unassigned_value=-1) -&gt; List[int]</code></li> <li><code>hungarian_assign(cost, unassigned_value=-1) -&gt; List[int]</code></li> <li><code>auction_assign(cost, alpha=5.0, unassigned_value=-1) -&gt; List[int]</code></li> <li><code>simulated_annealing_assignment(C,...) -&gt; List[int]</code></li> </ul>"},{"location":"algorithms/assignment/#example-one-shot-assignment","title":"Example: one-shot assignment","text":"<pre><code>from multi_uav_planner.world_models import World\nfrom multi_uav_planner.scenario_generation import ScenarioConfig, ScenarioType, AlgorithmType, generate_scenario\nfrom multi_uav_planner.simulation_loop import simulate_mission\n\ncfg = ScenarioConfig(\n    base=(0,0,0), area_width=2500, area_height=2500,\n    n_uavs=4, n_tasks=20, scenario_type=ScenarioType.NONE,\n    alg_type=AlgorithmType.HBA, seed=7\n)\nscenario = generate_scenario(cfg)\n\nworld = World(tasks={}, uavs={})\nsimulate_mission(world, scenario, dt=0.3, max_time=1e5)\nprint(\"done:\", world.done(), \"at_base:\", world.at_base())\n</code></pre> <p>To evaluate just the assignment step (outside the full loop), use <code>compute_cost</code> and one of the solvers:</p> <pre><code>from multi_uav_planner.assignment import compute_cost, hungarian_assign, greedy_global_assign_int\n# Choose idle UAVs and unassigned tasks\nu_ids = world.idle_uavs\nt_ids = world.unassigned\n\n# Cost: Euclidean or Dubins path length\nC, u_list, t_list, u_idx, t_idx = compute_cost(world, u_ids, t_ids, use_dubins=False)\n\n# Hungarian assignment (optimal on C)\nmatch = hungarian_assign(C, unassigned_value=-1)  # list of length len(u_ids)\nuid_to_tid = {}\nfor i, j in enumerate(match):\n    if j != -1:\n        uid = u_list[i]\n        tid = t_list[j]\n        uid_to_tid[uid] = tid\n\nprint(\"Assignments:\", uid_to_tid)\n</code></pre>"},{"location":"algorithms/assignment/#integration-in-the-simulation","title":"Integration in the simulation","text":"<ul> <li>PRBDDG:</li> <li>At initialization (or while UAVs are idle), clustering partitions unassigned tasks and computes cluster centers.</li> <li>For each idle UAV, restrict candidate tasks to its cluster and run greedy assignment with Dubins-aware costs locally.</li> <li> <p>Update world: the UAV enters transit; a transit path is planned (you can enable Dubins-aware transit for fidelity).</p> </li> <li> <p>RBDDG:</p> </li> <li>Build the global cost matrix using Dubins path lengths.</li> <li> <p>After assignment, plan a Dubins-aware transit path immediately for each assigned UAV.</p> </li> <li> <p>GBA / HBA / AA / SA:</p> </li> <li>In the default code, Euclidean costs are used for speed.</li> <li>After assignment, some variants plan transit as a straight line (for lightweight demos). Switch to <code>plan_path_to_task</code> to use Dubins-aware transit for kinematic fidelity.</li> </ul>"},{"location":"algorithms/assignment/#rectangular-matrices-and-unassigned-workers","title":"Rectangular matrices and unassigned workers","text":"<ul> <li>Hungarian handles rectangular matrices natively.</li> <li>Greedy and Auction handle fewer tasks than UAVs via unassigned markers or dummy padding:</li> <li>Greedy returns <code>-1</code> for unassigned workers.</li> <li>Auction pads with high-cost dummy tasks; workers mapped to dummy return <code>-1</code>.</li> <li>When $\\(m &lt; n\\)$ (fewer tasks than UAVs), expect some UAVs to remain idle or to return to base.</li> </ul>"},{"location":"algorithms/assignment/#complexity-rough","title":"Complexity (rough)","text":"<ul> <li>Greedy (GBA): $\\(O(nm)\\)$ per selection step, repeated $\\(\\min(n,m)\\)$ times.</li> <li>Hungarian (HBA): $\\(O(k^3)\\)$ with $\\(k=\\max(n,m)\\)$.</li> <li>Auction (AA): typically near linear in practice for moderate sizes; depends on $\\(\\epsilon\\)$ and price updates.</li> <li>Simulated Annealing (SA): user-chosen budget (iterations); often significantly higher wall-clock than others.</li> </ul>"},{"location":"algorithms/assignment/#proscons-summary","title":"Pros/cons summary","text":"<ul> <li>Greedy (GBA): fastest; lowest quality ceiling.</li> <li>Hungarian (HBA): optimal on the input matrix; good baseline; heavier.</li> <li>Auction (AA): scalable; tunable accuracy vs speed; approximate.</li> <li>SA: heuristic; can reach good solutions with time; slow and stochastic.</li> <li>RBDDG: Dubins-aware globally; robust quality; moderate speed.</li> <li>PRBDDG: cluster-first + Dubins-aware in clusters; fast and near-optimal for many spatial distributions.</li> </ul>"},{"location":"algorithms/assignment/#validation-checklist","title":"Validation checklist","text":"<ul> <li>Cost matrix built from the intended model:</li> <li>Euclidean for speed, or Dubins for kinematics.</li> <li>ID/index mappings consistent:</li> <li><code>u_idx[uid]</code> maps rows, <code>t_idx[tid]</code> maps columns.</li> <li>One-to-one assignment:</li> <li>Each UAV assigned at most one task; tasks not reused.</li> <li>World updates coherent:</li> <li>Move task ids from <code>unassigned</code> \u2192 <code>assigned</code> \u2192 <code>completed</code> in sequence.</li> <li>Set <code>u.state = 1</code> (transit) and create a transit path (preferably via <code>plan_path_to_task</code>).</li> <li>Rectangular handling correct:</li> <li>When <code>m &lt; n</code>, unassigned workers have <code>-1</code> and stay idle or return to base.</li> </ul>"},{"location":"algorithms/assignment/#common-pitfalls","title":"Common pitfalls","text":"<ul> <li>Using Euclidean costs in scenarios dominated by heading/turn-radius constraints:</li> <li>Results may look short but be kinematically inefficient; compare with Dubins-aware costs for final evaluations.</li> <li>Not restoring patched functions after timing runs:</li> <li>Always restore originals if you monkey-patch to measure planning time.</li> <li>Cluster size/mismatch:</li> <li>Ensure $\\(K = \\min(\\#\\text{idle UAVs}, \\#\\text{unassigned tasks})\\)$; if an idle UAV\u2019s cluster is empty, skip or fall back to global assignment.</li> </ul>"},{"location":"algorithms/assignment/#references","title":"References","text":"<ul> <li>Hungarian: <code>scipy.optimize.linear_sum_assignment</code></li> <li>Auction: Bertsekas, D. P. (1988), \u201cThe Auction Algorithm: A Distributed Relaxation Method for the Assignment Problem.\u201d</li> <li>Simulated annealing (generic meta-heuristics literature).</li> <li>Implementation:</li> <li><code>src/multi_uav_planner/assignment.py</code> (solvers and <code>assignment</code>)</li> <li><code>src/multi_uav_planner/clustering.py</code> (PRBDDG preprocessing)</li> <li><code>src/multi_uav_planner/path_planner.py</code> (transit plan creation)</li> </ul>"},{"location":"algorithms/clustering/","title":"Algorithms \u00b7 Clustering","text":"<p>This page documents task clustering and cluster\u2192UAV assignment used to reduce the decision space before allocation. Clustering is a preprocessing step that groups nearby tasks, computes cluster centers, and maps clusters to idle UAVs, improving both solution quality and planning time.</p>"},{"location":"algorithms/clustering/#goals","title":"Goals","text":"<ul> <li>Partition unassigned tasks into $\\(K\\)$ spatial clusters.</li> <li>Compute cluster centers ($\\(x_c, y_c\\)$) for each cluster.</li> <li>Assign each cluster to a distinct idle UAV (e.g., by proximity or optimally via Hungarian).</li> <li>Reduce the size of the allocation decision space for each UAV.</li> </ul>"},{"location":"algorithms/clustering/#when-clustering-is-applied","title":"When clustering is applied","text":"<ul> <li>At initialization for algorithms that rely on cluster preprocessing (e.g., $\\(\\text{PRBDDG}\\)$).</li> <li>Dynamically upon events:</li> <li>NEW_TASK: assign the new task to the nearest cluster (or nearest UAV cluster center).</li> <li>UAV_DAMAGE: redistribute the damaged UAV\u2019s cluster tasks to other UAVs by proximity.</li> </ul>"},{"location":"algorithms/clustering/#choosing-the-number-of-clusters","title":"Choosing the number of clusters","text":"<p>Let: - $\\(U_{\\text{idle}}\\)$ be the set of idle UAVs, - $\\(T_{\\text{unassigned}}\\)$ be the set of unassigned tasks.</p> <p>We choose: - $\\(K = \\min\\left(\\#U_{\\text{idle}},\\; \\#T_{\\text{unassigned}}\\right).\\)$</p> <p>If $\\(\\#T_{\\text{unassigned}} &lt; \\#U_{\\text{idle}}\\)$, multiple idle UAVs may be left without assigned clusters (and will remain idle or return to base later).</p>"},{"location":"algorithms/clustering/#algorithm","title":"Algorithm","text":"<p>1) Build positions matrix $\\(X \\in \\mathbb{R}^{N \\times 2}\\)$ from the tasks:    - $\\(X_i = (x_i, y_i).\\)$ 2) Run KMeans (with fixed random_state for reproducibility):    - Obtain labels $\\(\\ell_i \\in \\{0,\\dots,K-1\\}\\)$ and centers $\\(C_k = (c^x_k, c^y_k).\\)$ 3) Map clusters to idle UAVs:    - Build cost matrix $\\(\\text{cost}[i,j] = \\|U_i - C_j\\|^2\\)$ using UAV current positions $\\(U_i = (u^x_i, u^y_i).\\)$    - Assign each cluster to a distinct UAV:      - Greedy: pick globally lowest cost pairs without reuse.      - Hungarian: solve optimally for squared Euclidean distance. 4) Update UAV state:    - For UAV $\\(u\\)$ assigned cluster $\\(k\\)$:      - Set <code>u.cluster = {task ids with label == k}</code>.      - Set <code>u.cluster_CoG = (c^x_k, c^y_k)</code>.</p>"},{"location":"algorithms/clustering/#api-mapping","title":"API mapping","text":"<p>From <code>multi_uav_planner.clustering</code>: - <code>cluster_tasks_kmeans(tasks, n_clusters, random_state=...) -&gt; TaskClusterResult</code>:   - Returns <code>clusters: Dict[int, List[Task]]</code>, <code>centers: np.ndarray (K,2)</code>, <code>task_to_cluster: Dict[int, int]</code>. - <code>assign_clusters_to_uavs_by_proximity(uavs, centers) -&gt; Dict[int, int]</code>:   - Returns <code>cluster_index -&gt; uav_id</code>. - <code>cluster_tasks(world) -&gt; Optional[Dict[int, Set[int]]]</code>:   - High-level pipeline: picks $\\(K\\)$, runs KMeans, assigns clusters to idle UAVs, and populates <code>u.cluster</code> and <code>u.cluster_CoG</code>.</p>"},{"location":"algorithms/clustering/#example-static-clustering-at-init","title":"Example (static clustering at init)","text":"<pre><code>from multi_uav_planner.world_models import World\nfrom multi_uav_planner.clustering import cluster_tasks\n\n# Assume 'world' is initialized with tasks and UAVs,\n# and that some UAVs are idle while tasks are unassigned.\ncluster_map = cluster_tasks(world)\nif cluster_map is None:\n    print(\"No clustering performed (no idle UAVs or no unassigned tasks).\")\nelse:\n    for uid, task_ids in cluster_map.items():\n        print(f\"UAV {uid} cluster size:\", len(task_ids),\n              \"CoG:\", world.uavs[uid].cluster_CoG)\n</code></pre>"},{"location":"algorithms/clustering/#dynamic-behaviors","title":"Dynamic behaviors","text":""},{"location":"algorithms/clustering/#new-tasks","title":"New tasks","text":"<p>When a NEW_TASK event arrives, the task is attached to the nearest cluster center (or nearest UAV\u2019s cluster center). If the chosen UAV has no cluster yet, use its current position as the center. After insertion: - Update <code>u.cluster</code> to include the new task id. - Recompute <code>u.cluster_CoG</code> as the average of task positions in that cluster.</p>"},{"location":"algorithms/clustering/#uav-damage","title":"UAV damage","text":"<p>If a UAV becomes damaged: - Its cluster (if any) is emptied and each task is reassigned to the closest remaining UAV cluster center. - <code>u.cluster_CoG</code> is cleared for the damaged UAV.</p>"},{"location":"algorithms/clustering/#distance-models","title":"Distance models","text":"<p>Squared Euclidean distance for proximity: - $\\(\\text{cost}[i,j] = (c^x_j - u^x_i)^2 + (c^y_j - u^y_i)^2.\\)$</p> <p>This distance is consistent with KMeans clustering assumptions and is inexpensive to compute. If needed, you can switch to Euclidean distance or even Dubins distance for better kinematic fidelity; however, clustering is typically kept simple for speed.</p>"},{"location":"algorithms/clustering/#validation-checklist","title":"Validation checklist","text":"<ul> <li>K selection:</li> <li>$\\(K = \\min(\\#U_{\\text{idle}}, \\#T_{\\text{unassigned}})\\)$ and $\\(K \\ge 1\\)$.</li> <li>KMeans input:</li> <li>Positions matrix shape $\\(N \\times 2\\)$; $\\(K \\le N\\)$.</li> <li>Cluster assignment:</li> <li>Returned mapping uses distinct UAVs and distinct clusters (no reuse).</li> <li>World updates:</li> <li>For each assigned UAV:<ul> <li><code>u.cluster</code> is a set of task ids,</li> <li><code>u.cluster_CoG</code> is a tuple <code>(float, float)</code>.</li> </ul> </li> </ul>"},{"location":"algorithms/clustering/#complexity-and-performance","title":"Complexity and performance","text":"<ul> <li>KMeans: roughly $\\(O(NK \\cdot I)\\)$, where $\\(N\\)$ is the number of tasks, $\\(K\\)$ is clusters, $\\(I\\)$ is iterations (fixed).</li> <li>Assignment:</li> <li>Greedy: $\\(O(K^2)\\)$ iterating over pairs.</li> <li>Hungarian: $\\(O(K^3)\\)$ but small constants for typical $\\(K\\)$ (number of idle UAVs).</li> <li>Overall: preprocessing is fast compared to full assignment and path planning; it shrinks the decision space effectively.</li> </ul>"},{"location":"algorithms/clustering/#common-pitfalls","title":"Common pitfalls","text":"<ul> <li>$\\(K &gt; N\\)$: KMeans initialization fails. Always enforce $\\(K \\le N\\)$.</li> <li>Mismatch between clusters and UAV count:</li> <li>The proximity routine expects $\\(K = \\#U_{\\text{idle}}\\)$; ensure your K selection matches the number of idle UAVs, or use a rectangular assignment method that handles $\\(K \\ne \\#U_{\\text{idle}}\\)$.</li> <li>Forgetting to update <code>cluster_CoG</code> after tasks are added/removed dynamically (NEW_TASK or UAV_DAMAGE) can degrade later proximity decisions.</li> </ul>"},{"location":"algorithms/clustering/#references","title":"References","text":"<ul> <li>KMeans clustering (<code>sklearn.cluster.KMeans</code>) for task grouping.</li> <li>Hungarian assignment (<code>scipy.optimize.linear_sum_assignment</code>) for optimal cluster\u2192UAV mapping (optional).</li> <li>Implementation:</li> <li><code>src/multi_uav_planner/clustering.py</code></li> <li>Event integration in <code>src/multi_uav_planner/events.py</code></li> </ul>"},{"location":"algorithms/dubins/","title":"Algorithms \u00b7 Dubins Paths","text":"<p>This page documents the Dubins path constructions used in the planner, their feasibility conditions, length computation, and how they map to the code API. Dubins paths provide shortest, curvature\u2011bounded routes for fixed\u2011wing UAVs subject to a minimum turn radius and heading constraints.</p>"},{"location":"algorithms/dubins/#key-ideas","title":"Key ideas","text":"<ul> <li>Turning is constrained by the UAV\u2019s minimum turn radius $\\(R\\)$.</li> <li>A Dubins path is composed of straight segments ($\\(S\\)\\() and circular arcs (\\)\\(C\\)$) with constant curvature $\\(1/R\\)$.</li> <li>We use two families:</li> <li>CS: one circular arc then one straight segment ($\\(\\text{LS}\\)$ or $\\(\\text{RS}\\)$).</li> <li>CSC: two circular arcs with an intermediate straight segment ($\\(\\text{LSL}, \\text{LSR}, \\text{RSL}, \\text{RSR}\\)$).</li> </ul>"},{"location":"algorithms/dubins/#notation","title":"Notation","text":"<ul> <li>$\\(R\\)$: minimum turn radius (meters).</li> <li>$\\(p = (x, y, \\theta)\\)$: pose with position $\\(x,y\\)$ and heading $\\(\\theta\\)$ (radians).</li> <li>$\\(p_s = (x_s, y_s, \\theta_s)\\)$: start pose.</li> <li>$\\(p_f = (x_f, y_f, \\theta_f)\\)$: final pose (for CSC).</li> <li>$\\(C\\)$: circular arc; $\\(S\\)$: straight segment.</li> </ul>"},{"location":"algorithms/dubins/#feasibility-conditions","title":"Feasibility conditions","text":"<ul> <li>CS exists if the tangent from the start circle to the target point exists:</li> <li>Let $\\(d\\)$ be the distance from the center of the start circle to the target point; CS is feasible iff $\\(d \\ge R\\)$.</li> <li>CSC inner tangents ($\\(\\text{LSR}, \\text{RSL}\\)$) require sufficient separation of circle centers:</li> <li>Let $\\(d\\)$ be the distance between start and end circle centers; inner tangents feasible iff $\\(\\frac{2R}{d} \\le 1\\)$.</li> <li>CSC outer tangents ($\\(\\text{LSL}, \\text{RSR}\\)$) are generally feasible for $\\(d &gt; 0\\)$.</li> </ul>"},{"location":"algorithms/dubins/#segment-lengths","title":"Segment lengths","text":"<ul> <li>Straight segment:</li> <li> \\[L_S = \\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}.\\] </li> <li>Arc segment:</li> <li> \\[L_C = R \\cdot \\left|\\Delta \\theta\\right|.\\] </li> <li>Total path length:</li> <li> \\[L = \\sum_i L_i = \\sum \\left(L_S + L_C\\right).\\] </li> </ul>"},{"location":"algorithms/dubins/#cs-construction-lsrs","title":"CS construction (LS/RS)","text":"<p>Given $\\(p_s = (x_0,y_0,\\theta_0)\\)$ and target point $\\(p_f = (x_f,y_f)\\)$:</p> <p>1) Start circle center:    - $\\(\\theta_c = \\theta_0 + \\frac{\\pi}{2}\\)$ for $\\(\\text{LS}\\)$; $\\(\\theta_c = \\theta_0 - \\frac{\\pi}{2}\\)$ for $\\(\\text{RS}\\)$.    - $\\(x_c = x_0 + R \\cos(\\theta_c), \\quad y_c = y_0 + R \\sin(\\theta_c).\\)$ 2) Tangent feasibility:    - $\\(d = \\sqrt{(x_f - x_c)^2 + (y_f - y_c)^2}\\)$; if $\\(d &lt; R\\)$, CS infeasible. 3) Bearing to target and offset:    - $\\(\\theta_{sf} = \\operatorname{atan2}(y_f - y_c, x_f - x_c), \\quad \\theta_{mf} = \\arcsin\\!\\left(\\frac{R}{d}\\right).\\)$ 4) Tangent direction $\\(\\theta_M\\)$ and arc start angle $\\(\\theta_s^\\text{arc}\\)$:    - $\\(\\text{LS}: \\ \\theta_M = \\theta_{sf} + \\theta_{mf} - \\frac{\\pi}{2}, \\ \\theta_s^\\text{arc} = \\theta_0 - \\frac{\\pi}{2}.\\)$    - $\\(\\text{RS}: \\ \\theta_M = \\theta_{sf} - \\theta_{mf} + \\frac{\\pi}{2}, \\ \\theta_s^\\text{arc} = \\theta_0 + \\frac{\\pi}{2}.\\)$    - Signed arc sweep:      - $\\(\\Delta \\theta_{\\text{LS}} = (\\theta_M - \\theta_s^\\text{arc}) \\bmod 2\\pi.\\)$      - $\\(\\Delta \\theta_{\\text{RS}} = \\left[(\\theta_M - \\theta_s^\\text{arc}) \\bmod 2\\pi\\right] - 2\\pi.\\)$ 5) Tangent point:    - $\\(x_M = x_c + R \\cos(\\theta_M), \\quad y_M = y_c + R \\sin(\\theta_M).\\)$ 6) Path segments:    - Arc: center $\\((x_c,y_c)\\)$, radius $\\(R\\)$, start angle $\\(\\theta_s^\\text{arc}\\)$, sweep $\\(\\Delta \\theta\\)$.    - Straight: $\\(S((x_M,y_M) \\to (x_f,y_f)).\\)$</p> <p>Choose the shorter of $\\(\\text{LS}\\)$ or $\\(\\text{RS}\\)$.</p>"},{"location":"algorithms/dubins/#csc-construction-lsllsrrslrsr","title":"CSC construction (LSL/LSR/RSL/RSR)","text":"<p>Given $\\(p_s = (x_0,y_0,\\theta_0)\\)$ and $\\(p_f = (x_f,y_f,\\theta_f)\\)$:</p> <p>1) Start circle center:    - $\\(\\theta_c^s = \\theta_0 \\pm \\frac{\\pi}{2}, \\quad (x_c^s, y_c^s) = (x_0 + R \\cos \\theta_c^s, \\ y_0 + R \\sin \\theta_c^s).\\)$ 2) End circle center:    - $\\(\\theta_c^f = \\theta_f \\pm \\frac{\\pi}{2}, \\quad (x_c^f, y_c^f) = (x_f + R \\cos \\theta_c^f, \\ y_f + R \\sin \\theta_c^f).\\)$ 3) Center\u2011to\u2011center bearing and distance:    - $\\(d = \\sqrt{(x_c^f - x_c^s)^2 + (y_c^f - y_c^s)^2}, \\quad \\theta_{sf} = \\operatorname{atan2}(y_c^f - y_c^s, x_c^f - x_c^s).\\)$ 4) Inner tangent offset for $\\(\\text{LSR}/\\text{RSL}\\)$:    - $\\(\\theta_{mn} = \\arcsin\\!\\left(\\frac{2R}{d}\\right)\\)$ if $\\(\\frac{2R}{d} \\le 1\\)$, else these inner types are infeasible. 5) Tangent directions:    - $\\(\\text{LSL}: \\ \\theta_M = \\theta_{sf} - \\frac{\\pi}{2}, \\ \\theta_N = \\theta_{sf} - \\frac{\\pi}{2}.\\)$    - $\\(\\text{RSR}: \\ \\theta_M = \\theta_{sf} + \\frac{\\pi}{2}, \\ \\theta_N = \\theta_{sf} + \\frac{\\pi}{2}.\\)$    - $\\(\\text{LSR}: \\ \\theta_M = \\theta_{sf} + \\theta_{mn} - \\frac{\\pi}{2}, \\ \\theta_N = \\theta_{sf} + \\theta_{mn} + \\frac{\\pi}{2}.\\)$    - $\\(\\text{RSL}: \\ \\theta_M = \\theta_{sf} - \\theta_{mn} + \\frac{\\pi}{2}, \\ \\theta_N = \\theta_{sf} - \\theta_{mn} - \\frac{\\pi}{2}.\\)$ 6) Tangent points:    - $\\(M: \\ (x_M,y_M) = (x_c^s + R \\cos \\theta_M, \\ y_c^s + R \\sin \\theta_M).\\)$    - $\\(N: \\ (x_N,y_N) = (x_c^f + R \\cos \\theta_N, \\ y_c^f + R \\sin \\theta_N).\\)$ 7) Arc sweeps:    - Compute signed $\\(\\Delta \\theta_1\\)$ from start\u2011arc angle to $\\(\\theta_M\\)$ based on left/right convention; compute $\\(\\Delta \\theta_2\\)$ from $\\(\\theta_N\\)$ to end\u2011arc angle similarly. 8) Path segments:    - Arc1 $\\((x_c^s,y_c^s,R,\\theta_s^\\text{arc,start},\\Delta \\theta_1)\\)$; Straight $\\(S(M \\to N)\\)$; Arc2 $\\((x_c^f,y_c^f,R,\\theta_N,\\Delta \\theta_2)\\)$.</p> <p>Choose the shortest among $\\(\\text{LSL}, \\text{LSR}, \\text{RSL}, \\text{RSR}\\)$.</p>"},{"location":"algorithms/dubins/#angle-normalization-and-comparisons","title":"Angle normalization and comparisons","text":"<ul> <li>Normalize angles to $\\([0, 2\\pi)\\)$ when computing sweeps.</li> <li>Wrap\u2011aware difference for comparisons:</li> <li> \\[\\operatorname{ang\\_diff}(a, b) = ((a - b + \\pi) \\bmod 2\\pi) - \\pi.\\] </li> </ul>"},{"location":"algorithms/dubins/#api-mapping","title":"API mapping","text":"<p>From <code>multi_uav_planner.dubins</code>: - <code>cs_segments_single(start, end, radius, path_type)</code>:   - Build one CS path (<code>\"LS\"</code> or <code>\"RS\"</code>), returns <code>Path</code> or <code>None</code>. - <code>cs_segments_shortest(start, end, radius)</code>:   - Return shortest feasible CS path (<code>Path</code>). - <code>csc_segments_single(start, end, radius, path_type)</code>:   - Build one CSC path (<code>\"LSL\"</code>, <code>\"LSR\"</code>, <code>\"RSL\"</code>, <code>\"RSR\"</code>), returns <code>Path</code> or <code>None</code>. - <code>csc_segments_shortest(start, end, radius)</code>:   - Return shortest feasible CSC path (<code>Path</code>).</p> <p>Types: - <code>start</code>: <code>(x0, y0, theta0)</code>. - <code>end</code> (CS): <code>(xf, yf)</code>. - <code>end</code> (CSC): <code>(xf, yf, thetaf)</code>. - <code>radius</code>: <code>R &gt; 0</code>.</p>"},{"location":"algorithms/dubins/#examples","title":"Examples","text":"<p>Compute CS shortest: <pre><code>from math import pi\nfrom multi_uav_planner.dubins import cs_segments_shortest\n\nstart = (50.0, 50.0, pi/6)\nend   = (220.0, 80.0)\nR     = 40.0\n\npath = cs_segments_shortest(start, end, R)\nprint(\"CS length:\", path.length())\n</code></pre></p> <p>Compute CSC shortest:</p>"},{"location":"algorithms/dubins/#algorithms-dubins-paths_1","title":"Algorithms \u00b7 Dubins Paths","text":"<p>This page documents the Dubins path constructions used in the planner, their feasibility conditions, length computation, and how they map to the code API. Dubins paths provide shortest, curvature\u2011bounded routes for fixed\u2011wing UAVs subject to a minimum turn radius and heading constraints.</p>"},{"location":"algorithms/dubins/#key-ideas_1","title":"Key ideas","text":"<ul> <li>Turning is constrained by the UAV\u2019s minimum turn radius $\\(R\\)$.</li> <li>A Dubins path is composed of straight segments ($\\(S\\)\\() and circular arcs (\\)\\(C\\)$) with constant curvature $\\(1/R\\)$.</li> <li>We use:</li> <li>CS type: one circular arc then one straight segment.</li> <li>CSC type: two circular arcs with an intermediate straight segment.</li> </ul>"},{"location":"algorithms/dubins/#notation_1","title":"Notation","text":"<ul> <li>$\\(R\\)$: minimum turn radius (meters).</li> <li>$\\(p = (x, y, \\theta)\\)$: pose with position $\\(x,y\\)$ and heading $\\(\\theta\\)$ (radians).</li> <li>$\\(p_s = (x_s, y_s, \\theta_s)\\)$: start pose.</li> <li>$\\(p_f = (x_f, y_f, \\theta_f)\\)$: final pose (for CSC).</li> <li>$\\(C\\)$: circular arc segment; $\\(S\\)$: straight segment.</li> <li>Path types:</li> <li>CS: $\\(\\text{LS}\\)$ (left arc then straight), $\\(\\text{RS}\\)$ (right arc then straight).</li> <li>CSC: $\\(\\text{LSL}, \\text{LSR}, \\text{RSL}, \\text{RSR}\\)$.</li> </ul>"},{"location":"algorithms/dubins/#feasibility-conditions_1","title":"Feasibility conditions","text":"<ul> <li>CS feasibility requires a valid tangent from the start circle to the end point:</li> <li>Let $\\(d\\)$ be the distance from the center of the start circle to the target point. Then:</li> <li>CS exists if $\\(d \\ge R\\)$.</li> <li>CSC inner tangents ($\\(\\text{LSR}, \\text{RSL}\\)$) require the circle centers to be sufficiently separated:</li> <li>Let $\\(d\\)$ be the distance between start and end circle centers. Then:</li> <li>Inner tangents exist if $\\(\\frac{2R}{d} \\le 1\\)$.</li> <li>Outer tangents ($\\(\\text{LSL}, \\text{RSR}\\)$) exist for any $\\(d &gt; 0\\)$ (with non\u2011coincident circle centers).</li> </ul>"},{"location":"algorithms/dubins/#segment-lengths_1","title":"Segment lengths","text":"<ul> <li>Straight segment length:</li> <li> \\[L_S = \\|p_2 - p_1\\| = \\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}.\\] </li> <li>Arc segment length:</li> <li> \\[L_C = R \\cdot \\left|\\Delta \\theta\\right|.\\] </li> <li>Here $\\(\\Delta \\theta\\)$ is the signed sweep angle of the arc (positive counterclockwise, negative clockwise).</li> </ul> <p>Total path length is the sum of segment lengths across all segments in the path.</p>"},{"location":"algorithms/dubins/#cs-construction-lsrs_1","title":"CS construction (LS/RS)","text":"<p>Given $\\(p_s = (x_0,y_0,\\theta_0)\\)$ and the target point $\\(p_f = (x_f,y_f)\\)$:</p> <p>1) Compute the center of the start circle:    - For $\\(\\text{LS}\\)$: center heading $\\(\\theta_c = \\theta_0 + \\frac{\\pi}{2}\\)$.    - For $\\(\\text{RS}\\)$: center heading $\\(\\theta_c = \\theta_0 - \\frac{\\pi}{2}\\)$.    - Center coordinates:      - $\\(x_c = x_0 + R \\cos(\\theta_c), \\quad y_c = y_0 + R \\sin(\\theta_c).\\)$ 2) Tangent feasibility:    - Distance to target:      - $\\(d = \\sqrt{(x_f - x_c)^2 + (y_f - y_c)^2}.\\)$    - If $\\(d &lt; R\\)$, CS is infeasible. 3) Tangent angle:    - $\\(\\theta_{sf} = \\operatorname{atan2}(y_f - y_c, x_f - x_c).\\)$    - $\\(\\theta_{mf} = \\arcsin\\!\\left(\\frac{R}{d}\\right).\\)$ 4) Tangent point direction $\\(\\theta_M\\)$:    - For $\\(\\text{LS}\\)$:      - $\\(\\theta_M = \\theta_{sf} + \\theta_{mf} - \\frac{\\pi}{2}, \\quad \\theta_s^\\text{arc} = \\theta_0 - \\frac{\\pi}{2}.\\)$      - $\\(\\Delta \\theta = (\\theta_M - \\theta_s^\\text{arc}) \\bmod 2\\pi.\\)$    - For $\\(\\text{RS}\\)$:      - $\\(\\theta_M = \\theta_{sf} - \\theta_{mf} + \\frac{\\pi}{2}, \\quad \\theta_s^\\text{arc} = \\theta_0 + \\frac{\\pi}{2}.\\)$      - $\\(\\Delta \\theta = \\left[(\\theta_M - \\theta_s^\\text{arc}) \\bmod 2\\pi\\right] - 2\\pi.\\)$ 5) Tangent point coordinates:    - $\\(x_M = x_c + R \\cos(\\theta_M), \\quad y_M = y_c + R \\sin(\\theta_M).\\)$ 6) Path segments:    - Arc: center $\\((x_c,y_c)\\)$, radius $\\(R\\)$, start angle $\\(\\theta_s^\\text{arc}\\)$, sweep $\\(\\Delta \\theta\\)$.    - Straight: $\\(S((x_M,y_M) \\to (x_f,y_f)).\\)$</p> <p>Pick $\\(\\text{LS}\\)$ or $\\(\\text{RS}\\)$ that yields the shorter total length.</p>"},{"location":"algorithms/dubins/#csc-construction-lsllsrrslrsr_1","title":"CSC construction (LSL/LSR/RSL/RSR)","text":"<p>Given $\\(p_s = (x_0,y_0,\\theta_0)\\)$ and $\\(p_f = (x_f,y_f,\\theta_f)\\)$:</p> <p>1) Compute start circle center:    - $\\(\\theta_c^s = \\theta_0 \\pm \\frac{\\pi}{2}\\)$ (left +, right \u2013).    - $\\(x_c^s = x_0 + R \\cos(\\theta_c^s), \\quad y_c^s = y_0 + R \\sin(\\theta_c^s).\\)$ 2) Compute end circle center:    - $\\(\\theta_c^f = \\theta_f \\pm \\frac{\\pi}{2}\\)$ (left +, right \u2013).    - $\\(x_c^f = x_f + R \\cos(\\theta_c^f), \\quad y_c^f = y_f + R \\sin(\\theta_c^f).\\)$ 3) Vector between circle centers:    - $\\(d = \\sqrt{(x_c^f - x_c^s)^2 + (y_c^f - y_c^s)^2}, \\quad \\theta_{sf} = \\operatorname{atan2}(y_c^f - y_c^s, x_c^f - x_c^s).\\)$ 4) Inner tangent angle offset (only for $\\(\\text{LSR}, \\text{RSL}\\)$):    - $\\(\\theta_{mn} = \\arcsin\\!\\left(\\frac{2R}{d}\\right)\\)$ if $\\(\\frac{2R}{d} \\le 1\\)$, else infeasible. 5) Tangent directions:    - $\\(\\text{LSL}: \\quad \\theta_M = \\theta_{sf} - \\frac{\\pi}{2}, \\quad \\theta_N = \\theta_{sf} - \\frac{\\pi}{2}.\\)$    - $\\(\\text{RSR}: \\quad \\theta_M = \\theta_{sf} + \\frac{\\pi}{2}, \\quad \\theta_N = \\theta_{sf} + \\frac{\\pi}{2}.\\)$    - $\\(\\text{LSR}: \\quad \\theta_M = \\theta_{sf} + \\theta_{mn} - \\frac{\\pi}{2}, \\quad \\theta_N = \\theta_{sf} + \\theta_{mn} + \\frac{\\pi}{2}.\\)$    - $\\(\\text{RSL}: \\quad \\theta_M = \\theta_{sf} - \\theta_{mn} + \\frac{\\pi}{2}, \\quad \\theta_N = \\theta_{sf} - \\theta_{mn} - \\frac{\\pi}{2}.\\)$ 6) Tangent points:    - $\\(x_M = x_c^s + R \\cos(\\theta_M), \\quad y_M = y_c^s + R \\sin(\\theta_M).\\)$    - $\\(x_N = x_c^f + R \\cos(\\theta_N), \\quad y_N = y_c^f + R \\sin(\\theta_N).\\)$ 7) Arc sweeps (signed):    - For the start arc, compute $\\(\\Delta \\theta_1\\)$ from $\\(\\theta_s^\\text{arc,start}\\)$ to $\\(\\theta_M\\)$ with proper wrap/sign per left/right.    - For the end arc, compute $\\(\\Delta \\theta_2\\)$ from $\\(\\theta_N\\)$ to $\\(\\theta_f^\\text{arc,end}\\)$ with proper wrap/sign. 8) Path segments:    - Arc1: $\\((x_c^s, y_c^s, R, \\theta_s^\\text{arc,start}, \\Delta \\theta_1).\\)$    - Straight: $\\(S((x_M,y_M) \\to (x_N,y_N)).\\)$    - Arc2: $\\((x_c^f, y_c^f, R, \\theta_N, \\Delta \\theta_2).\\)$</p> <p>Compute lengths and select the shortest among $\\(\\text{LSL}, \\text{LSR}, \\text{RSL}, \\text{RSR}\\)$.</p>"},{"location":"algorithms/dubins/#choosing-the-shortest-path","title":"Choosing the shortest path","text":"<ul> <li>CS shortest:</li> <li>Evaluate $\\(\\text{LS}\\)$ and $\\(\\text{RS}\\)$, discard infeasible, pick minimum length.</li> <li>CSC shortest:</li> <li>Evaluate all four types, discard infeasible, pick minimum length.</li> </ul> <p>In code, this logic is provided by: - <code>cs_segments_shortest(start, end, radius)</code>. - <code>csc_segments_shortest(start, end, radius)</code>.</p>"},{"location":"algorithms/dubins/#numerical-stability-and-angle-wrapping","title":"Numerical stability and angle wrapping","text":"<p>When computing signed sweeps: - Always normalize angles to $\\([0, 2\\pi)\\)$ and apply the sign based on left/right convention. - Use consistent angle differences mapped into $\\((-\\pi, \\pi]\\)$ when comparing/aligning headings:   - $\\(\\operatorname{ang\\_diff}(a,b) = ((a - b + \\pi) \\bmod 2\\pi) - \\pi.\\)$</p>"},{"location":"algorithms/dubins/#api-mapping_1","title":"API mapping","text":"<p>Core constructors (from <code>multi_uav_planner.dubins</code>): - <code>cs_segments_single(start, end, radius, path_type)</code>:   - Build one CS path: $\\(\\text{LS}\\)$ or $\\(\\text{RS}\\)$, returns <code>Path</code> or <code>None</code>. - <code>cs_segments_shortest(start, end, radius)</code>:   - Return the shortest feasible CS path (<code>Path</code>). - <code>csc_segments_single(start, end, radius, path_type)</code>:   - Build one CSC path: $\\(\\text{LSL}, \\text{LSR}, \\text{RSL}, \\text{RSR}\\)$, returns <code>Path</code> or <code>None</code>. - <code>csc_segments_shortest(start, end, radius)</code>:   - Return the shortest feasible CSC path (<code>Path</code>).</p> <p>Types: - <code>start</code>: tuple $$ (x_0, y_0, \\theta_0) $$. - <code>end</code> (CS): tuple $$ (x_f, y_f) $$. - <code>end</code> (CSC): tuple $$ (x_f, y_f, \\theta_f) $$. - <code>radius</code>: $\\(R &gt; 0\\)$.</p>"},{"location":"algorithms/dubins/#example-usage","title":"Example usage","text":"<p>Compute and compare CS shortest:</p> <pre><code>from math import pi\nfrom multi_uav_planner.dubins import cs_segments_shortest\n\nstart = (50.0, 50.0, pi/6)\nend   = (220.0, 80.0)\nR     = 40.0\n\npath = cs_segments_shortest(start, end, R)\nprint(\"CS length:\", path.length())\n</code></pre> <p>Compute CSC shortest: <pre><code>from math import pi\nfrom multi_uav_planner.dubins import csc_segments_shortest\n\nstart = (40.0, 40.0, pi/3)\nend   = (250.0, 140.0, -pi/6)\nR     = 50.0\n\npath = csc_segments_shortest(start, end, R)\nprint(\"CSC length:\", path.length())\n</code></pre></p>"},{"location":"algorithms/dubins/#integration-into-planning","title":"Integration into planning","text":"<p>Transit planning chooses between CS and CSC depending on whether the task\u2019s entry heading is constrained:</p> <ul> <li>Unconstrained entry heading:</li> <li>Prefer straight line if headings align within tolerance.</li> <li>Otherwise use CS shortest to the target point.</li> <li>Constrained entry heading:</li> <li>Prefer straight line if both start and end headings align to the line within tolerance.</li> <li>Otherwise:<ul> <li>Try CS (LS/RS) to the point and keep only those whose final straight segment heading matches the required entry heading within $\\(\\text{Tolerances.ang}\\)$. If any remain, pick the shortest.</li> <li>If none remain or CS is infeasible, use CSC shortest (LSL/LSR/RSL/RSR).</li> </ul> </li> </ul> <p>Additional guards in the planner: - Co-located case:   - If position error $\\(\\le \\text{Tolerances.pos}\\)$ and entry heading is unconstrained or within $\\(\\text{Tolerances.ang}\\)$, return an empty <code>Path</code> (no transit).   - Otherwise, use CSC to correct heading in place (degenerate straight).</p> <p>This policy is implemented in: - <code>plan_path_to_task(world, uid, (x_e, y_e, theta_e_or_None))</code> (transit) - <code>plan_mission_path(uav, task)</code> (coverage inside the task)</p> <p>Minimal usage:</p> <pre><code>from math import pi\nfrom multi_uav_planner.world_models import World\nfrom multi_uav_planner.path_planner import plan_path_to_task\n\nworld = World(tasks={}, uavs={}, base=(0,0,0))\n#... initialize world and add a UAV with position (x0, y0, th0)\nuid = 1\nx_e, y_e = 120.0, 80.0\ntheta_e = None  # unconstrained entry heading; set to a float if constrained\npath = plan_path_to_task(world, uid, (x_e, y_e, theta_e))\nprint(\"Transit length:\", path.length())\n</code></pre> <p>When the task requires a specific entry heading, set <code>theta_e</code> to that required value (in radians). The planner will then:</p> <p>1) Attempt a straight line if both start and end headings align with the line within $\\(\\text{Tolerances.ang}\\)\\(. 2) Try CS candidates (\\)\\(\\text{LS}, \\text{RS}\\)$) to the point, and keep only those whose final straight\u2011segment heading matches $\\(\\theta_e\\)$ within $\\(\\text{Tolerances.ang}\\)\\(; if any remain, pick the shortest. 3) If none remain (or CS is infeasible), fall back to the shortest CSC (\\)\\(\\text{LSL}, \\text{LSR}, \\text{RSL}, \\text{RSR}\\)$).</p> <p>Feasibility checks: - CS: require $\\(d \\ge R\\)$, where $\\(d\\)$ is the distance from the start\u2011circle center to the target point. - CSC inner tangents ($\\(\\text{LSR}, \\text{RSL}\\)$): require $\\(\\frac{2R}{d} \\le 1\\)$, where $\\(d\\)$ is the distance between start and end circle centers.</p> <p>Minimal example (constrained entry heading): ```python from math import pi from multi_uav_planner.world_models import World, UAV, PointTask  # or any Task subclass with heading_enforcement from multi_uav_planner.path_planner import plan_path_to_task</p>"},{"location":"algorithms/dubins/#build-a-tiny-world-with-one-uav","title":"Build a tiny world with one UAV","text":"<p>world = World(tasks={}, uavs={}, base=(0.0, 0.0, 0.0)) world.uavs[1] = UAV(id=1, position=(50.0, 50.0, pi/6), turn_radius=60.0) uid = 1</p>"},{"location":"algorithms/dubins/#target-entry-pose-with-constrained-heading-eg-due-east","title":"Target entry pose with constrained heading (e.g., due east)","text":"<p>x_e, y_e = 220.0, 120.0 theta_e = 0.0   # required entry heading (radians)</p> <p>path = plan_path_to_task(world, uid, (x_e, y_e, theta_e)) print(\"Chosen transit length:\", path.length())</p>"},{"location":"algorithms/dubins/#pathsegments-contains-a-cs-or-csc-sequence-that-satisfies-the-heading-within-tolerancesang","title":"path.segments contains a CS or CSC sequence that satisfies the heading within Tolerances.ang","text":""},{"location":"api/multi_uav_planner/","title":"API Reference","text":""},{"location":"api/multi_uav_planner/#multi_uav_planner","title":"<code>multi_uav_planner</code>","text":"<p>multi_uav_planner</p> <p>Dynamic real-time multi-UAV cooperative mission planning under multiple constraints, based on Dubins paths and task allocation / clustering strategies.  Python reimplementation of the methods described in (Liu et al., 2025).  Package includes modular tools for path modeling and Dubins geometry, plus world models, scenarios, clustering, assignment, and simulation.</p>"},{"location":"api/multi_uav_planner/#multi_uav_planner--public-entry-points","title":"Public entry points","text":"<p>Typical usage pattern:</p> <pre><code>from multi_uav_planner import (\n    World,\n    UAV,\n    PointTask, LineTask, CircleTask, AreaTask,\n    ScenarioConfig, Scenario, generate_scenario, initialize_world,\n    simulate_mission,\n    AlgorithmType,\n)\n\n# 1) Build or generate a scenario\ncfg = ScenarioConfig()\nscenario = generate_scenario(cfg)\n\n# 2) Create an empty World and initialize it from the scenario\nworld = World(tasks={}, uavs={})\ninitialize_world(world, scenario)\n\n# 3) Run simulation\nsimulate_mission(world, scenario, dt=0.1)\n\n# 4) Analyze results with post_processing.RunLog, aggregate_metrics, etc.\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.AlgorithmType","title":"<code>AlgorithmType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Identifier for planner/algorithm selection; stored in scenario metadata.</p>"},{"location":"api/multi_uav_planner/#multi_uav_planner.AreaTask","title":"<code>AreaTask(id: int, position: Tuple[float, float], state: Literal[0, 1, 2] = 0, heading_enforcement: bool = False, heading: Optional[float] = None, worked_by_uav: Optional[int] = None, pass_length: float = 10.0, pass_spacing: float = 1.0, num_passes: int = 3, side: Literal['left', 'right'] = 'left')</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Task</code></p> <p>A rectangular/strip-style area coverage task. The planner is expected to produce multiple passes to cover the area.</p> <p>Attributes: - pass_length: length of each pass in meters (default: $\\(10.0\\)$). - pass_spacing: lateral spacing between passes in meters (default: $\\(1.0\\)$). - num_passes: number of passes required (default: $\\(3\\)$). - side: side to begin the first pass: $\\('left'\\)$ or $\\('right'\\)$.</p> <p>Note: - This data model does not include the actual polygon describing the area;   it merely encodes sweep parameters. Geometry generation is delegated to   higher-level components.</p>"},{"location":"api/multi_uav_planner/#multi_uav_planner.CircleTask","title":"<code>CircleTask(id: int, position: Tuple[float, float], state: Literal[0, 1, 2] = 0, heading_enforcement: bool = False, heading: Optional[float] = None, worked_by_uav: Optional[int] = None, radius: float = 10.0, side: Literal['left', 'right'] = 'left')</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Task</code></p> <p>A circular-turn task centered at the task position.</p> <p>Attributes: - radius: radius of the circle in meters (default: $\\(10.0\\)$). - side: which side to traverse first; either $\\('left'\\)$ or $\\('right'\\)$.</p>"},{"location":"api/multi_uav_planner/#multi_uav_planner.CurveSegment","title":"<code>CurveSegment(center: Point, radius: float, theta_s: float, d_theta: float)</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Segment</code></p> <p>A circular-arc segment.</p> <p>Attributes: - center: center point of the circle (xc, yc). - radius: positive radius $\\(R &gt; 0\\)$. - theta_s: start angle in radians (measured from the positive x-axis). - d_theta: signed angular sweep in radians; positive =&gt; CCW rotation,   negative =&gt; CW rotation.</p> <p>Notes and constraints: - The arc length is given by $\\(L = R \\cdot |\\Delta  heta|\\)$ where   $\\(\\Delta  heta =  ext{d\\_theta}\\)$. - The implementation validates that $\\(R &gt; 0\\)$. - By default the class disallows sweeps with absolute value greater than   one full revolution; i.e. it enforces   $\\(|       ext{d\\_theta}| \\le 2\\pi\\)$ (with a tiny tolerance). Adjust or remove   this guard if you need multi-revolution arcs. - Angles are handled in radians. Use angle_at(t) to interpolate the   angular position at normalized parameter $\\(t \\in [0,1]\\)$.</p>"},{"location":"api/multi_uav_planner/#multi_uav_planner.CurveSegment.angle_at","title":"<code>angle_at(t: float) -&gt; float</code>","text":"<p>Return the angular coordinate at normalized parameter $\\(t \\in [0,1]\\)$.</p> <pre><code>    The angle is interpolated linearly:\n    $$      heta(t) =       heta_s + t \\cdot \\Delta heta.$$\n\n    Raises:\n    - ValueError if $$t\n</code></pre> <p>otin [0,1]$$.</p> Source code in <code>src/multi_uav_planner/path_model.py</code> <pre><code>def angle_at(self, t: float) -&gt; float:\n    \"\"\"Return the angular coordinate at normalized parameter $$t \\in [0,1]$$.\n\n    The angle is interpolated linearly:\n    $$\\theta(t) = \\theta_s + t \\cdot \\Delta\\theta.$$\n\n    Raises:\n    - ValueError if $$t \\notin [0,1]$$.\n    \"\"\"\n    if not 0.0 &lt;= t &lt;= 1.0:\n        raise ValueError(\"t must be in [0,1]\")\n    return self.theta_s + t * self.d_theta\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.CurveSegment.end_point","title":"<code>end_point() -&gt; Point</code>","text":"<p>Return the point at $\\(t = 1\\)$ (end of the arc).</p> Source code in <code>src/multi_uav_planner/path_model.py</code> <pre><code>def end_point(self) -&gt; Point:\n    \"\"\"Return the point at $$t = 1$$ (end of the arc).\"\"\"\n    return self.point_at(1.0)\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.CurveSegment.length","title":"<code>length() -&gt; float</code>","text":"<p>Return arc length: $\\(L = R \\cdot |\\Delta        heta|\\)$.</p> Source code in <code>src/multi_uav_planner/path_model.py</code> <pre><code>def length(self) -&gt; float:\n    \"\"\"Return arc length: $$L = R \\cdot |\\Delta\\theta|$$.\"\"\"\n    return abs(self.radius * self.d_theta)\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.CurveSegment.point_at","title":"<code>point_at(t: float) -&gt; Point</code>","text":"<p>Return the Cartesian point on the arc at normalized parameter $\\(t\\)$.</p> <p>Uses: $\\(x = x_c + R \\cos(     heta(t)), \\quad y = y_c + R \\sin(       heta(t)).\\)$</p> Source code in <code>src/multi_uav_planner/path_model.py</code> <pre><code>def point_at(self, t: float) -&gt; Point:\n    \"\"\"Return the Cartesian point on the arc at normalized parameter $$t$$.\n\n    Uses:\n    $$x = x_c + R \\cos(\\theta(t)), \\quad y = y_c + R \\sin(\\theta(t)).$$\n    \"\"\"\n    a = self.angle_at(t)\n    x = self.center[0] + self.radius * cos(a)\n    y = self.center[1] + self.radius * sin(a)\n    return (x, y)\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.CurveSegment.sample","title":"<code>sample(n: int) -&gt; List[Point]</code>","text":"<p>Return $\\(n\\)$ points sampled along the circular arc, including endpoints.</p> <p>Samples are taken at uniformly spaced parameter values $\\(t\\)$ in $\\([0,1]\\)$, so the angular spacing is uniform in parameter, not necessarily uniform in arc-length for non-constant curvature (not applicable here since curvature is constant). Requires $\\(n \\ge 2\\)$.</p> <p>Raises: - ValueError if $\\(n &lt; 2\\)$.</p> Source code in <code>src/multi_uav_planner/path_model.py</code> <pre><code>def sample(self, n: int) -&gt; List[Point]:\n    \"\"\"Return $$n$$ points sampled along the circular arc, including endpoints.\n\n    Samples are taken at uniformly spaced parameter values $$t$$ in\n    $$[0,1]$$, so the angular spacing is uniform in parameter, not\n    necessarily uniform in arc-length for non-constant curvature (not\n    applicable here since curvature is constant).\n    Requires $$n \\ge 2$$.\n\n    Raises:\n    - ValueError if $$n &lt; 2$$.\n    \"\"\"\n    if n &lt; 2:\n        raise ValueError(\"n must be &gt;= 2\")\n    return [self.point_at(i / (n - 1)) for i in range(n)]\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.CurveSegment.start_point","title":"<code>start_point() -&gt; Point</code>","text":"<p>Return the point at $\\(t = 0\\)$ (start of the arc).</p> Source code in <code>src/multi_uav_planner/path_model.py</code> <pre><code>def start_point(self) -&gt; Point:\n    \"\"\"Return the point at $$t = 0$$ (start of the arc).\"\"\"\n    return self.point_at(0.0)\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.Event","title":"<code>Event(time: float, kind: EventType, id: int, payload: Payload)</code>  <code>dataclass</code>","text":"<p>A scheduled event in the simulation or planner timeline.</p> <p>Ordering: - Events are ordered by their $\\(time\\)$ field so they can be stored in   a priority queue or list and processed chronologically.</p> <p>Fields: - time: trigger time (float, seconds). - kind: an EventType value. - id: user-defined integer id for the event (for bookkeeping). - payload: additional data whose type depends on $\\(kind\\)$. The payload   is excluded from ordering comparisons.</p> <p>Post-initialization checks: - For $$    ext{EventType.NEW_TASK}$$, payload must be a non-empty $\\(List[Task]\\)$. - For $$    ext{EventType.UAV_DAMAGE}$$, payload must be an $\\(int\\)$ representing the UAV id.</p>"},{"location":"api/multi_uav_planner/#multi_uav_planner.Event.should_trigger","title":"<code>should_trigger(world_time: float) -&gt; bool</code>","text":"<p>Return True if the event should trigger at or before the given world_time.</p> <p>This simple check allows event processing loops to pop events in time order and decide whether they are ready to fire.</p> Source code in <code>src/multi_uav_planner/world_models.py</code> <pre><code>def should_trigger(self, world_time: float) -&gt; bool:\n    \"\"\"\n    Return True if the event should trigger at or before the given world_time.\n\n    This simple check allows event processing loops to pop events in time\n    order and decide whether they are ready to fire.\n    \"\"\"\n    return world_time &gt;= self.time\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.EventType","title":"<code>EventType</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Event kind enumeration used for discrete simulation scheduling. - UAV_DAMAGE: payload is a UAV id (int) indicating the UAV becomes damaged. - NEW_TASK: payload is a non-empty List[Task] which should be added to the world.</p>"},{"location":"api/multi_uav_planner/#multi_uav_planner.LineSegment","title":"<code>LineSegment(start: Point, end: Point)</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Segment</code></p> <p>A straight line segment between two points.</p> <p>Attributes: - start: starting point as (x, y). - end: ending point as (x, y).</p> <p>Semantics: - length() returns the Euclidean distance between start and end. - point_at(t) returns the linear interpolation at normalized parameter   $\\(t \\in [0,1]\\)$ such that:   $$        ext{point_at}(0) =     ext{start}, \\quad       ext{point_at}(1) =     ext{end}.$$ - sample(n) returns $\\(n\\)$ evenly spaced points along the segment,   including endpoints; requires $\\(n \\ge 2\\)$.</p>"},{"location":"api/multi_uav_planner/#multi_uav_planner.LineSegment.end_point","title":"<code>end_point() -&gt; Point</code>","text":"<p>Return the end point of the segment.</p> Source code in <code>src/multi_uav_planner/path_model.py</code> <pre><code>def end_point(self) -&gt; Point:\n    \"\"\"Return the end point of the segment.\"\"\"\n    return self.end\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.LineSegment.point_at","title":"<code>point_at(t: float) -&gt; Point</code>","text":"<p>Return the point at normalized parameter $\\(t \\in [0,1]\\)$.</p> <pre><code>    Uses linear interpolation:\n    $$x = x_0 + t (x_1 - x_0), \\quad y = y_0 + t (y_1 - y_0).$$\n\n    Raises:\n    - ValueError if $$t\n</code></pre> <p>otin [0,1]$$.</p> Source code in <code>src/multi_uav_planner/path_model.py</code> <pre><code>def point_at(self, t: float) -&gt; Point:\n    \"\"\"Return the point at normalized parameter $$t \\in [0,1]$$.\n\n    Uses linear interpolation:\n    $$x = x_0 + t (x_1 - x_0), \\quad y = y_0 + t (y_1 - y_0).$$\n\n    Raises:\n    - ValueError if $$t \\notin [0,1]$$.\n    \"\"\"\n    if not 0.0 &lt;= t &lt;= 1.0:\n        raise ValueError(\"t must be in [0,1]\")\n    x = self.start[0] + t * (self.end[0] - self.start[0])\n    y = self.start[1] + t * (self.end[1] - self.start[1])\n    return (x, y)\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.LineSegment.sample","title":"<code>sample(n: int) -&gt; List[Point]</code>","text":"<p>Return $\\(n\\)$ points sampled uniformly along the segment.</p> <p>The returned list contains the start and end points and requires $\\(n \\ge 2\\)$ to include both endpoints.</p> <p>Raises: - ValueError if $\\(n &lt; 2\\)$.</p> Source code in <code>src/multi_uav_planner/path_model.py</code> <pre><code>def sample(self, n: int) -&gt; List[Point]:\n    \"\"\"Return $$n$$ points sampled uniformly along the segment.\n\n    The returned list contains the start and end points and requires\n    $$n \\ge 2$$ to include both endpoints.\n\n    Raises:\n    - ValueError if $$n &lt; 2$$.\n    \"\"\"\n    if n &lt; 2:\n        raise ValueError(\"n must be &gt;= 2\")\n    return [self.point_at(i / (n - 1)) for i in range(n)]\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.LineSegment.start_point","title":"<code>start_point() -&gt; Point</code>","text":"<p>Return the start point of the segment.</p> Source code in <code>src/multi_uav_planner/path_model.py</code> <pre><code>def start_point(self) -&gt; Point:\n    \"\"\"Return the start point of the segment.\"\"\"\n    return self.start\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.LineTask","title":"<code>LineTask(id: int, position: Tuple[float, float], state: Literal[0, 1, 2] = 0, heading_enforcement: bool = False, heading: Optional[float] = None, worked_by_uav: Optional[int] = None, length: float = 10.0)</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Task</code></p> <p>A line-type task that indicates the UAV should traverse a short line segment centered at the task position. Typical fields: - length: length of the line in meters (default: $\\(10.0\\)$).</p> <p>Interpretation: - The task position can be considered the midpoint or an endpoint;   specific geometric handling is the responsibility of the planner.</p>"},{"location":"api/multi_uav_planner/#multi_uav_planner.Path","title":"<code>Path(segments: List[Segment])</code>  <code>dataclass</code>","text":"<p>A sequence of segments forming a continuous path.</p> <p>Attributes: - segments: ordered list of Segment instances.</p> <p>Methods: - length(): total length obtained by summing segment lengths. - sample(samples_per_segment): sample each segment with the given   number of samples and concatenate results. To avoid duplicate points   at segment boundaries the first point of each subsequent segment is   omitted (since it equals the previous segment's last point).</p> <p>Sampling details: - Each segment is sampled with exactly $$   ext{samples_per_segment}$$   points (requires $\\(\\ge 2\\)$). - The returned list length will be:   $$        ext{len} = N \\cdot S - (N - 1)$$ where $\\(N\\)$ is the number of   segments and $\\(S\\)$ is $$  ext{samples_per_segment}$$ because junction   points are deduplicated.</p>"},{"location":"api/multi_uav_planner/#multi_uav_planner.Path.length","title":"<code>length() -&gt; float</code>","text":"<p>Return the total length of the path (sum of segment lengths).</p> Source code in <code>src/multi_uav_planner/path_model.py</code> <pre><code>def length(self) -&gt; float:\n    \"\"\"Return the total length of the path (sum of segment lengths).\"\"\"\n    return sum(s.length() for s in self.segments)\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.Path.sample","title":"<code>sample(samples_per_segment: int) -&gt; List[Point]</code>","text":"<p>Sample each segment and concatenate results, removing duplicate junctions.</p> <p>Parameters: - samples_per_segment: integer $\\(S \\ge 2\\)$, number of samples per segment.</p> <p>Returns: - List[Point]: concatenated sampled points for the whole path.</p> <p>Behavior: - For segment index $\\(i &gt; 0\\)$ the first sampled point of that segment   is dropped to avoid duplicating the shared endpoint with the   previous segment.</p> Source code in <code>src/multi_uav_planner/path_model.py</code> <pre><code>def sample(self, samples_per_segment: int) -&gt; List[Point]:\n    \"\"\"Sample each segment and concatenate results, removing duplicate junctions.\n\n    Parameters:\n    - samples_per_segment: integer $$S \\ge 2$$, number of samples per segment.\n\n    Returns:\n    - List[Point]: concatenated sampled points for the whole path.\n\n    Behavior:\n    - For segment index $$i &gt; 0$$ the first sampled point of that segment\n      is dropped to avoid duplicating the shared endpoint with the\n      previous segment.\n    \"\"\"\n    pts: List[Point] = []\n    for i, seg in enumerate(self.segments):\n        pts_seg = seg.sample(samples_per_segment)\n        if i &gt; 0:\n            # drop the first point to avoid duplicating the junction\n            # (the first point of seg equals the last point of previous seg)\n            pts_seg = pts_seg[1:]\n        pts.extend(pts_seg)\n    return pts\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.PointTask","title":"<code>PointTask(id: int, position: Tuple[float, float], state: Literal[0, 1, 2] = 0, heading_enforcement: bool = False, heading: Optional[float] = None, worked_by_uav: Optional[int] = None)</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Task</code></p> <p>A task located at a single point. No additional fields beyond Task. Use for simple point-inspection or waypoint-style tasks.</p>"},{"location":"api/multi_uav_planner/#multi_uav_planner.RunLog","title":"<code>RunLog(snapshots: List[Snapshot] = list(), stages: Tuple[str, ...] = ('init', 'triggering_events', 'assignment', 'after_move', 'end_tick (post_coverage)', 'planned_return'))</code>  <code>dataclass</code>","text":"<p>Collect time-indexed snapshots during a simulation run.</p> <p>Use the <code>hook()</code> method to obtain a callable suitable for <code>simulate_mission(on_step=...)</code> which will append snapshots for the stages listed in <code>stages</code>.</p> <p>Attributes: - snapshots: list of Snapshot objects (in chronological order). - stages: tuple of stage tags accepted by the hook (default set matches simulate_mission tags).</p>"},{"location":"api/multi_uav_planner/#multi_uav_planner.RunLog.hook","title":"<code>hook() -&gt; Callable[[World, str], None]</code>","text":"<p>Return an <code>on_step(world, stage)</code> callback that appends snapshots.</p> <p>The callback copies current sets and per-UAV fields so that the RunLog contains stable historical data (not references into mutable objects).</p> Source code in <code>src/multi_uav_planner/post_processing.py</code> <pre><code>def hook(self) -&gt; Callable[[World, str], None]:\n    \"\"\"Return an `on_step(world, stage)` callback that appends snapshots.\n\n    The callback copies current sets and per-UAV fields so that the RunLog\n    contains stable historical data (not references into mutable objects).\n    \"\"\"\n    def on_step(world, stage: str):\n        if stage not in self.stages:\n            return\n        snap = Snapshot(\n            time=world.time,\n            unassigned=sorted(world.unassigned),\n            assigned=sorted(world.assigned),\n            completed=sorted(world.completed),\n            uav_positions={uid: u.position for uid, u in world.uavs.items()},\n            uav_states={uid: u.state for uid, u in world.uavs.items()},\n            uav_range={uid: u.current_range for uid, u in world.uavs.items()},\n        )\n        self.snapshots.append(snap)\n    return on_step\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.RunLog.to_json","title":"<code>to_json() -&gt; Dict[str, Any]</code>","text":"<p>Convert the collected snapshots into a JSON-serializable dict.</p> Source code in <code>src/multi_uav_planner/post_processing.py</code> <pre><code>def to_json(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert the collected snapshots into a JSON-serializable dict.\"\"\"\n    return {\n        \"snapshots\": [\n            {\n                \"time\": s.time,\n                \"unassigned\": s.unassigned,\n                \"assigned\": s.assigned,\n                \"completed\": s.completed,\n                \"uav_positions\": s.uav_positions,\n                \"uav_states\": s.uav_states,\n                \"uav_range\": s.uav_range,\n            } for s in self.snapshots\n        ]\n    }\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.Scenario","title":"<code>Scenario(config: ScenarioConfig, tasks: List[Task], uavs: List[UAV], base: Tuple[float, float, float], events: List[Event] = list(), alg_type: AlgorithmType = AlgorithmType.PRBDD)</code>  <code>dataclass</code>","text":"<p>Container holding the result of scenario generation.</p> <p>Attributes: - $\\(config\\)$: the ScenarioConfig used to produce this scenario. - $\\(tasks\\)$: list of Task objects created. - $\\(uavs\\)$: list of UAV objects created and initially located at the base. - $\\(base\\)$: base pose $\\((x,y,heading)\\)$ used to initialize UAVs. - $\\(events\\)$: sorted list of Event objects (may be empty). - $\\(alg\\_type\\)$: chosen AlgorithmType for later use by planners.</p>"},{"location":"api/multi_uav_planner/#multi_uav_planner.ScenarioConfig","title":"<code>ScenarioConfig(base: Tuple[float, float, float] = (0.0, 0.0, 0.0), area_width: float = 2500.0, area_height: float = 2500.0, n_uavs: int = 4, n_tasks: int = 20, max_time: float = 1000000.0, p_point: float = 0.6, p_line: float = 0.2, p_circle: float = 0.1, p_area: float = 0.1, uav_speed: float = 17.5, turn_radius: float = 80.0, total_range: float = 0.0, max_range: float = 10000.0, tolerances: Tolerances = Tolerances(), alg_type: AlgorithmType = AlgorithmType.PRBDD, scenario_type: ScenarioType = ScenarioType.NONE, n_new_task: int = 0, n_damage: int = 0, ts_new_task: float = 0.0, tf_new_task: float = 0.0, ts_damage: float = 0.0, tf_damage: float = 0.0, seed: int = 0)</code>  <code>dataclass</code>","text":"<p>Configuration options controlling random scenario generation.</p> <p>Key fields: - $\\(base\\)$: base pose as $\\((x, y, heading)\\)$ (heading in radians). - $\\(area\\_width\\)$, $\\(area\\_height\\)$: sampling rectangle size for task positions. - $\\(n\\_uavs\\)$, $\\(n\\_tasks\\)$: numbers of initial UAVs and tasks. - Task-type probabilities $\\(p\\_point\\)$, $\\(p\\_line\\)$, $\\(p\\_circle\\)$, $\\(p\\_area\\)$ sum to 1.0   (used by the random sampler to choose task kinds). - UAV dynamics: $\\(uav\\_speed\\)$, $\\(turn\\_radius\\)$, $\\(total\\_range\\)$, $\\(max\\_range\\)$. - Tolerances: defaults are provided and are propagated to the World on init. - Scenario dynamics: $\\(scenario\\_type\\)$ determines whether to create delayed   new-task or damage events; counts and time windows control event creation. - $\\(seed\\)$: RNG seed for reproducibility.</p>"},{"location":"api/multi_uav_planner/#multi_uav_planner.ScenarioType","title":"<code>ScenarioType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Kinds of dynamic scenario events supported.</p>"},{"location":"api/multi_uav_planner/#multi_uav_planner.Segment","title":"<code>Segment()</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract interface for a path segment.</p> <p>A Segment represents a contiguous piece of a geometric path. Concrete implementations must provide: - length(): length of the segment (non-negative float). - sample(n): an ordered list of $\\(n\\)$ points sampled along the segment,   including both endpoints. - start_point() and end_point(): coordinates of the segment endpoints.</p> <p>Implementations should accept the normalized parameter $\\(t \\in [0,1]\\)$ for point evaluation (if they expose such a method).</p>"},{"location":"api/multi_uav_planner/#multi_uav_planner.Snapshot","title":"<code>Snapshot(time: float, unassigned: List[int], assigned: List[int], completed: List[int], uav_positions: Dict[int, Tuple[float, float, float]], uav_states: Dict[int, int], uav_range: Dict[int, float])</code>  <code>dataclass</code>","text":"<p>Immutable data snapshot captured at a simulation stage.</p> <p>Fields: - time: simulation time for the snapshot. - unassigned, assigned, completed: sorted lists of task ids (copied at capture time). - uav_positions: map uav_id -&gt; (x, y, heading). - uav_states: map uav_id -&gt; state code (0 idle, 1 transit, 2 busy, 3 damaged). - uav_range: map uav_id -&gt; cumulative executed distance (meters) at snapshot time.</p>"},{"location":"api/multi_uav_planner/#multi_uav_planner.Task","title":"<code>Task(id: int, position: Tuple[float, float], state: Literal[0, 1, 2] = 0, heading_enforcement: bool = False, heading: Optional[float] = None, worked_by_uav: Optional[int] = None)</code>  <code>dataclass</code>","text":"<p>Base class for a task (work item) to be performed by a UAV.</p> <p>Common fields: - id: unique integer identifier for the task. - position: 2D coordinates $\\((x, y)\\)$ representing the task location. - state: task lifecycle state with values:     - $\\(0\\)$: unassigned     - $\\(1\\)$: assigned     - $\\(2\\)$: completed   The type is declared as a Literal for clarity. - heading_enforcement: if True, the task requires the UAV to arrive   with a specific heading; otherwise arrival heading is unconstrained. - heading: optional heading in radians that is meaningful only when   $\\(heading\\_enforcement\\)$ is True. - worked_by_uav: optional id of the UAV currently assigned or working the task.</p> <p>Note: - This class carries only lightweight metadata; task execution details   (e.g., how to traverse an AreaTask) are handled elsewhere.</p>"},{"location":"api/multi_uav_planner/#multi_uav_planner.TaskClusterResult","title":"<code>TaskClusterResult(clusters: Dict[int, List[Task]], centers: np.ndarray, task_to_cluster: Dict[int, int])</code>  <code>dataclass</code>","text":"<p>Result container for K-means task clustering.</p> <p>Attributes:</p> Name Type Description <code>clusters</code> <code>Dict[int, List[Task]]</code> <p>Mapping from cluster index -&gt; list of Task objects assigned to that cluster. Keys are integers in $\\([0, K-1]\\)$.</p> <code>centers</code> <code>ndarray</code> <p>Numpy array of shape $\\((K, 2)\\)$ containing cluster center coordinates $\\((x, y)\\)$ for each cluster index.</p> <code>task_to_cluster</code> <code>Dict[int, int]</code> <p>Mapping from task id (int) to the assigned cluster index.</p>"},{"location":"api/multi_uav_planner/#multi_uav_planner.TimeRegistry","title":"<code>TimeRegistry(wall: Dict[str, float] = dict(), cpu: Dict[str, float] = dict(), calls: Dict[str, int] = dict())</code>  <code>dataclass</code>","text":"<p>Collect and accumulate timing statistics across labeled operations.</p> <p>Use-case: register timings from many calls to the same labeled operation and later query aggregated totals and averages.</p> <p>Stored fields: - wall: map label -&gt; total wall-clock seconds. - cpu: map label -&gt; total CPU seconds. - calls: map label -&gt; number of times the label was recorded.</p> <p>Methods: - add(label, wall, cpu): add a single timing record. - summary(): return a dict keyed by label with aggregated totals and averages.</p>"},{"location":"api/multi_uav_planner/#multi_uav_planner.TimeRegistry.add","title":"<code>add(label: str, wall: float, cpu: float)</code>","text":"<p>Accumulate one timing measurement for the given label.</p> Source code in <code>src/multi_uav_planner/post_processing.py</code> <pre><code>def add(self, label: str, wall: float, cpu: float):\n    \"\"\"Accumulate one timing measurement for the given label.\"\"\"\n    self.wall[label] = self.wall.get(label, 0.0) + wall\n    self.cpu[label] = self.cpu.get(label, 0.0) + cpu\n    self.calls[label] = self.calls.get(label, 0) + 1\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.TimeRegistry.summary","title":"<code>summary() -&gt; Dict[str, Dict[str, float]]</code>","text":"<p>Return per-label aggregated stats including totals and averages.</p> <p>For each label the returned dict contains: - wall_total, cpu_total, calls, wall_avg, cpu_avg</p> Source code in <code>src/multi_uav_planner/post_processing.py</code> <pre><code>def summary(self) -&gt; Dict[str, Dict[str, float]]:\n    \"\"\"Return per-label aggregated stats including totals and averages.\n\n    For each label the returned dict contains:\n    - wall_total, cpu_total, calls, wall_avg, cpu_avg\n    \"\"\"\n    out = {}\n    for k in sorted(self.wall.keys()):\n        n = self.calls.get(k, 1)\n        out[k] = {\n            \"wall_total\": self.wall[k],\n            \"cpu_total\": self.cpu[k],\n            \"calls\": n,\n            \"wall_avg\": self.wall[k] / n,\n            \"cpu_avg\": self.cpu[k] / n,\n        }\n    return out\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.Timer","title":"<code>Timer(label: str = 'block')</code>  <code>dataclass</code>","text":"<p>Context manager that measures wall-clock and CPU time for a code block.</p> Usage <p>with Timer(\"label\") as t:...  # code to profile print(t.elapsed_wall, t.elapsed_cpu)</p> <p>Attributes: - label: user-supplied name to identify the timed block. - start_wall: wall-clock timestamp recorded on entry (perf_counter). - start_cpu: process CPU time recorded on entry (process_time). - elapsed_wall: wall-clock duration on exit (seconds). - elapsed_cpu: CPU time duration on exit (seconds).</p>"},{"location":"api/multi_uav_planner/#multi_uav_planner.Tolerances","title":"<code>Tolerances(pos: float = 0.001, ang: float = 0.001, time: float = 1e-06)</code>  <code>dataclass</code>","text":"<p>Numeric tolerances used across the planner.</p> <p>Attributes: - pos: position tolerance in meters (default: $\\(1\\mathrm{e}{-3}\\)$). - ang: angular tolerance in radians (default: $\\(1\\mathrm{e}{-3}\\)$). - time: time epsilon in seconds (default: $\\(1\\mathrm{e}{-6}\\)$).</p> <p>Use an instance of this class to centralize tolerance choices so that assertions and proximity checks remain consistent across modules.</p>"},{"location":"api/multi_uav_planner/#multi_uav_planner.UAV","title":"<code>UAV(id: int, position: Tuple[float, float, float] = (0.0, 0.0, 0.0), speed: float = 17.5, turn_radius: float = 80.0, state: Literal[0, 1, 2, 3] = 0, cluster: Optional[Set[int]] = set(), cluster_CoG: Optional[Tuple[float, float]] = None, current_task: Optional[int] = None, assigned_path: Optional[Path] = None, current_range: float = 0.0, max_range: float = 10000.0)</code>  <code>dataclass</code>","text":"<p>Represents the state and capabilities of a single UAV.</p> <p>Fields: - id: integer UAV identifier. - position: current pose as $\\((x, y, heading)\\)$; heading in radians. - speed: nominal cruise speed in meters per second. - turn_radius: minimum turning radius in meters (used for path generation). - state: integer UAV status:     - $\\(0\\)$: idle     - $\\(1\\)$: in-transit (moving to a target)     - $\\(2\\)$: busy (executing a task)     - $\\(3\\)$: damaged/unavailable - cluster: optional set of assigned task ids (useful for clustering-based planners). - cluster_CoG: optional center-of-gravity coordinates for the cluster. - current_task: optional id of the task currently being executed. - assigned_path: optional Path instance representing planned route. - current_range: current remaining range in meters. - max_range: maximum mission range in meters.</p> <p>Remarks: - Many fields are optional so the planner can annotate UAVs gradually   (e.g., assign a path only when planning is completed).</p>"},{"location":"api/multi_uav_planner/#multi_uav_planner.World","title":"<code>World(tasks: Dict[int, Task], uavs: Dict[int, UAV], base: Tuple[float, float, float] = (0.0, 0.0, 0.0), time: float = 0.0, events: List[Event] = list(), events_cursor: int = 0, unassigned: Set[int] = set(), assigned: Set[int] = set(), completed: Set[int] = set(), idle_uavs: Set[int] = set(), transit_uavs: Set[int] = set(), busy_uavs: Set[int] = set(), damaged_uavs: Set[int] = set(), tols: Tolerances = Tolerances())</code>  <code>dataclass</code>","text":"<p>Global container holding the planner simulation state.</p> <p>Responsibilities: - Maintain dictionaries of tasks and UAVs keyed by id. - Track base location and global time. - Hold pending events and a cursor for sequential event processing. - Maintain partitions of task and UAV id sets (unassigned/assigned/completed,   idle/transit/busy/damaged) to enable fast membership checks.</p> <p>Fields: - tasks: Dict[id, Task] containing all task objects in the world. - uavs: Dict[id, UAV] containing UAV state objects. - base: base pose as $\\((x, y, heading)\\)$ (heading used when returning to base). - time: current simulation/planner time (float seconds). - events: chronological list of scheduled Event objects. - events_cursor: index used when iterating events incrementally. - unassigned/assigned/completed: sets partitioning task ids. - idle_uavs/transit_uavs/busy_uavs/damaged_uavs: sets partitioning UAV ids. - tols: Tolerances instance controlling numeric comparisons.</p>"},{"location":"api/multi_uav_planner/#multi_uav_planner.World.at_base","title":"<code>at_base(p_tol: Optional[float] = None, a_tol: Optional[float] = None) -&gt; bool</code>","text":"<p>Return True if all non-damaged UAVs are within positional and (optionally) angular tolerance of the base.</p> <ul> <li>$\\(p\\_tol\\)$: optional override for the position tolerance (meters).             If None, uses $$    ext{tols.pos}$$.</li> <li>$\\(a\\_tol\\)$: optional override for angular tolerance (radians).             If None, uses $$    ext{tols.ang}$$.</li> </ul> <p>Notes: - Damaged UAVs (state == $\\(3\\)\\() are ignored in this check. - The angular comparison is present but commented out by default. The   commented code computes the minimal signed angular difference using   a standard wrap-to-\\)\\([-\\pi,\\pi]\\)$ formula:   $$     \\left| \big( (h - bh + \\pi) \bmod 2\\pi \big) - \\pi  ight|   $$   which yields the smallest absolute angular difference between   UAV heading $\\(h\\)$ and base heading $\\(bh\\)$. Uncomment those lines   if heading alignment to base should be enforced.</p> Source code in <code>src/multi_uav_planner/world_models.py</code> <pre><code>    def at_base(self, p_tol: Optional[float] = None, a_tol: Optional[float] = None) -&gt; bool:\n        \"\"\"\n        Return True if all non-damaged UAVs are within positional and (optionally)\n        angular tolerance of the base.\n\n        Parameters:\n        - $$p\\_tol$$: optional override for the position tolerance (meters).\n                    If None, uses $$\\text{tols.pos}$$.\n        - $$a\\_tol$$: optional override for angular tolerance (radians).\n                    If None, uses $$\\text{tols.ang}$$.\n\n        Notes:\n        - Damaged UAVs (state == $$3$$) are ignored in this check.\n        - The angular comparison is present but commented out by default. The\n          commented code computes the minimal signed angular difference using\n          a standard wrap-to-$$[-\\pi,\\pi]$$ formula:\n          $$\n            \\left| \\big( (h - bh + \\pi) \\bmod 2\\pi \\big) - \\pi \\right|\n          $$\n          which yields the smallest absolute angular difference between\n          UAV heading $$h$$ and base heading $$bh$$. Uncomment those lines\n          if heading alignment to base should be enforced.\n        \"\"\"\n        p_tol = self.tols.pos if p_tol is None else p_tol\n        a_tol = self.tols.ang if a_tol is None else a_tol\n\n        bx,by,bh = self.base\n        for u in self.uavs.values():\n            # Skip damaged UAVs when determining whether the fleet is at base.\n            if u.state == 3:\n                continue\n            x,y,h = u.position\n            # Positional check: ensure both x and y are within the tolerance.\n            if abs(x-bx)&gt;p_tol or abs(y-by)&gt;p_tol:\n                return False\n            # Angular check (disabled by default): use modulo arithmetic to\n            # compute the smallest absolute angular difference between the UAV\n            # heading and the base heading. The formula below maps the raw\n            # difference into $$[-\\pi,\\pi]$$ and takes the absolute value.\n            # Uncomment to enable heading verification.\n#            if abs((h-bh + pi)%(2*pi)-pi)&gt;a_tol:\n#                return False\n        return True\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.World.done","title":"<code>done() -&gt; bool</code>","text":"<p>Return True if there are no remaining tasks to assign or complete.</p> <p>The world is considered finished when both the unassigned and assigned task sets are empty (completed tasks may remain in the completed set).</p> Source code in <code>src/multi_uav_planner/world_models.py</code> <pre><code>def done(self) -&gt; bool:\n    \"\"\"\n    Return True if there are no remaining tasks to assign or complete.\n\n    The world is considered finished when both the unassigned and assigned\n    task sets are empty (completed tasks may remain in the completed set).\n    \"\"\"\n    return not self.unassigned and not self.assigned\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.World.is_initialized","title":"<code>is_initialized() -&gt; bool</code>","text":"<p>Sanity-check that the World has been initialized consistently.</p> <p>Checks performed: - If $\\(time &gt; 0\\)$ we assume initialization has happened (early-exit). - Both tasks and uavs dictionaries are non-empty. - Base pose is a 3-tuple. - Task id sets form a partition of the keys in tasks. - UAV id sets form a partition of the keys in uavs and are disjoint. - No overlapping ids across partitions.</p> <p>Returns True if all checks pass, False otherwise.</p> Source code in <code>src/multi_uav_planner/world_models.py</code> <pre><code>def is_initialized(self) -&gt; bool:\n    \"\"\"\n    Sanity-check that the World has been initialized consistently.\n\n    Checks performed:\n    - If $$time &gt; 0$$ we assume initialization has happened (early-exit).\n    - Both tasks and uavs dictionaries are non-empty.\n    - Base pose is a 3-tuple.\n    - Task id sets form a partition of the keys in tasks.\n    - UAV id sets form a partition of the keys in uavs and are disjoint.\n    - No overlapping ids across partitions.\n\n    Returns True if all checks pass, False otherwise.\n    \"\"\"\n    # If time has advanced, we treat the world as already initialized.\n    if self.time &gt; 0: \n        return True\n\n    # tasks and uavs must be present for a meaningful simulation.\n    if not self.tasks or not self.uavs:\n        return False\n\n    # Base must be a 3-tuple: (x, y, heading)\n    if not (isinstance(self.base, tuple) and len(self.base) == 3):\n        return False\n\n    task_ids = set(self.tasks.keys())\n    # Tasks partition check:\n    # Ensure the union of task sets equals the set of declared task ids.\n    if (self.unassigned | self.assigned | self.completed) != task_ids:\n        return False\n    # Ensure pairwise disjointness of task partitions:\n    if (self.unassigned &amp; self.assigned) or (self.unassigned &amp; self.completed) or (self.assigned &amp; self.completed):\n        return False\n\n    uav_ids  = set(self.uavs.keys())\n    # UAVs partition check: union should equal declared UAV ids\n    if (self.idle_uavs | self.transit_uavs | self.busy_uavs | self.damaged_uavs) != uav_ids:\n        return False\n    # Pairwise disjointness checks for UAV partitions:\n    if (self.idle_uavs &amp; self.transit_uavs) or (self.idle_uavs &amp; self.busy_uavs) or (self.transit_uavs &amp; self.busy_uavs) or (self.damaged_uavs &amp; (self.idle_uavs | self.transit_uavs | self.busy_uavs)):\n        return False\n\n    return True\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.aggregate_metrics","title":"<code>aggregate_metrics(world, runlog: RunLog) -&gt; Dict[str, Any]</code>","text":"<p>Convenience aggregator that bundles several key post-run metrics.</p> Source code in <code>src/multi_uav_planner/post_processing.py</code> <pre><code>def aggregate_metrics(world, runlog: RunLog) -&gt; Dict[str, Any]:\n    \"\"\"Convenience aggregator that bundles several key post-run metrics.\"\"\"\n    return {\n        \"world_summary\": summarize_world(world),\n        \"uav_distances\": compute_uav_distances(runlog),\n        \"uav_state_durations\": compute_uav_state_durations(runlog),\n        \"task_latencies\": compute_task_latencies(runlog, initial_time=0.0),\n    }\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.assign_clusters_to_uavs_by_proximity","title":"<code>assign_clusters_to_uavs_by_proximity(uavs: List[UAV], cluster_centers: np.ndarray) -&gt; Dict[int, int]</code>","text":"<p>Assign each cluster to a distinct UAV by approximate proximity.</p> <pre><code>This routine forms a cost matrix of squared Euclidean distances between\neach UAV position and each cluster center, then calls a greedy assignment\nroutine to produce a one-to-one mapping from clusters to UAVs.\n\nRequirements and behavior:\n- `cluster_centers` must be an array of shape $$(K, 2)$$.\n- The function currently expects $$K =      ext{len(uavs)}$$ (one cluster per UAV).\n  If the numbers differ a ValueError is raised.\n- Costs are squared Euclidean distances (no sqrt) so:\n  $$        ext{cost}_{i,j} = (x_{c_j} - x_{u_i})^2 + (y_{c_j} - y_{u_i})^2.$$\n- The greedy global assignment function `greedy_global_assign_int` is used to\n  select worker-task pairs (here UAV-cluster pairs) without reuse of UAVs\n  or clusters. The returned mapping is cluster_index -&gt; uav_id.\n\nArgs:\n    uavs: list of UAV objects; each `uav.position` is $$(x,y,heading)$$.\n    cluster_centers: numpy array of cluster centers shape $$(K,2)$$.\n\nReturns:\n    Dictionary mapping `cluster_index -&gt; uav.id`.\n\nRaises:\n    ValueError: if `cluster_centers` does not have shape $$(K,2)$$ or if\n                $$K\n</code></pre> <p>e       ext{len(uavs)}$$.</p> Source code in <code>src/multi_uav_planner/clustering.py</code> <pre><code>def assign_clusters_to_uavs_by_proximity(\n    uavs: List[UAV],\n    cluster_centers: np.ndarray,\n) -&gt; Dict[int, int]:\n    \"\"\"Assign each cluster to a distinct UAV by approximate proximity.\n\n    This routine forms a cost matrix of squared Euclidean distances between\n    each UAV position and each cluster center, then calls a greedy assignment\n    routine to produce a one-to-one mapping from clusters to UAVs.\n\n    Requirements and behavior:\n    - `cluster_centers` must be an array of shape $$(K, 2)$$.\n    - The function currently expects $$K = \\text{len(uavs)}$$ (one cluster per UAV).\n      If the numbers differ a ValueError is raised.\n    - Costs are squared Euclidean distances (no sqrt) so:\n      $$\\text{cost}_{i,j} = (x_{c_j} - x_{u_i})^2 + (y_{c_j} - y_{u_i})^2.$$\n    - The greedy global assignment function `greedy_global_assign_int` is used to\n      select worker-task pairs (here UAV-cluster pairs) without reuse of UAVs\n      or clusters. The returned mapping is cluster_index -&gt; uav_id.\n\n    Args:\n        uavs: list of UAV objects; each `uav.position` is $$(x,y,heading)$$.\n        cluster_centers: numpy array of cluster centers shape $$(K,2)$$.\n\n    Returns:\n        Dictionary mapping `cluster_index -&gt; uav.id`.\n\n    Raises:\n        ValueError: if `cluster_centers` does not have shape $$(K,2)$$ or if\n                    $$K \\ne \\text{len(uavs)}$$.\n    \"\"\"\n    cluster_centers = np.asarray(cluster_centers, dtype=float)\n    if cluster_centers.ndim != 2 or cluster_centers.shape[1] != 2:\n        raise ValueError(\"cluster_centers must have shape (K, 2)\")\n\n    K = cluster_centers.shape[0]\n    if K != len(uavs):\n        raise ValueError(\n            f\"Number of clusters ({K}) must equal number of UAVs ({len(uavs)}) \"\n            \"for this assignment rule.\"\n        )\n\n    # Build cost matrix: squared Euclidean distances between UAV i and cluster j\n    costs = np.zeros((K, K), dtype=float)\n    for i, uav in enumerate(uavs):\n        ux, uy, _ = uav.position  # heading ignored for clustering\n        for j in range(K):\n            cx, cy = cluster_centers[j]\n            dx = cx - ux\n            dy = cy - uy\n            costs[i, j] = dx * dx + dy * dy\n\n    # Greedy integer assignment returns a list `assignment` of length K where\n    # assignment[i] = j indicates UAV i -&gt; cluster j (or -1 if unassigned).\n    assignment = greedy_global_assign_int(costs)\n\n    # Convert assignment (indexed by UAV index) to mapping cluster_index -&gt; uav_id\n    cluster_to_uav: Dict[int, int] = {}\n    for i in range(K):\n        assigned_cluster = assignment[i]\n        if assigned_cluster is not None and assigned_cluster &gt;= 0:\n            # Map cluster index -&gt; UAV id\n            cluster_to_uav[assigned_cluster] = uavs[i].id\n    return cluster_to_uav\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.cluster_tasks","title":"<code>cluster_tasks(world: World) -&gt; Optional[Dict[int, Set[int]]]</code>","text":"<p>High-level clustering pipeline that assigns unassigned tasks to idle UAVs.</p> <p>Steps performed: 1. Collect unassigned Task objects from <code>world.unassigned</code>. 2. If there are no unassigned tasks or no idle UAVs, return None. 3. Choose $\\(K = \\min(\\#     ext{idle\\_uavs}, \\#     ext{unassigned\\_tasks})\\)$ clusters. 4. Run <code>cluster_tasks_kmeans</code> to partition tasks into $\\(K\\)$ clusters. 5. Map clusters to idle UAVs using <code>assign_clusters_to_uavs_by_proximity</code>. 6. For each assigned cluster <code>k -&gt; uid</code>, update:     - <code>world.uavs[uid].cluster</code> as the set of task ids in cluster <code>k</code>.     - <code>world.uavs[uid].cluster_CoG</code> as the cluster center coordinates (floats). 7. Return a dictionary mapping <code>uav_id -&gt; set(task_ids)</code> for the newly assigned clusters.</p> <p>Returns:</p> Type Description <code>Optional[Dict[int, Set[int]]]</code> <p>A mapping <code>uid -&gt; set(task_ids)</code> when clustering occurs, or None if no</p> <code>Optional[Dict[int, Set[int]]]</code> <p>clustering was performed (e.g., no idle UAVs or no unassigned tasks).</p> Source code in <code>src/multi_uav_planner/clustering.py</code> <pre><code>def cluster_tasks(world: World) -&gt; Optional[Dict[int, Set[int]]]:\n    \"\"\"High-level clustering pipeline that assigns unassigned tasks to idle UAVs.\n\n    Steps performed:\n    1. Collect unassigned Task objects from `world.unassigned`.\n    2. If there are no unassigned tasks or no idle UAVs, return None.\n    3. Choose $$K = \\min(\\#\\text{idle\\_uavs}, \\#\\text{unassigned\\_tasks})$$ clusters.\n    4. Run `cluster_tasks_kmeans` to partition tasks into $$K$$ clusters.\n    5. Map clusters to idle UAVs using `assign_clusters_to_uavs_by_proximity`.\n    6. For each assigned cluster `k -&gt; uid`, update:\n        - `world.uavs[uid].cluster` as the set of task ids in cluster `k`.\n        - `world.uavs[uid].cluster_CoG` as the cluster center coordinates (floats).\n    7. Return a dictionary mapping `uav_id -&gt; set(task_ids)` for the newly assigned clusters.\n\n    Returns:\n        A mapping `uid -&gt; set(task_ids)` when clustering occurs, or None if no\n        clustering was performed (e.g., no idle UAVs or no unassigned tasks).\n    \"\"\"\n    # Collect Task objects for unassigned task ids\n    unassigned_tasks = [world.tasks[tid] for tid in world.unassigned]\n    if not unassigned_tasks or not world.idle_uavs:\n        return None  # Nothing to cluster\n\n    result: Dict[int, Set[int]] = {}\n\n    # Choose number of clusters: at most the number of idle UAVs and the number of tasks\n    K = min(len(world.idle_uavs), len(unassigned_tasks))\n    clustering_result = cluster_tasks_kmeans(\n        unassigned_tasks,\n        n_clusters=K,\n        random_state=0,\n    )\n\n    # Map clusters to idle UAVs ordered arbitrarily as a list\n    idle_uavs_list = [world.uavs[uid] for uid in world.idle_uavs]\n    cluster_to_uav = assign_clusters_to_uavs_by_proximity(\n        idle_uavs_list,\n        clustering_result.centers,\n    )\n\n    # Update world.uavs for each assigned cluster\n    for k, uid in cluster_to_uav.items():\n        world.uavs[uid].cluster = {t.id for t in clustering_result.clusters[k]}\n        cx, cy = clustering_result.centers[k]\n        world.uavs[uid].cluster_CoG = (float(cx), float(cy))\n        result[uid] = world.uavs[uid].cluster\n\n    return result\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.cluster_tasks_kmeans","title":"<code>cluster_tasks_kmeans(tasks: List[Task], n_clusters: int, random_state: int = 42) -&gt; TaskClusterResult</code>","text":"<p>Cluster tasks into $\\(K\\)$ groups using K-means on their 2D positions.</p> <p>Parameters:</p> Name Type Description Default <code>tasks</code> <code>List[Task]</code> <p>list of Task objects (each must have a 2D <code>position</code>).</p> required <code>n_clusters</code> <code>int</code> <p>desired number of clusters $\\(K\\)$ (commonly equal to number of UAVs).</p> required <code>random_state</code> <code>int</code> <p>seed for KMeans initialization for reproducibility.</p> <code>42</code> <p>Returns:</p> Type Description <code>TaskClusterResult</code> <p>TaskClusterResult containing:</p> <code>TaskClusterResult</code> <ul> <li>clusters: dict mapping cluster index -&gt; List[Task]</li> </ul> <code>TaskClusterResult</code> <ul> <li>centers: $\\(K  imes 2\\)$ array with cluster centers</li> </ul> <code>TaskClusterResult</code> <ul> <li>task_to_cluster: mapping from task id -&gt; cluster index</li> </ul> <p>Raises:</p> Type Description <code>ValueError</code> <p>if <code>tasks</code> is empty, or if <code>n_clusters</code> is not in $\\([1, N]\\)$         where $\\(N\\)$ is the number of tasks.</p> Source code in <code>src/multi_uav_planner/clustering.py</code> <pre><code>def cluster_tasks_kmeans(\n    tasks: List[Task],\n    n_clusters: int,\n    random_state: int = 42,\n) -&gt; TaskClusterResult:\n    \"\"\"Cluster tasks into $$K$$ groups using K-means on their 2D positions.\n\n    Args:\n        tasks: list of Task objects (each must have a 2D `position`).\n        n_clusters: desired number of clusters $$K$$ (commonly equal to number of UAVs).\n        random_state: seed for KMeans initialization for reproducibility.\n\n    Returns:\n        TaskClusterResult containing:\n        - clusters: dict mapping cluster index -&gt; List[Task]\n        - centers: $$K \\times 2$$ array with cluster centers\n        - task_to_cluster: mapping from task id -&gt; cluster index\n\n    Raises:\n        ValueError: if `tasks` is empty, or if `n_clusters` is not in $$[1, N]$$\n                    where $$N$$ is the number of tasks.\n    \"\"\"\n    if not tasks:\n        raise ValueError(\"tasks list must be non-empty\")\n    if n_clusters &lt;= 0:\n        raise ValueError(\"n_clusters must be positive\")\n    if n_clusters &gt; len(tasks):\n        raise ValueError(\"n_clusters cannot exceed number of tasks\")\n\n    # Build data matrix for K-means: shape (N, 2)\n    X = _extract_task_positions(tasks)\n\n    kmeans = KMeans(\n        n_clusters=n_clusters,\n        n_init=10,\n        random_state=random_state,\n    )\n    labels = kmeans.fit_predict(X)\n    centers = kmeans.cluster_centers_\n\n    # Organize tasks by cluster label and construct id-&gt;cluster map\n    clusters: Dict[int, List[Task]] = {i: [] for i in range(n_clusters)}\n    task_to_cluster: Dict[int, int] = {}\n\n    for task, label in zip(tasks, labels):\n        label_int = int(label)\n        clusters[label_int].append(task)\n        task_to_cluster[task.id] = label_int\n\n    return TaskClusterResult(\n        clusters=clusters,\n        centers=centers,\n        task_to_cluster=task_to_cluster,\n    )\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.compute_cost","title":"<code>compute_cost(world: World, uav_ids: Iterable[int], task_ids: Iterable[int], use_dubins: bool)</code>","text":"<p>Construct a cost matrix for the specified UAV ids (rows) and task ids (cols).</p> Returns a tuple <ul> <li>$\\(C\\)$: list of lists representing the cost matrix (shape $\\(n    imes m\\)$).</li> <li>$\\(uav_ids_list\\)$: list mapping row index -&gt; uav_id.</li> <li>$\\(task_ids_list\\)$: list mapping column index -&gt; task_id.</li> <li>$\\(uav_index\\)$: dict mapping uav_id -&gt; row index.</li> <li>$\\(task_index\\)$: dict mapping task_id -&gt; column index.</li> </ul> <p>Cost semantics: - If $\\(use_dubins\\)$ is True the cost is the length of the Dubins-style path   returned by <code>plan_path_to_task(world, uid, (x_e, y_e,     heta_e))</code>. - Otherwise the cost is the Euclidean distance:   $$        ext{cost} = \\sqrt{(x_e - x_s)^2 + (y_e - y_s)^2}.$$</p> <p>Notes: - Returned matrix $\\(C\\)$ is a list-of-lists (row-major). The function does not   attempt to normalize or scale costs; callers should be aware of absolute scales.</p> Source code in <code>src/multi_uav_planner/assignment.py</code> <pre><code>def compute_cost(\n    world: World,\n    uav_ids: Iterable[int],\n    task_ids: Iterable[int],\n    use_dubins: bool,\n):\n    \"\"\"\n    Construct a cost matrix for the specified UAV ids (rows) and task ids (cols).\n\n    Returns a tuple:\n      - $$C$$: list of lists representing the cost matrix (shape $$n \\times m$$).\n      - $$uav_ids_list$$: list mapping row index -&gt; uav_id.\n      - $$task_ids_list$$: list mapping column index -&gt; task_id.\n      - $$uav_index$$: dict mapping uav_id -&gt; row index.\n      - $$task_index$$: dict mapping task_id -&gt; column index.\n\n    Cost semantics:\n    - If $$use_dubins$$ is True the cost is the length of the Dubins-style path\n      returned by `plan_path_to_task(world, uid, (x_e, y_e, \\theta_e))`.\n    - Otherwise the cost is the Euclidean distance:\n      $$\\text{cost} = \\sqrt{(x_e - x_s)^2 + (y_e - y_s)^2}.$$\n\n    Notes:\n    - Returned matrix $$C$$ is a list-of-lists (row-major). The function does not\n      attempt to normalize or scale costs; callers should be aware of absolute scales.\n    \"\"\"\n    uav_ids_list = list(uav_ids)\n    task_ids_list = list(task_ids)\n\n    uav_index = {uid: i for i, uid in enumerate(uav_ids_list)}\n    task_index = {tid: j for j, tid in enumerate(task_ids_list)}\n\n    n = len(uav_ids_list)\n    m = len(task_ids_list)\n\n    C = [[0.0 for _ in range(m)] for _ in range(n)]\n\n    for uid in uav_ids_list:\n        i = uav_index[uid]\n        for tid in task_ids_list:\n            j = task_index[tid]\n            if use_dubins:\n                # Use full path planner to compute a feasible/realistic cost (path length)\n                t = world.tasks[tid]\n                xe, ye = t.position\n                the = t.heading if t.heading_enforcement else None\n\n                p = plan_path_to_task(world, uid, (xe, ye, the))\n                C[i][j] = p.length()\n            else:\n                # Simple Euclidean distance (fast proxy cost)\n                xs, ys, _ = world.uavs[uid].position\n                xe, ye = world.tasks[tid].position\n                C[i][j] = math.hypot(xe - xs, ye - ys)\n\n    return C, uav_ids_list, task_ids_list, uav_index, task_index\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.compute_task_latencies","title":"<code>compute_task_latencies(runlog: RunLog, initial_time: float = 0.0) -&gt; Dict[int, Dict[str, float]]</code>","text":"<p>Compute per-task latency metrics using snapshots.</p> <p>For each task id, the returned dict contains:   - time_assigned: first timestamp the task appears in the <code>assigned</code> set.   - time_completed: first timestamp the task appears in the <code>completed</code> set.   - wait_to_assign = time_assigned - initial_time   - wait_to_complete = time_completed - initial_time</p> <p>Notes: - If a task never appears in <code>assigned</code> or <code>completed</code>, the corresponding value is NaN. - If NEW_TASK events occur mid-simulation, consider passing a task-specific   <code>initial_time</code> when interpreting waits.</p> Source code in <code>src/multi_uav_planner/post_processing.py</code> <pre><code>def compute_task_latencies(runlog: RunLog, initial_time: float = 0.0) -&gt; Dict[int, Dict[str, float]]:\n    \"\"\"\n    Compute per-task latency metrics using snapshots.\n\n    For each task id, the returned dict contains:\n      - time_assigned: first timestamp the task appears in the `assigned` set.\n      - time_completed: first timestamp the task appears in the `completed` set.\n      - wait_to_assign = time_assigned - initial_time\n      - wait_to_complete = time_completed - initial_time\n\n    Notes:\n    - If a task never appears in `assigned` or `completed`, the corresponding value is NaN.\n    - If NEW_TASK events occur mid-simulation, consider passing a task-specific\n      `initial_time` when interpreting waits.\n    \"\"\"\n    lat: Dict[int, Dict[str, float]] = {}\n    # Build first-appearance times\n    t_assigned: Dict[int, float] = {}\n    t_completed: Dict[int, float] = {}\n    for s in runlog.snapshots:\n        t = s.time\n        for tid in s.assigned:\n            t_assigned.setdefault(tid, t)\n        for tid in s.completed:\n            t_completed.setdefault(tid, t)\n    tids = set(t_assigned.keys()) | set(t_completed.keys())\n    for tid in tids:\n        ta = t_assigned.get(tid)\n        tc = t_completed.get(tid)\n        lat[tid] = {\n            \"time_assigned\": ta if ta is not None else float(\"nan\"),\n            \"time_completed\": tc if tc is not None else float(\"nan\"),\n            \"wait_to_assign\": (ta - initial_time) if ta is not None else float(\"nan\"),\n            \"wait_to_complete\": (tc - initial_time) if tc is not None else float(\"nan\"),\n        }\n    return lat\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.compute_time_series_metrics","title":"<code>compute_time_series_metrics(runlog: RunLog) -&gt; List[Dict[str, float]]</code>","text":"<p>Produce a list of per-snapshot aggregate metrics (time series).</p> <p>Each entry contains: - time - total_actual_distance: sum of all UAV executed distances at that snapshot - max_actual_distance: maximum per-UAV executed distance - unfinished_tasks: number of unassigned tasks</p> Source code in <code>src/multi_uav_planner/post_processing.py</code> <pre><code>def compute_time_series_metrics(runlog: RunLog) -&gt; List[Dict[str, float]]:\n    \"\"\"\n    Produce a list of per-snapshot aggregate metrics (time series).\n\n    Each entry contains:\n    - time\n    - total_actual_distance: sum of all UAV executed distances at that snapshot\n    - max_actual_distance: maximum per-UAV executed distance\n    - unfinished_tasks: number of unassigned tasks\n    \"\"\"\n    series = []\n    for s in runlog.snapshots:\n        distances = list(s.uav_range.values())\n        total = sum(distances)\n        max_dist = max(distances) if distances else 0.0\n        series.append({\n            \"time\": s.time,\n            \"total_actual_distance\": total,\n            \"max_actual_distance\": max_dist,\n            \"unfinished_tasks\": len(s.unassigned),\n        })\n    return series\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.compute_uav_distances","title":"<code>compute_uav_distances(runlog: RunLog) -&gt; Dict[int, float]</code>","text":"<p>Extract executed (actual) traveled distance per UAV from the latest snapshot.</p> <p>The function uses the last snapshot's <code>uav_range</code> which is expected to be a cumulative traveled distance measured during the simulation.</p> Source code in <code>src/multi_uav_planner/post_processing.py</code> <pre><code>def compute_uav_distances(runlog: RunLog) -&gt; Dict[int, float]:\n    \"\"\"Extract executed (actual) traveled distance per UAV from the latest snapshot.\n\n    The function uses the last snapshot's `uav_range` which is expected to be\n    a cumulative traveled distance measured during the simulation.\n    \"\"\"\n    dist = {}\n    if not runlog.snapshots:\n        return dist\n    last = runlog.snapshots[-1]\n    for uid, val in last.uav_range.items():\n        dist[uid] = float(val)\n    return dist\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.compute_uav_path_lengths","title":"<code>compute_uav_path_lengths(uav_paths: Dict[int, Path]) -&gt; Dict[int, float]</code>","text":"<p>Compute planned (pre-execution) path lengths for each UAV from Path objects.</p> <p>Returns a mapping uav_id -&gt; path.length().</p> Source code in <code>src/multi_uav_planner/post_processing.py</code> <pre><code>def compute_uav_path_lengths(uav_paths: Dict[int, Path]) -&gt; Dict[int, float]:\n    \"\"\"Compute planned (pre-execution) path lengths for each UAV from Path objects.\n\n    Returns a mapping uav_id -&gt; path.length().\n    \"\"\"\n    return {uav_id: path.length() for uav_id, path in uav_paths.items()}\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.compute_uav_state_durations","title":"<code>compute_uav_state_durations(runlog: RunLog) -&gt; Dict[int, Dict[int, float]]</code>","text":"<p>Compute per-UAV accumulated durations in each state (0 idle, 1 transit, 2 busy, 3 damaged).</p> <p>The algorithm: - Uses consecutive snapshots to obtain time intervals $\\(\\Delta t_i\\)$. - For each interval, it accumulates the duration into the state observed   at the interval start for each UAV.</p> <p>Returns: - dict: uav_id -&gt; {state_code -&gt; seconds}</p> Source code in <code>src/multi_uav_planner/post_processing.py</code> <pre><code>def compute_uav_state_durations(runlog: RunLog) -&gt; Dict[int, Dict[int, float]]:\n    \"\"\"Compute per-UAV accumulated durations in each state (0 idle, 1 transit, 2 busy, 3 damaged).\n\n    The algorithm:\n    - Uses consecutive snapshots to obtain time intervals $$\\Delta t_i$$.\n    - For each interval, it accumulates the duration into the state observed\n      at the interval start for each UAV.\n\n    Returns:\n    - dict: uav_id -&gt; {state_code -&gt; seconds}\n    \"\"\"\n    durations: Dict[int, Dict[int, float]] = {}\n    if len(runlog.snapshots) &lt; 2:\n        return durations\n    times = [s.time for s in runlog.snapshots]\n    dt = [times[i + 1] - times[i] for i in range(len(times) - 1)]\n    # initialize durations per UAV\n    for uid in runlog.snapshots[0].uav_states.keys():\n        durations[uid] = {0: 0.0, 1: 0.0, 2: 0.0, 3: 0.0}\n        for i in range(len(dt)):\n            st = runlog.snapshots[i].uav_states.get(uid, 0)\n            durations[uid][st] += dt[i]\n    return durations\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.cs_segments_shortest","title":"<code>cs_segments_shortest(start: Tuple[float, float, float], end: Tuple[float, float], radius: float) -&gt; Path</code>","text":"<p>Return the shortest feasible CS path among the two variants: $\\(LS\\)$ and $\\(RS\\)$.</p> <p>The function evaluates both $\\(\"LS\"\\)$ and $\\(\"RS\"\\)$ via cs_segments_single and returns the feasible one with minimal total length.</p> <p>Raises - ValueError if $\\(radius \\le 0\\)$. - ValueError if both $\\(LS\\)$ and $\\(RS\\)$ are infeasible (i.e., no tangent exists).</p> Source code in <code>src/multi_uav_planner/dubins.py</code> <pre><code>def cs_segments_shortest(\n    start: Tuple[float, float, float],\n    end: Tuple[float, float],\n    radius: float,\n) -&gt; Path:\n    \"\"\"\n    Return the shortest feasible CS path among the two variants: $$LS$$ and $$RS$$.\n\n    The function evaluates both $$\"LS\"$$ and $$\"RS\"$$ via cs_segments_single and\n    returns the feasible one with minimal total length.\n\n    Raises\n    - ValueError if $$radius \\le 0$$.\n    - ValueError if both $$LS$$ and $$RS$$ are infeasible (i.e., no tangent exists).\n    \"\"\"\n    if radius &lt;= 0.0:\n        raise ValueError(\"radius must be positive\")\n    if (start[0], start[1]) == end:\n        # degenerate: same position (no path required)\n        return Path([])\n    candidates = [cs_segments_single(start, end, radius, pt) for pt in (\"LS\", \"RS\")]\n    feasible = [p for p in candidates if p is not None]\n    if not feasible:\n        raise ValueError(\"No feasible CS-type Dubins path\")\n    return min(feasible, key=lambda p: p.length())\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.cs_segments_single","title":"<code>cs_segments_single(start: Tuple[float, float, float], end: Tuple[float, float], radius: float, path_type: PathType) -&gt; Optional[Path]</code>","text":"<p>Build a CS-type path composed of a single circular arc (C) followed by a straight line (S). The returned Path has the form [CurveSegment, LineSegment].</p> <p>The construction places a circle of radius $\\(R\\)$ tangent to the start configuration, then finds the tangency point to a straight line that reaches the target point.</p> <p>Parameters - $\\(start\\)$: $\\((x_0, y_0,   heta_0)\\)$ start configuration (position and heading, radians). - $\\(end\\)$: $\\((x_f, y_f)\\)$ goal position (heading at goal not used for CS). - $\\(radius\\)$: positive turning radius $\\(R &gt; 0\\)$. - $\\(path\\_type\\)$: either $\\(\"LS\"\\)$ (left-turn arc then straight) or $\\(\"RS\"\\)$   (right-turn arc then straight).</p> <p>Returns - A Path [arc, line] if a tangent straight-line exists. - $\\(None\\)$ if no tangent exists (i.e., the point is inside the circle of   tangency).</p> <p>Geometric summary and key formulas used: - The center of the start circle is obtained by offsetting the start   position laterally by $\\(\\pm       frac{\\pi}{2}\\)$ depending on left/right:   $$        heta_{center} =         heta_0 \\pm \frac{\\pi}{2}.$$   $\\(x_s = x_0 + R\\cos(      heta_{center}),\\quad y_s = y_0 + R\\sin( heta_{center}).\\)$ - Let $\\(d\\)$ be the distance from the circle center $\\((x_s,y_s)\\)$ to the   goal point $\\((x_f,y_f)\\)$. If $\\(d &lt; R\\)$ there is no external tangent,   so the CS path is infeasible. - The angle from the circle center to the goal is   $$        heta_{sf} = \\operatorname{atan2}(y_f-y_s,\\, x_f-x_s).$$ - For the right triangle between the center, tangency point, and goal:   $\\(\\sin(   heta_{mf}) = \frac{R}{d},\\quad   heta_{mf} = \u0007rcsin\\!\\left(\frac{R}{d} ight).\\)$ - The tangency angle on the circle (angle of the center-&gt;tangent point)   depends on path type; the code computes $$        heta_M$$ accordingly. - Arc sweep $\\(\\Delta        heta\\)$ (stored as $\\(d\\_theta\\)$) is normalized to the   appropriate signed interval in the implementation.</p> <p>Raises - ValueError if $\\(radius \\le 0\\)$.</p> Source code in <code>src/multi_uav_planner/dubins.py</code> <pre><code>def cs_segments_single(\n    start: Tuple[float, float, float],\n    end: Tuple[float, float],\n    radius: float,\n    path_type: PathType,\n) -&gt; Optional[Path]:\n    \"\"\"\n    Build a CS-type path composed of a single circular arc (C) followed by a\n    straight line (S). The returned Path has the form [CurveSegment, LineSegment].\n\n    The construction places a circle of radius $$R$$ tangent to the start\n    configuration, then finds the tangency point to a straight line that\n    reaches the target point.\n\n    Parameters\n    - $$start$$: $$(x_0, y_0, \\theta_0)$$ start configuration (position and heading, radians).\n    - $$end$$: $$(x_f, y_f)$$ goal position (heading at goal not used for CS).\n    - $$radius$$: positive turning radius $$R &gt; 0$$.\n    - $$path\\_type$$: either $$\"LS\"$$ (left-turn arc then straight) or $$\"RS\"$$\n      (right-turn arc then straight).\n\n    Returns\n    - A Path [arc, line] if a tangent straight-line exists.\n    - $$None$$ if no tangent exists (i.e., the point is inside the circle of\n      tangency).\n\n    Geometric summary and key formulas used:\n    - The center of the start circle is obtained by offsetting the start\n      position laterally by $$\\pm \\tfrac{\\pi}{2}$$ depending on left/right:\n      $$\\theta_{center} = \\theta_0 \\pm \\frac{\\pi}{2}.$$\n      $$x_s = x_0 + R\\cos(\\theta_{center}),\\quad y_s = y_0 + R\\sin(\\theta_{center}).$$\n    - Let $$d$$ be the distance from the circle center $$(x_s,y_s)$$ to the\n      goal point $$(x_f,y_f)$$. If $$d &lt; R$$ there is no external tangent,\n      so the CS path is infeasible.\n    - The angle from the circle center to the goal is\n      $$\\theta_{sf} = \\operatorname{atan2}(y_f-y_s,\\, x_f-x_s).$$\n    - For the right triangle between the center, tangency point, and goal:\n      $$\\sin(\\theta_{mf}) = \\frac{R}{d},\\quad \\theta_{mf} = \\arcsin\\!\\left(\\frac{R}{d}\\right).$$\n    - The tangency angle on the circle (angle of the center-&gt;tangent point)\n      depends on path type; the code computes $$\\theta_M$$ accordingly.\n    - Arc sweep $$\\Delta\\theta$$ (stored as $$d\\_theta$$) is normalized to the\n      appropriate signed interval in the implementation.\n\n    Raises\n    - ValueError if $$radius \\le 0$$.\n    \"\"\"\n    if radius &lt;= 0.0:\n        raise ValueError(\"radius must be positive\")\n\n    x0, y0, theta0 = start\n    xf, yf = end\n\n    # Center angle is start heading rotated left or right by 90 degrees:\n    # $$\\theta_{center} = \\theta_0 + (\\pi/2 \\text{ if 'LS' else } -\\pi/2)$$\n    theta_center = theta0 + (math.pi / 2.0 if path_type == \"LS\" else -math.pi / 2.0)\n\n    # Center coordinates of the start-turning circle:\n    # $$x_s = x_0 + R\\cos(\\theta_{center}), \\quad y_s = y_0 + R\\sin(\\theta_{center})$$\n    xs = x0 + radius * math.cos(theta_center)\n    ys = y0 + radius * math.sin(theta_center)\n\n    # --- 2. Angle $$\\theta_{SF}$$ and Euclidean distance $$d$$ from circle center to target ----\n    dx_sf = xf - xs\n    dy_sf = yf - ys\n    d = math.hypot(dx_sf, dy_sf)\n\n    # For a CS path the straight segment must be tangent to the circle:\n    # A tangent from the circle center to point F exists only if $$d \\ge R$$.\n    if d &lt; radius:\n        return None\n\n    # Angle from the circle center to F:\n    # $$\\theta_{sf} = \\operatorname{atan2}(dy_{sf}, dx_{sf})$$\n    theta_sf = math.atan2(dy_sf, dx_sf)  # \u03b8_SF in the paper\n\n    # --- 3. Angle $$\\theta_{mf}$$ between SF and the line from M to F -------\n    # From the right triangle: $$\\sin(\\theta_{mf}) = R / d$$\n    sin_theta_mf = min(1.0, max(-1.0, radius / d))\n    theta_mf = math.asin(sin_theta_mf)\n\n    # --- 4. Angle $$\\theta_M$$ of the tangent point M on the start circle ----\n    # For left-turn (LS): rotate $$\\theta_{sf}$$ CCW by $$\\theta_{mf} - \\pi/2$$.\n    # For right-turn (RS): rotate $$\\theta_{sf}$$ CW by $$-\\theta_{mf} + \\pi/2$$.\n    # The code also computes the start-angle on the circle (theta_s) based on start heading.\n    if path_type == \"LS\":\n        theta_M = theta_sf + theta_mf - math.pi / 2.0\n        theta_s=theta0-math.pi/2\n        # Normalize sweep to $$[0, 2\\pi)$$ for left arc (positive CCW sweep)\n        d_theta = (theta_M - theta_s)%(2*math.pi)\n    else:  # \"RS\"\n        theta_M = theta_sf - theta_mf + math.pi / 2.0\n        theta_s=theta0+math.pi/2\n        # Normalize sweep for right (negative / CW) arcs by shifting to negative range\n        d_theta = (theta_M - theta_s)%(2*math.pi)-2*math.pi\n\n    # Tangent point M on the circle:\n    # $$x_M = x_s + R\\cos(\\theta_M), \\quad y_M = y_s + R\\sin(\\theta_M)$$\n    xM = xs + radius * math.cos(theta_M)\n    yM = ys + radius * math.sin(theta_M)\n\n    arc = CurveSegment(center=(xs, ys), radius=radius, theta_s=theta_s%(2*math.pi), d_theta=d_theta)\n    line = LineSegment(start=(xM, yM), end=(xf, yf))\n\n    return Path([arc, line])\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.csc_segments_shortest","title":"<code>csc_segments_shortest(start: Tuple[float, float, float], end: Tuple[float, float, float], radius: float) -&gt; Path</code>","text":"<p>Return the shortest CSC path among the four canonical types: $$  ext{'LSL'},\\;   ext{'LSR'},\\;   ext{'RSL'},\\;   ext{'RSR'}$$.</p> <p>The function tries each CSC configuration using csc_segments_single and returns the feasible path with minimal total length.</p> <p>Raises - ValueError if $\\(radius \\le 0\\)$. - ValueError if all four CSC variants are infeasible.</p> Source code in <code>src/multi_uav_planner/dubins.py</code> <pre><code>def csc_segments_shortest(\n    start: Tuple[float, float, float],\n    end: Tuple[float, float, float],\n    radius: float,\n) -&gt; Path:\n    \"\"\"\n    Return the shortest CSC path among the four canonical types:\n    $$\\text{'LSL'},\\; \\text{'LSR'},\\; \\text{'RSL'},\\; \\text{'RSR'}$$.\n\n    The function tries each CSC configuration using csc_segments_single and\n    returns the feasible path with minimal total length.\n\n    Raises\n    - ValueError if $$radius \\le 0$$.\n    - ValueError if all four CSC variants are infeasible.\n    \"\"\"\n    if radius &lt;= 0.0:\n        raise ValueError(\"radius must be positive\")\n\n    candidates = [\n        csc_segments_single(start, end, radius, pt) for pt in (\"LSL\", \"LSR\", \"RSL\", \"RSR\")\n    ]\n    feasible = [p for p in candidates if p is not None]\n    if not feasible:\n        raise ValueError(\"No feasible CSC-type Dubins path\")\n    return min(feasible, key=lambda p: p.length())\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.csc_segments_single","title":"<code>csc_segments_single(start: Tuple[float, float, float], end: Tuple[float, float, float], R: float, path_type: CSCPathType) -&gt; Optional[Path]</code>","text":"<p>Build a CSC-type path consisting of two circular arcs separated by a straight line: [arc1, straight, arc2]. Returns $\\(None\\)$ if the requested tangent geometry is infeasible.</p> <p>Parameters - $\\(start\\)$: $\\((x_0, y_0,   heta_0)\\)$ start configuration (radians). - $\\(end\\)$: $\\((x_f, y_f,     heta_f)\\)$ end configuration (radians). - $\\(R\\)$: positive turning radius $\\(R &gt; 0\\)$. - $\\(path\\_type\\)$: one of $\\(\"LSL\"\\)$, $\\(\"LSR\"\\)$, $\\(\"RSL\"\\)$, $\\(\"RSR\"\\)$ describing the   turning directions of the first and second arcs.</p> <p>Returns - Path [arc1, line, arc2] when a valid tangent solution exists. - $\\(None\\)$ when no valid tangent exists (e.g., inner tangent missing).</p> <p>Notes on geometry and existence conditions: - Compute start circle center $\\(C_s\\)$ and end circle center $\\(C_f\\)$ by offsetting   the start and end positions laterally by $\\(\\pm    frac{\\pi}{2}\\)$ according to   the left/right choices for the first and second arc:   $\\(C_s = (x_0 + R\\cos(     heta_0 \\pm      frac{\\pi}{2}),\\; y_0 + R\\sin(   heta_0 \\pm      frac{\\pi}{2})),\\)$   $\\(C_f = (x_f + R\\cos(     heta_f \\pm      frac{\\pi}{2}),\\; y_f + R\\sin(   heta_f \\pm      frac{\\pi}{2})).\\)$ - Let $\\(d\\)$ be the distance between centers. For outer tangents (LSL, RSR)   an external tangent always exists for distinct centers. For inner tangents   (LSR, RSL) a tangent exists only if $\\(d \\ge 2R\\)$ because the circles must be   sufficiently separated. - The code computes tangent direction angles and arc sweeps $\\(\\Delta        heta\\)$   for the first and second arcs. These are normalized to represent the   appropriate signed rotations (positive for CCW, negative for CW).</p> Source code in <code>src/multi_uav_planner/dubins.py</code> <pre><code>def csc_segments_single(\n    start: Tuple[float, float, float],\n    end: Tuple[float, float, float],\n    R: float,\n    path_type: CSCPathType,\n) -&gt; Optional[Path]:\n    \"\"\"\n    Build a CSC-type path consisting of two circular arcs separated by a\n    straight line: [arc1, straight, arc2]. Returns $$None$$ if the requested\n    tangent geometry is infeasible.\n\n    Parameters\n    - $$start$$: $$(x_0, y_0, \\theta_0)$$ start configuration (radians).\n    - $$end$$: $$(x_f, y_f, \\theta_f)$$ end configuration (radians).\n    - $$R$$: positive turning radius $$R &gt; 0$$.\n    - $$path\\_type$$: one of $$\"LSL\"$$, $$\"LSR\"$$, $$\"RSL\"$$, $$\"RSR\"$$ describing the\n      turning directions of the first and second arcs.\n\n    Returns\n    - Path [arc1, line, arc2] when a valid tangent solution exists.\n    - $$None$$ when no valid tangent exists (e.g., inner tangent missing).\n\n    Notes on geometry and existence conditions:\n    - Compute start circle center $$C_s$$ and end circle center $$C_f$$ by offsetting\n      the start and end positions laterally by $$\\pm \\tfrac{\\pi}{2}$$ according to\n      the left/right choices for the first and second arc:\n      $$C_s = (x_0 + R\\cos(\\theta_0 \\pm \\tfrac{\\pi}{2}),\\; y_0 + R\\sin(\\theta_0 \\pm \\tfrac{\\pi}{2})),$$\n      $$C_f = (x_f + R\\cos(\\theta_f \\pm \\tfrac{\\pi}{2}),\\; y_f + R\\sin(\\theta_f \\pm \\tfrac{\\pi}{2})).$$\n    - Let $$d$$ be the distance between centers. For outer tangents (LSL, RSR)\n      an external tangent always exists for distinct centers. For inner tangents\n      (LSR, RSL) a tangent exists only if $$d \\ge 2R$$ because the circles must be\n      sufficiently separated.\n    - The code computes tangent direction angles and arc sweeps $$\\Delta\\theta$$\n      for the first and second arcs. These are normalized to represent the\n      appropriate signed rotations (positive for CCW, negative for CW).\n    \"\"\"\n    # Unpack start and end configurations\n    x0, y0, th0 = start\n    xf, yf, thf = end\n\n    # Compute center of start circle:\n    # $$\\theta_{rad\\_s} = \\theta_0 \\pm \\frac{\\pi}{2}$$ depending on first turn being L or R\n    th_rad_s = th0 + (math.pi / 2.0 if path_type[0] == \"L\" else -math.pi / 2.0)\n    xs = x0 + R * math.cos(th_rad_s)\n    ys = y0 + R * math.sin(th_rad_s)\n\n    # Compute center of end circle similarly:\n    th_rad_f = thf + (math.pi / 2.0 if path_type[-1] == \"L\" else -math.pi / 2.0)\n    xf_c = xf + R * math.cos(th_rad_f)\n    yf_c = yf + R * math.sin(th_rad_f)\n\n\n    # Vector between circle centers and its distance:\n    # $$d = \\|C_f - C_s\\|$$ and base angle $$\\theta_{sf} = \\operatorname{atan2}(dy, dx)$$\n    dx, dy = xf_c - xs, yf_c - ys\n    d = math.hypot(dx, dy)\n    th_sf = math.atan2(dy, dx)\n\n    # inner = True for LSR or RSL (these use inner tangents)\n    inner = path_type in {\"LSR\", \"RSL\"}\n\n    # Angle correction used for inner tangents:\n    theta_mn = 0.0\n    if inner: \n        # For inner tangents we need $$d \\ge 2R$$ because the tangent joins the\n        # near sides of the two circles. Compute:\n        # $$\\sin(\\theta_{mn}) = \\frac{2R}{d}$$ (derived from geometry)\n        ratio = 2 * R / d\n        if ratio &gt; 1.0:     # no inner tangent exists if centers are too close\n            return None\n        theta_mn = math.asin(min(1.0, max(-1.0, ratio)))\n\n    # Compute tangent angles and arc transitions depending on path_type.\n    # The code establishes angles of the tangent points on each circle (th_M, th_N)\n    # and the corresponding arc start angles and sweeps (delta1, delta2).\n    if path_type == \"LSL\":\n        th_M = th_sf - math.pi / 2.0\n        th_N = th_sf - math.pi / 2.0\n        theta_s1 = th0 - math.pi / 2.0\n        # Normalize to $$[0,2\\pi)$$ for left-turned arcs (CCW positive)\n        delta1 = (th_M - theta_s1)%(2*math.pi)\n        theta_f2 = thf - math.pi/2\n        delta2 = (theta_f2 - th_N)%(2*math.pi) \n    elif path_type == \"RSR\":\n        th_M = th_sf + math.pi / 2.0\n        th_N = th_sf + math.pi / 2.0\n        theta_s1 = th0+math.pi/2\n        # For right turns we represent CW rotation as a negative sweep:\n        delta1 = (th_M - theta_s1)%(2*math.pi)-(2*math.pi)\n        theta_f2=thf+math.pi/2\n        delta2 = (theta_f2 - th_N)%(2*math.pi)-(2*math.pi)\n    elif path_type == \"LSR\":\n        # inner tangent: connect left-turn start circle to right-turn end circle\n        th_M = th_sf + theta_mn - math.pi / 2.0\n        th_N = th_sf + theta_mn + math.pi / 2.0\n        theta_s1 = th0 - math.pi/2\n        delta1= (th_M-theta_s1)%(2*math.pi)\n        theta_f2= thf + math.pi/2\n        # second arc is right-turn (CW), normalize to negative sweep\n        delta2=(theta_f2 - th_N)%(2*math.pi)-(2*math.pi)\n    else: # \"RSL\"\n        # inner tangent: connect right-turn start circle to left-turn end circle\n        th_M = th_sf - theta_mn + math.pi / 2.0\n        th_N = th_sf - theta_mn - math.pi / 2.0\n        theta_s1 = th0 + math.pi/2\n        # First arc is a right turn (CW); represent CW as negative sweep\n        delta1= (th_M-theta_s1)%(2*math.pi)-(2*math.pi)\n        theta_f2= thf - math.pi/2\n        # Second arc is left turn (CCW); normalize to positive sweep\n        delta2=(theta_f2 - th_N) %(2*math.pi)\n\n    # Compute the tangent points on each circle using their angles:\n    # $$M = C_s + R[\\cos(\\theta_M), \\sin(\\theta_M)]$$\n    # $$N = C_f + R[\\cos(\\theta_N), \\sin(\\theta_N)]$$\n    xM = xs + R * math.cos(th_M)\n    yM = ys + R * math.sin(th_M)\n    xN = xf_c + R * math.cos(th_N)\n    yN = yf_c + R * math.sin(th_N)\n\n    # Construct the path segments:\n    # - arc1: CurveSegment for the initial turning arc around C_s\n    # - line: LineSegment connecting tangent points M-&gt;N\n    # - arc2: CurveSegment for the final turning arc around C_f\n    arc1 = CurveSegment(center=(xs, ys), radius=R, theta_s=theta_s1%(2*math.pi), d_theta=delta1)\n    line = LineSegment(start=(xM, yM), end=(xN, yN))\n    arc2 = CurveSegment(center=(xf_c, yf_c), radius=R, theta_s=th_N%(2*math.pi), d_theta=delta2)\n    return Path([arc1, line, arc2])\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.generate_scenario","title":"<code>generate_scenario(config: ScenarioConfig) -&gt; Scenario</code>","text":"<p>Generate a random Scenario from the provided config.</p> <p>The procedure is deterministic when $\\(config.seed\\)$ is fixed via $\\(random.seed(config.seed)\\)$, making it suitable for repeatable tests.</p> <p>Returns: - Scenario: container with fields populated (tasks, uavs, base, events, alg_type).</p> Source code in <code>src/multi_uav_planner/scenario_generation.py</code> <pre><code>def generate_scenario(config: ScenarioConfig) -&gt; Scenario:\n    \"\"\"\n    Generate a random Scenario from the provided config.\n\n    The procedure is deterministic when $$config.seed$$ is fixed via\n    $$random.seed(config.seed)$$, making it suitable for repeatable tests.\n\n    Returns:\n    - Scenario: container with fields populated (tasks, uavs, base, events, alg_type).\n    \"\"\"\n    random.seed(config.seed)\n\n    base = config.base\n\n    tasks: List[Task] = [\n        _generate_random_task(task_id=i + 1, config=config)\n        for i in range(config.n_tasks)\n    ]\n    uavs = _generate_uavs(config, base)\n\n    events = _generate_events(config)\n\n    alg_type = config.alg_type\n\n    return Scenario(\n        config=config,\n        tasks=tasks,\n        uavs=uavs,\n        base=base,\n        events=events,\n        alg_type=alg_type,\n    )\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.initialize_world","title":"<code>initialize_world(world: World, scenario: Scenario) -&gt; None</code>","text":"<p>Initialize a World instance using the data produced by generate_scenario().</p> <p>Side effects: - Overwrites world.tasks and world.uavs with dicts keyed by id. - Sets world.base and world.time (time reset to $\\(0.0\\)$). - Installs the scenario event list on world.events and resets the events cursor. - Clears and repopulates the task and UAV partition sets (unassigned/assigned/completed and idle/transit/busy/damaged). - Propagates tolerances from the scenario config into world.tols.</p> <p>Consistency checks and validation: - Validates $\\(UAV.assigned\\_path\\)$ types (must be a Path or None). - Raises ValueError for unknown task or UAV states. - At the end the function asserts that the declared partitions exactly cover   the respective id sets for tasks and UAVs.</p> Source code in <code>src/multi_uav_planner/scenario_generation.py</code> <pre><code>def initialize_world(world: World, scenario: Scenario) -&gt; None:\n    \"\"\"\n    Initialize a World instance using the data produced by generate_scenario().\n\n    Side effects:\n    - Overwrites world.tasks and world.uavs with dicts keyed by id.\n    - Sets world.base and world.time (time reset to $$0.0$$).\n    - Installs the scenario event list on world.events and resets the events cursor.\n    - Clears and repopulates the task and UAV partition sets (unassigned/assigned/completed and idle/transit/busy/damaged).\n    - Propagates tolerances from the scenario config into world.tols.\n\n    Consistency checks and validation:\n    - Validates $$UAV.assigned\\_path$$ types (must be a Path or None).\n    - Raises ValueError for unknown task or UAV states.\n    - At the end the function asserts that the declared partitions exactly cover\n      the respective id sets for tasks and UAVs.\n    \"\"\"\n    # Replace dictionaries and simple fields\n    world.tasks = {t.id: t for t in scenario.tasks}\n    world.uavs  = {u.id: u for u in scenario.uavs}\n    world.base = scenario.base\n    world.time = 0.0\n\n    # Install scheduled events\n    world.events = scenario.events\n    world.events_cursor = 0\n\n    # Clear partitions before repopulating\n    world.unassigned.clear(); world.assigned.clear(); world.completed.clear()\n    world.idle_uavs.clear(); world.transit_uavs.clear(); world.busy_uavs.clear(); world.damaged_uavs.clear()\n\n    world.tols = scenario.config.tolerances\n\n    # Populate task partitions from task.state\n    for tid, t in world.tasks.items():\n        if t.state == 0: world.unassigned.add(tid)\n        elif t.state == 1: world.assigned.add(tid)\n        elif t.state == 2: world.completed.add(tid)\n        else: raise ValueError(f\"Task {tid} has unknown state {t.state}\")\n\n    # Populate UAV partitions from u.state and validate assigned_path type\n    for uid, u in world.uavs.items():\n        if u.assigned_path is not None and not isinstance(u.assigned_path, Path):\n            raise TypeError(\"UAV.assigned_path must be a Path or None\")\n        if u.state == 0: world.idle_uavs.add(uid)\n        elif u.state == 1: world.transit_uavs.add(uid)\n        elif u.state == 2: world.busy_uavs.add(uid)\n        elif u.state == 3: world.damaged_uavs.add(uid)\n        else: raise ValueError(f\"UAV {uid} has unknown status {u.state}\")\n\n    # Final consistency assertions: partitions must exactly cover declared ids\n    assert world.unassigned | world.assigned | world.completed == set(world.tasks.keys())\n    assert world.idle_uavs | world.transit_uavs | world.busy_uavs | world.damaged_uavs == set(world.uavs.keys())\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.instrument_assignment","title":"<code>instrument_assignment(assignment_fn: Callable, registry: TimeRegistry, label: str = 'assignment')</code>","text":"<p>Return a wrapper around an assignment function that records wall and CPU time.</p> <p>Parameters: - assignment_fn: callable performing assignment (e.g., <code>assignment</code>). - registry: TimeRegistry instance used to accumulate timings. - label: label under which to record the timing (default: \"assignment\").</p> <p>The returned function has the same signature as <code>assignment_fn</code> and, in addition to forwarding its return value, will call <code>registry.add(label, wall, cpu)</code>.</p> Source code in <code>src/multi_uav_planner/post_processing.py</code> <pre><code>def instrument_assignment(assignment_fn: Callable, registry: TimeRegistry, label: str = \"assignment\"):\n    \"\"\"\n    Return a wrapper around an assignment function that records wall and CPU time.\n\n    Parameters:\n    - assignment_fn: callable performing assignment (e.g., `assignment`).\n    - registry: TimeRegistry instance used to accumulate timings.\n    - label: label under which to record the timing (default: \"assignment\").\n\n    The returned function has the same signature as `assignment_fn` and, in\n    addition to forwarding its return value, will call `registry.add(label, wall, cpu)`.\n    \"\"\"\n    def wrapped(*args, **kwargs):\n        start = time.perf_counter(); start_c = time.process_time()\n        res = assignment_fn(*args, **kwargs)\n        registry.add(label, time.perf_counter() - start, time.process_time() - start_c)\n        return res\n    return wrapped\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.instrument_cluster","title":"<code>instrument_cluster(cluster_fn: Callable, registry: TimeRegistry, label: str = 'cluster_tasks')</code>","text":"<p>Wrap the clustering routine to measure its runtime.</p> <p>Parameters: - cluster_fn: callable performing clustering (e.g., <code>cluster_tasks</code>). - registry: TimeRegistry instance used to accumulate timings. - label: label for the timing records (default: \"cluster_tasks\").</p> <p>Returned callable forwards all arguments to <code>cluster_fn</code> and records wall and CPU time.</p> Source code in <code>src/multi_uav_planner/post_processing.py</code> <pre><code>def instrument_cluster(cluster_fn: Callable, registry: TimeRegistry, label: str = \"cluster_tasks\"):\n    \"\"\"\n    Wrap the clustering routine to measure its runtime.\n\n    Parameters:\n    - cluster_fn: callable performing clustering (e.g., `cluster_tasks`).\n    - registry: TimeRegistry instance used to accumulate timings.\n    - label: label for the timing records (default: \"cluster_tasks\").\n\n    Returned callable forwards all arguments to `cluster_fn` and records wall and CPU time.\n    \"\"\"\n    def wrapped(*args, **kwargs):\n        start = time.perf_counter(); start_c = time.process_time()\n        res = cluster_fn(*args, **kwargs)\n        registry.add(label, time.perf_counter() - start, time.process_time() - start_c)\n        return res\n    return wrapped\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.instrument_planner","title":"<code>instrument_planner(plan_to_task_fn: Callable, registry: TimeRegistry, label: str = 'plan_path_to_task')</code>","text":"<p>Wrap a path planning function to collect runtime per invocation.</p> <p>Parameters: - plan_to_task_fn: callable (e.g., <code>plan_path_to_task</code>) to be wrapped. - registry: TimeRegistry instance to record timings. - label: label to record timings under (default: \"plan_path_to_task\").</p> Usage <p>planner = instrument_planner(plan_path_to_task, registry) path = planner(world, uav_id, target_pose)</p> Source code in <code>src/multi_uav_planner/post_processing.py</code> <pre><code>def instrument_planner(plan_to_task_fn: Callable, registry: TimeRegistry, label: str = \"plan_path_to_task\"):\n    \"\"\"\n    Wrap a path planning function to collect runtime per invocation.\n\n    Parameters:\n    - plan_to_task_fn: callable (e.g., `plan_path_to_task`) to be wrapped.\n    - registry: TimeRegistry instance to record timings.\n    - label: label to record timings under (default: \"plan_path_to_task\").\n\n    Usage:\n        planner = instrument_planner(plan_path_to_task, registry)\n        path = planner(world, uav_id, target_pose)\n    \"\"\"\n    def wrapped(*args, **kwargs):\n        start = time.perf_counter(); start_c = time.process_time()\n        res = plan_to_task_fn(*args, **kwargs)\n        registry.add(label, time.perf_counter() - start, time.process_time() - start_c)\n        return res\n    return wrapped\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.move_in_transit","title":"<code>move_in_transit(world: World, dt: float) -&gt; bool</code>","text":"<p>Advance UAVs currently in the <code>world.transit_uavs</code> set by time step $\\(dt\\)$.</p> <p>Behavior: - For each UAV id <code>j</code> in <code>world.transit_uavs</code>:     - If the UAV has no assigned path (<code>uav.assigned_path</code> is None) or       the path has no remaining segments, the UAV is considered to have       reached the assigned position. The UAV is moved from the transit       partition to the busy partition and a mission path for the assigned       task is generated via <code>plan_mission_path</code>.     - Otherwise, call <code>pose_update(uav, dt, world.tols.ang)</code> to advance       the UAV along its current active segment.       - If <code>pose_update</code> returns True it means the active segment was         completed during this update; in that case the completed segment         is removed from the path (<code>path.segments.pop(0)</code>). - The function returns True if any UAV had its pose advanced during this call.</p> <p>Notes: - The function iterates over a snapshot <code>list(world.transit_uavs)</code> to   permit safely removing/adding ids to the partition sets inside the loop.</p> Source code in <code>src/multi_uav_planner/stepping_fcts.py</code> <pre><code>def move_in_transit(world: World, dt: float) -&gt; bool:\n    \"\"\"\n    Advance UAVs currently in the ``world.transit_uavs`` set by time step $$dt$$.\n\n    Behavior:\n    - For each UAV id ``j`` in ``world.transit_uavs``:\n        - If the UAV has no assigned path (``uav.assigned_path`` is None) or\n          the path has no remaining segments, the UAV is considered to have\n          reached the assigned position. The UAV is moved from the transit\n          partition to the busy partition and a mission path for the assigned\n          task is generated via ``plan_mission_path``.\n        - Otherwise, call ``pose_update(uav, dt, world.tols.ang)`` to advance\n          the UAV along its current active segment.\n          - If ``pose_update`` returns True it means the active segment was\n            completed during this update; in that case the completed segment\n            is removed from the path (``path.segments.pop(0)``).\n    - The function returns True if any UAV had its pose advanced during this call.\n\n    Notes:\n    - The function iterates over a snapshot ``list(world.transit_uavs)`` to\n      permit safely removing/adding ids to the partition sets inside the loop.\n    \"\"\"\n    moved = False\n    for j in list(world.transit_uavs):\n        uav = world.uavs[j]\n        path = uav.assigned_path\n        if path is None or not path.segments:\n            # Path empty: arrive =&gt; switch to busy and create mission path\n            world.transit_uavs.remove(j)\n            world.busy_uavs.add(j)\n            uav.state = 2\n            tid = uav.current_task\n            if tid is not None:\n                # Generate intratask coverage path (may be empty for point tasks)\n                uav.assigned_path = plan_mission_path(uav, world.tasks[tid])\n            continue\n\n        # Advance along the current segment\n        flag = pose_update(uav, dt, world.tols.ang)\n        moved = True\n        if flag:\n            # The active segment completed: remove it from the path\n            path.segments.pop(0)\n    return moved\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.perform_task","title":"<code>perform_task(world: World, dt: float) -&gt; bool</code>","text":"<p>Advance UAVs that are executing a task (<code>world.busy_uavs</code>) by $\\(dt\\)$.</p> <p>Behavior: - For each UAV id <code>j</code> in <code>world.busy_uavs</code>:     - If the UAV has an assigned mission path with remaining segments,       call <code>pose_update</code> to advance along the active segment. If the       active segment completes, pop it from the path.     - If the UAV has no mission path or no remaining segments after the       advance, the task is considered finished:         - Move the UAV from <code>busy</code> to <code>idle</code> partition and clear its           assigned path and <code>current_task</code>.         - Mark the task as completed in the world partition sets:           move task id from <code>assigned</code> to <code>completed</code> and set           <code>world.tasks[tid].state = 2</code>.         - If the task belonged to the UAV's cluster, remove it; recompute           cluster CoG if tasks remain, else clear the CoG. - Returns True if any UAV had its pose advanced.</p> <p>Notes: - All updates mutate the World and UAVs in-place.</p> Source code in <code>src/multi_uav_planner/stepping_fcts.py</code> <pre><code>def perform_task(world: World, dt: float) -&gt; bool:\n    \"\"\"\n    Advance UAVs that are executing a task (``world.busy_uavs``) by $$dt$$.\n\n    Behavior:\n    - For each UAV id ``j`` in ``world.busy_uavs``:\n        - If the UAV has an assigned mission path with remaining segments,\n          call ``pose_update`` to advance along the active segment. If the\n          active segment completes, pop it from the path.\n        - If the UAV has no mission path or no remaining segments after the\n          advance, the task is considered finished:\n            - Move the UAV from ``busy`` to ``idle`` partition and clear its\n              assigned path and ``current_task``.\n            - Mark the task as completed in the world partition sets:\n              move task id from ``assigned`` to ``completed`` and set\n              ``world.tasks[tid].state = 2``.\n            - If the task belonged to the UAV's cluster, remove it; recompute\n              cluster CoG if tasks remain, else clear the CoG.\n    - Returns True if any UAV had its pose advanced.\n\n    Notes:\n    - All updates mutate the World and UAVs in-place.\n    \"\"\"\n    moved = False\n    for j in list(world.busy_uavs):\n        uav = world.uavs[j]\n        path = uav.assigned_path\n\n        if path and path.segments:\n            flag = pose_update(uav, dt, world.tols.ang)\n            moved = True\n            if flag:\n                path.segments.pop(0)\n\n        if path is None or not path.segments:\n            # Task finished: update partitions and bookkeeping\n            tid = uav.current_task\n            world.busy_uavs.remove(j)\n            world.idle_uavs.add(j)\n            uav.state = 0\n            uav.assigned_path = None\n            if tid is not None:\n                # Mark task completed\n                world.tasks[tid].state = 2\n                world.assigned.discard(tid)\n                world.completed.add(tid)\n                uav.current_task = None\n                # Maintain cluster membership and recompute CoG if needed\n                if tid in uav.cluster:\n                    uav.cluster.remove(tid)\n                    if uav.cluster:\n                        xs = [world.tasks[t].position[0] for t in uav.cluster]\n                        ys = [world.tasks[t].position[1] for t in uav.cluster]\n                        uav.cluster_CoG = (sum(xs) / len(xs), sum(ys) / len(ys))\n                    else:\n                        uav.cluster_CoG = None\n\n    return moved\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.plan_mission_path","title":"<code>plan_mission_path(uav: UAV, task: Task) -&gt; Optional[Path]</code>","text":"<p>Build the coverage path required to perform the given Task. The returned Path describes how the UAV should traverse the geometry inside the task.</p> <p>Summary per task type: - PointTask:     - No coverage path inside the task: returns an empty Path <code>[]</code>. - LineTask:     - Returns a single straight LineSegment of length <code>task.length</code> starting       at the task position and oriented along the mission heading. - CircleTask:     - Returns a single full-circle CurveSegment centered so the circle       passes through the task position and starts with the specified heading.       The sweep is $\\(\\pm 2\\pi\\)$ depending on the <code>side</code> ('left' =&gt; +2\u03c0, 'right' =&gt; -2\u03c0).       The start angle is computed so that the tangent/heading at the start       matches the requested mission heading. - AreaTask:     - Constructs a boustrophedon (back-and-forth) pattern consisting of       straight passes (LineSegment) and semicircular end-turns (CurveSegment).       The semicircle radius used for turns is $\\(r_{turn} = \frac{    ext{pass\\_spacing}}{2}\\)$.</p> <p>Parameters: - $\\(uav\\)$: UAV instance providing current pose and parameters (used for default heading). - $\\(task\\)$: Task instance describing the required coverage.</p> <ul> <li>Path containing the sequence of segments to cover the task area, or   an empty Path for tasks that need no intratask traversal (PointTask).</li> </ul> Source code in <code>src/multi_uav_planner/path_planner.py</code> <pre><code>def plan_mission_path(uav: UAV, task: Task) -&gt; Optional[Path]:\n    \"\"\"\n    Build the coverage path required to perform the given Task. The returned\n    Path describes how the UAV should traverse the geometry inside the task.\n\n    Summary per task type:\n    - PointTask:\n        - No coverage path inside the task: returns an empty Path `[]`.\n    - LineTask:\n        - Returns a single straight LineSegment of length `task.length` starting\n          at the task position and oriented along the mission heading.\n    - CircleTask:\n        - Returns a single full-circle CurveSegment centered so the circle\n          passes through the task position and starts with the specified heading.\n          The sweep is $$\\pm 2\\pi$$ depending on the `side` ('left' =&gt; +2\u03c0, 'right' =&gt; -2\u03c0).\n          The start angle is computed so that the tangent/heading at the start\n          matches the requested mission heading.\n    - AreaTask:\n        - Constructs a boustrophedon (back-and-forth) pattern consisting of\n          straight passes (LineSegment) and semicircular end-turns (CurveSegment).\n          The semicircle radius used for turns is $$r_{turn} = \\frac{\\text{pass\\_spacing}}{2}$$.\n\n    Parameters:\n    - $$uav$$: UAV instance providing current pose and parameters (used for default heading).\n    - $$task$$: Task instance describing the required coverage.\n\n    Returns:\n    - Path containing the sequence of segments to cover the task area, or\n      an empty Path for tasks that need no intratask traversal (PointTask).\n    \"\"\"\n    xe, ye = task.position\n    # Choose mission heading: if the task enforces a heading use it; otherwise use UAV heading\n    base_heading = task.heading if task.heading_enforcement else uav.position[2]\n\n    if isinstance(task, PointTask):\n        # No traversal required inside a point task\n        return Path([])\n\n    elif isinstance(task, LineTask):\n        # Create a straight pass starting at the task position in direction base_heading\n        assert isinstance(task, LineTask)\n        end_x = xe + task.length * math.cos(base_heading)\n        end_y = ye + task.length * math.sin(base_heading)\n        return Path([LineSegment(start=(xe, ye), end=(end_x, end_y))])\n\n    elif isinstance(task, CircleTask):\n        # Full-circle traversal: choose sweep sign by side and compute circle center\n        assert isinstance(task, CircleTask)\n        d_theta = +2 * math.pi if task.side == 'left' else -2 * math.pi\n        # Start angle: offset such that the circle tangent aligns with base_heading.\n        # We move start angle by +/- pi/2 depending on the sweep sign:\n        theta_s = base_heading - sgn(d_theta) * (math.pi / 2)\n        # Compute circle center so the circle of radius R passes through the task point (xe, ye).\n        # We place center on the ray from the task via angle (theta_s + pi).\n        xc = xe + task.radius * math.cos(theta_s + math.pi)\n        yc = ye + task.radius * math.sin(theta_s + math.pi)\n        return Path([CurveSegment(center=(xc, yc), radius=task.radius, theta_s=theta_s, d_theta=d_theta)])\n\n    elif isinstance(task, AreaTask):\n        # Boustrophedon pattern: alternating straight passes and semicircular turns.\n        assert isinstance(task, AreaTask)\n        segs: List[Segment] = []\n        # Semicircle radius used at pass ends:\n        r_turn = task.pass_spacing / 2.0\n        # Starting position for the first pass\n        x_curr, y_curr = xe, ye\n\n        for i in range(task.num_passes):\n            # Alternate pass direction: even -&gt; base_heading, odd -&gt; base_heading + pi\n            heading_i = base_heading if (i % 2 == 0) else (base_heading + math.pi)\n            # Straight pass end point\n            x_end = x_curr + task.pass_length * math.cos(heading_i)\n            y_end = y_curr + task.pass_length * math.sin(heading_i)\n            segs.append(LineSegment(start=(x_curr, y_curr), end=(x_end, y_end)))\n\n            if i == task.num_passes - 1:\n                # No turn after the last pass\n                break\n\n            # Determine turn side to shift laterally by pass_spacing.\n            # We alternate the turn side so that passes are offset correctly.\n            turn_side = task.side if (i % 2 == 0) else ('right' if task.side == 'left' else 'left')\n            # Normal direction relative to current heading: +pi/2 for left, -pi/2 for right\n            normal = math.pi / 2.0 if turn_side == 'left' else -math.pi / 2.0\n            # Semicircle center offset from the end point along the normal direction\n            cx = x_end + r_turn * math.cos(heading_i + normal)\n            cy = y_end + r_turn * math.sin(heading_i + normal)\n            # Angle from center to starting point of the turn (end of straight pass)\n            theta_s = math.atan2(y_end - cy, x_end - cx)\n            # Semicircle sweep: +pi for left-turn (CCW), -pi for right-turn (CW)\n            d_theta = +math.pi if turn_side == 'left' else -math.pi\n            segs.append(CurveSegment(center=(cx, cy), radius=r_turn, theta_s=theta_s, d_theta=d_theta))\n            # Update current point to the end of the semicircle (start of next pass)\n            theta_e = theta_s + d_theta\n            x_curr = cx + r_turn * math.cos(theta_e)\n            y_curr = cy + r_turn * math.sin(theta_e)\n\n        return Path(segs)\n\n    else:\n        raise ValueError(f\"Unknown task type: {type(task).__name__}\")\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.plan_path_to_task","title":"<code>plan_path_to_task(world: World, uid: int, t_pose: Tuple[float, float, float]) -&gt; Path</code>","text":"<p>Plan a feasible path (sequence of segments) that brings UAV <code>uid</code> from its current pose to the task entry pose <code>t_pose</code>.</p> <p>Policy summary (priority and fallbacks):   1) If the UAV is already co-located with the task position within positional tolerance:      - If the requested entry heading is unconstrained (None) or matches the UAV heading        within angular tolerance, return an empty Path (no motion required).      - Otherwise, perform an in-place heading adjustment using the shortest CSC path        (which reduces to a pure rotational maneuver when spatial displacement is zero).   2) Try a single straight-line (LineSegment) if headings permit:      - For unconstrained task entry heading (the is None), only the UAV's heading        must be aligned with the line to the target.      - For constrained task entry heading, both the UAV heading and the desired        task heading must be aligned with the line direction within angular tolerance.   3) Otherwise use Dubins-style constructions (turns of radius $\\(R\\)$):      - If the task entry heading is unconstrained: compute the shortest CS path        using <code>cs_segments_shortest</code>.      - If the task entry heading is constrained:          a) Try CS candidates (LS/RS) that end with a straight-line segment oriented             so that the straight segment's heading matches the desired task heading             within angular tolerance; pick the shortest feasible such CS if any.          b) If none of the CS candidates satisfy the heading constraint or are infeasible,             fall back to the shortest CSC path via <code>csc_segments_shortest</code>.</p> <p>Parameters: - $\\(world\\)$: World object giving UAV states and tolerances. - $\\(uid\\)$: UAV identifier (must be a key in $\\(world.uavs\\)$). - $\\(t\\_pose\\)$: target pose tuple $\\((x_e, y_e,       heta_e)\\)$ where $$      heta_e$$ may be $\\(None\\)$              if the entry heading is unconstrained.</p> <p>Returns: - Path instance representing the planned sequence of segments.</p> <p>Notes and assumptions: - UAV minimum turn radius $\\(R\\)$ is read from the UAV object and must be positive. - Angular comparisons use the world's tolerances $\\(world.tols.ang\\)$ and positional   comparisons use $\\(world.tols.pos\\)$.</p> Source code in <code>src/multi_uav_planner/path_planner.py</code> <pre><code>def plan_path_to_task(world: World, uid:int, t_pose: Tuple[float,float,float]) -&gt; Path:\n    \"\"\"\n    Plan a feasible path (sequence of segments) that brings UAV `uid` from its\n    current pose to the task entry pose `t_pose`.\n\n    Policy summary (priority and fallbacks):\n      1) If the UAV is already co-located with the task position within positional tolerance:\n         - If the requested entry heading is unconstrained (None) or matches the UAV heading\n           within angular tolerance, return an empty Path (no motion required).\n         - Otherwise, perform an in-place heading adjustment using the shortest CSC path\n           (which reduces to a pure rotational maneuver when spatial displacement is zero).\n      2) Try a single straight-line (LineSegment) if headings permit:\n         - For unconstrained task entry heading (the is None), only the UAV's heading\n           must be aligned with the line to the target.\n         - For constrained task entry heading, both the UAV heading and the desired\n           task heading must be aligned with the line direction within angular tolerance.\n      3) Otherwise use Dubins-style constructions (turns of radius $$R$$):\n         - If the task entry heading is unconstrained: compute the shortest CS path\n           using `cs_segments_shortest`.\n         - If the task entry heading is constrained:\n             a) Try CS candidates (LS/RS) that end with a straight-line segment oriented\n                so that the straight segment's heading matches the desired task heading\n                within angular tolerance; pick the shortest feasible such CS if any.\n             b) If none of the CS candidates satisfy the heading constraint or are infeasible,\n                fall back to the shortest CSC path via `csc_segments_shortest`.\n\n    Parameters:\n    - $$world$$: World object giving UAV states and tolerances.\n    - $$uid$$: UAV identifier (must be a key in $$world.uavs$$).\n    - $$t\\_pose$$: target pose tuple $$(x_e, y_e, \\theta_e)$$ where $$\\theta_e$$ may be $$None$$\n                 if the entry heading is unconstrained.\n\n    Returns:\n    - Path instance representing the planned sequence of segments.\n\n    Notes and assumptions:\n    - UAV minimum turn radius $$R$$ is read from the UAV object and must be positive.\n    - Angular comparisons use the world's tolerances $$world.tols.ang$$ and positional\n      comparisons use $$world.tols.pos$$.\n    \"\"\"\n\n    x0, y0, th0 = world.uavs[uid].position\n    R = world.uavs[uid].turn_radius\n    xe, ye, the = t_pose\n    tols = world.tols\n\n    if R &lt;= 0.0:\n        raise ValueError(\"UAV minimum turn radius must be positive!\")\n\n    # 1) Co-located check: if position difference within tolerance\n    if _distance((x0, y0), (xe, ye)) &lt;= tols.pos:\n        # If heading is unconstrained or matches within tolerance, no motion required\n        if the is None or abs(_angle_diff(th0, the)) &lt;= tols.ang:\n            return Path([])\n        # Else, adjust heading in place using CSC (degenerate straight length)\n        return csc_segments_shortest((x0, y0, th0), (xe, ye, the), R)\n\n    # 2) Straight-line feasibility check\n    dir_to_target = math.atan2(ye - y0, xe - x0)\n    # For unconstrained entry heading: only UAV heading must align with the line\n    if the is None and abs(_angle_diff(th0, dir_to_target)) &lt;= tols.ang:\n        return Path([LineSegment(start=(x0, y0), end=(xe, ye))])\n    # For constrained entry heading: both UAV and desired heading must align with the line\n    if the is not None:\n        if abs(_angle_diff(th0, dir_to_target)) &lt;= tols.ang and abs(_angle_diff(the, dir_to_target)) &lt;= tols.ang:\n            return Path([LineSegment(start=(x0, y0), end=(xe, ye))])\n\n    # 3) Dubins-style constructions\n    if the is None:\n        # Only a CS path is needed (final heading unconstrained)\n        return cs_segments_shortest((x0, y0, th0), (xe, ye), R)\n    else:\n        # Try CS candidates (LS, RS) and filter those whose final straight-line\n        # heading matches the requested task heading within tolerance.\n        cs_candidates = [\n            cs_segments_single((x0, y0, th0), (xe, ye), R, pt) for pt in (\"LS\", \"RS\")\n        ]\n        cs_feasible = [p for p in cs_candidates if p is not None]\n        # Filter by final-line heading\n        filtered: List[Path] = []\n        for p in cs_feasible:\n            last = p.segments[-1]\n            if isinstance(last, LineSegment):\n                line_h = _line_heading(last)\n                if abs(_angle_diff(line_h, the)) &lt;= tols.ang:\n                    filtered.append(p)\n        if filtered:\n            return min(filtered, key=lambda p: p.length())\n\n        # No CS candidate meets the heading requirement; use the shortest CSC path\n        return csc_segments_shortest((x0, y0, th0), (xe, ye, the), R)\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.return_to_base","title":"<code>return_to_base(world, use_dubins)</code>","text":"<p>Send all idle UAVs back to base.</p> <p>Parameters: - $\\(world\\)$: World instance whose <code>idle_uavs</code> set will be processed. - $\\(use\\_dubins\\)$: if True use <code>plan_path_to_task</code> (Dubins-aware planner)   to compute a feasible path to the base pose; otherwise assign a single   straight-line <code>LineSegment</code> path to the base.</p> <p>Side effects: - Moves each idle UAV into the <code>transit</code> partition and sets its state to 1. - Updates <code>uav.assigned_path</code> for each UAV accordingly.</p> Source code in <code>src/multi_uav_planner/stepping_fcts.py</code> <pre><code>def return_to_base(world, use_dubins):\n    \"\"\"\n    Send all idle UAVs back to base.\n\n    Parameters:\n    - $$world$$: World instance whose ``idle_uavs`` set will be processed.\n    - $$use\\_dubins$$: if True use ``plan_path_to_task`` (Dubins-aware planner)\n      to compute a feasible path to the base pose; otherwise assign a single\n      straight-line ``LineSegment`` path to the base.\n\n    Side effects:\n    - Moves each idle UAV into the ``transit`` partition and sets its state to 1.\n    - Updates ``uav.assigned_path`` for each UAV accordingly.\n    \"\"\"\n    for j in list(world.idle_uavs):\n        world.uavs[j].state = 1\n        world.idle_uavs.remove(j)\n        world.transit_uavs.add(j)\n        if use_dubins:\n            # Compute a Dubins-style path back to base (more realistic)\n            world.uavs[j].assigned_path = plan_path_to_task(world, j, world.base)\n        else:\n            # Simple straight-line return: single LineSegment from current position to base\n            world.uavs[j].assigned_path = Path(\n                segments=[LineSegment((world.uavs[j].position[0], world.uavs[j].position[1]),\n                                      (world.base[0], world.base[1]))]\n            )\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.save_csv_rows","title":"<code>save_csv_rows(path: str, header: List[str], rows: List[Tuple[Any, ...]])</code>","text":"<p>Write rows (sequence of tuples) to a CSV file with optional header.</p> <p>Parameters: - path: output file path. - header: list of column names. If empty, no header row is written. - rows: iterable of tuples representing CSV rows.</p> <p>Notes: - Uses newline='' when opening the file for cross-platform CSV writing. - Values are written verbatim using the default csv.writer formatting.</p> Source code in <code>src/multi_uav_planner/post_processing.py</code> <pre><code>def save_csv_rows(path: str, header: List[str], rows: List[Tuple[Any,...]]):\n    \"\"\"Write rows (sequence of tuples) to a CSV file with optional header.\n\n    Parameters:\n    - path: output file path.\n    - header: list of column names. If empty, no header row is written.\n    - rows: iterable of tuples representing CSV rows.\n\n    Notes:\n    - Uses newline='' when opening the file for cross-platform CSV writing.\n    - Values are written verbatim using the default csv.writer formatting.\n    \"\"\"\n    with open(path, \"w\", newline=\"\") as f:\n        w = csv.writer(f)\n        if header:\n            w.writerow(header)\n        for r in rows:\n            w.writerow(r)\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.simulate_mission","title":"<code>simulate_mission(world: World, scenario: Optional[Scenario], dt: float = 0.1, max_time: float = 100.0, N_stall: int = 30, on_step: Optional[Callable[[World, str], None]] = None) -&gt; None</code>","text":"<p>Run a discrete-time simulation of the multi-UAV mission until completion or timeout.</p> <p>Parameters - $\\(world\\)$: a World object that will be advanced in-place. If the world is not              initialized (<code>world.is_initialized()</code> returns False), the function              will initialize it using <code>scenario</code> or by synthesizing one. - $\\(scenario\\)$: optional Scenario used to initialize the world if necessary.                 If None, a default ScenarioConfig is used and a scenario is                 generated internally. - $\\(dt\\)$: simulation time step in seconds (default: $\\(0.1\\)$). - $\\(max\\_time\\)$: safety upper bound on simulation time in seconds; simulation                 aborts if exceeded (default: $\\(1    imes 10^2\\)$). - $\\(N\\_stall\\)$: number of consecutive ticks with no UAV movement after which                the simulation prints a stall warning and aborts (reserved). - $\\(on\\_step\\)$: optional callback <code>on_step(world, tag)</code> invoked at several                logical points; useful for logging or visualization. Tags used:                - <code>\"init\"</code>: after initialization,                - <code>\"triggering_events\"</code>: after event processing,                - <code>\"assignment\"</code>: after assignment step,                - <code>\"after_move\"</code>: after moving transit UAVs,                - <code>\"end_tick (post_coverage)\"</code>: end of tick,                - <code>\"planned_return\"</code>: after scheduling return-to-base.</p> <p>High-level loop (per tick):   1. Process pending events whose trigger time &lt;= world.time.   2. If using PRBDD, run clustering once at initialization.   3. If there are idle UAVs and unassigned tasks, run the selected assignment      algorithm to produce committed UAV-&gt;task assignments.   4. Advance UAVs that are in-transit (move_in_transit).   5. Advance UAVs that are executing tasks (perform_task).   6. Detect stalls (no UAV moved) and abort if they persist for $\\(N\\_stall\\)$ ticks.   7. Increment world.time by $\\(dt\\)$ and continue until all tasks are completed      and all UAVs have returned to base (see stopping condition below).</p> <p>Stopping condition: - The main loop continues while:     - not <code>world.done()</code> (i.e., there remain unassigned or assigned tasks)     OR     - not <code>world.at_base()</code> (i.e., UAVs are yet to be at base).   When the world has no pending tasks but UAVs are not at base, the   simulator triggers <code>return_to_base</code> for idle UAVs and continues until they   reach base or time limit / stall aborts the run.</p> <p>Side effects: - The function mutates <code>world</code> (tasks/UAVs/partitions/time) and may call   assignment and path-planning routines that set UAV assigned paths.</p> Source code in <code>src/multi_uav_planner/simulation_loop.py</code> <pre><code>def simulate_mission(\n    world: World,\n    scenario: Optional[Scenario],\n    dt: float = 0.1,\n    max_time: float = 1e2,\n    N_stall: int = 30,  # reserved for future stall detection\n    on_step: Optional[Callable[[World, str], None]] = None,  # recorder hook\n) -&gt; None:\n    \"\"\"\n    Run a discrete-time simulation of the multi-UAV mission until completion or timeout.\n\n    Parameters\n    - $$world$$: a World object that will be advanced in-place. If the world is not\n                 initialized (``world.is_initialized()`` returns False), the function\n                 will initialize it using `scenario` or by synthesizing one.\n    - $$scenario$$: optional Scenario used to initialize the world if necessary.\n                    If None, a default ScenarioConfig is used and a scenario is\n                    generated internally.\n    - $$dt$$: simulation time step in seconds (default: $$0.1$$).\n    - $$max\\_time$$: safety upper bound on simulation time in seconds; simulation\n                    aborts if exceeded (default: $$1 \\times 10^2$$).\n    - $$N\\_stall$$: number of consecutive ticks with no UAV movement after which\n                   the simulation prints a stall warning and aborts (reserved).\n    - $$on\\_step$$: optional callback ``on_step(world, tag)`` invoked at several\n                   logical points; useful for logging or visualization. Tags used:\n                   - ``\"init\"``: after initialization,\n                   - ``\"triggering_events\"``: after event processing,\n                   - ``\"assignment\"``: after assignment step,\n                   - ``\"after_move\"``: after moving transit UAVs,\n                   - ``\"end_tick (post_coverage)\"``: end of tick,\n                   - ``\"planned_return\"``: after scheduling return-to-base.\n\n    High-level loop (per tick):\n      1. Process pending events whose trigger time &lt;= world.time.\n      2. If using PRBDD, run clustering once at initialization.\n      3. If there are idle UAVs and unassigned tasks, run the selected assignment\n         algorithm to produce committed UAV-&gt;task assignments.\n      4. Advance UAVs that are in-transit (move_in_transit).\n      5. Advance UAVs that are executing tasks (perform_task).\n      6. Detect stalls (no UAV moved) and abort if they persist for $$N\\_stall$$ ticks.\n      7. Increment world.time by $$dt$$ and continue until all tasks are completed\n         and all UAVs have returned to base (see stopping condition below).\n\n    Stopping condition:\n    - The main loop continues while:\n        - not ``world.done()`` (i.e., there remain unassigned or assigned tasks)\n        OR\n        - not ``world.at_base()`` (i.e., UAVs are yet to be at base).\n      When the world has no pending tasks but UAVs are not at base, the\n      simulator triggers `return_to_base` for idle UAVs and continues until they\n      reach base or time limit / stall aborts the run.\n\n    Side effects:\n    - The function mutates ``world`` (tasks/UAVs/partitions/time) and may call\n      assignment and path-planning routines that set UAV assigned paths.\n    \"\"\"\n    # Initialize world if needed\n    if not world.is_initialized():\n        if scenario is None:\n            cfg = ScenarioConfig()\n            scenario = generate_scenario(cfg)\n        initialize_world(world, scenario)\n        if on_step:\n            on_step(world, \"init\")\n\n    # For PRBDD workflow, perform initial clustering to populate UAV clusters\n    if scenario.alg_type is AlgorithmType.PRBDD:\n        cluster_tasks(world)\n\n    stall = 0\n\n    # Main simulation loop: iterate until mission finished and UAVs are at base\n    while not world.done() or not world.at_base():\n        # -------------------------------\n        # 1) Process events (new tasks, UAV damage)\n        # -------------------------------\n        check_for_events(world, scenario.alg_type is AlgorithmType.PRBDD)\n        if on_step:\n            on_step(world, \"triggering_events\")\n\n        # -------------------------------\n        # 2) Assignment step (idle UAVs -&gt; unassigned tasks)\n        # -------------------------------\n        if world.idle_uavs and world.unassigned:\n            assignment(world, scenario.alg_type)\n        if on_step:\n            on_step(world, \"assignment\")\n\n        # -------------------------------\n        # 3) Advance UAVs in-transit along their assigned paths\n        # -------------------------------\n        transit_moved = move_in_transit(world, dt)\n        if on_step:\n            on_step(world, \"after_move\")\n\n        # -------------------------------\n        # 4) Advance UAVs that are executing tasks (coverage)\n        # -------------------------------\n        mission_moved = perform_task(world, dt)\n\n        # -------------------------------\n        # 5) Stall detection: abort if no UAV moved for N_stall ticks\n        # -------------------------------\n        if not transit_moved and not mission_moved:\n            stall += 1\n            if stall &gt;= N_stall:\n                print(\"Warning: Simulation is stalled, Simulation aborted\")\n                break\n        else:\n            stall = 0\n\n        # -------------------------------\n        # 6) Advance global simulation time and notify observers\n        # -------------------------------\n        world.time += dt\n        if on_step:\n            on_step(world, \"end_tick (post_coverage)\")\n\n        # Safety: abort if simulation time exceeds the configured limit\n        if world.time &gt; max_time:\n            print(\"Simulation aborted: time limit exceeded\")\n            break\n\n        # If all tasks are complete but UAVs are not yet at base and there are no\n        # active transit/busy UAVs, schedule a return-to-base for idle UAVs.\n        if world.done() and not world.at_base() and not world.transit_uavs and not world.busy_uavs:\n            return_to_base(world, scenario.alg_type in {AlgorithmType.PRBDD, AlgorithmType.RBDD})\n            if on_step:\n                on_step(world, \"planned_return\")\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.summarize_uav_path_lengths","title":"<code>summarize_uav_path_lengths(uav_paths: Dict[int, Path]) -&gt; Dict[str, float]</code>","text":"<p>Return summary statistics over planned path lengths.</p> <p>The returned dict contains <code>total</code>, <code>avg</code>, <code>max</code>, and <code>min</code> values. If no paths are provided, zeros are returned.</p> Source code in <code>src/multi_uav_planner/post_processing.py</code> <pre><code>def summarize_uav_path_lengths(uav_paths: Dict[int, Path]) -&gt; Dict[str, float]:\n    \"\"\"Return summary statistics over planned path lengths.\n\n    The returned dict contains `total`, `avg`, `max`, and `min` values. If no\n    paths are provided, zeros are returned.\n    \"\"\"\n    lengths = list(compute_uav_path_lengths(uav_paths).values())\n    if not lengths:\n        return {\"total\": 0.0, \"avg\": 0.0, \"max\": 0.0, \"min\": 0.0}\n    total = sum(lengths)\n    return {\n        \"total\": total,\n        \"avg\": total / len(lengths),\n        \"max\": max(lengths),\n        \"min\": min(lengths),\n    }\n</code></pre>"},{"location":"api/multi_uav_planner/#multi_uav_planner.summarize_world","title":"<code>summarize_world(world) -&gt; Dict[str, Any]</code>","text":"<p>Return a small dictionary summarizing the final world state.</p> Source code in <code>src/multi_uav_planner/post_processing.py</code> <pre><code>def summarize_world(world) -&gt; Dict[str, Any]:\n    \"\"\"Return a small dictionary summarizing the final world state.\"\"\"\n    return {\n        \"time_final\": world.time,\n        \"n_tasks_total\": len(world.tasks),\n        \"n_unassigned\": len(world.unassigned),\n        \"n_assigned\": len(world.assigned),\n        \"n_completed\": len(world.completed),\n        \"n_uavs\": len(world.uavs),\n        \"n_idle\": len(world.idle_uavs),\n        \"n_transit\": len(world.transit_uavs),\n        \"n_busy\": len(world.busy_uavs),\n        \"n_damaged\": len(world.damaged_uavs),\n        \"at_base\": world.at_base(),\n        \"done\": world.done(),\n    }\n</code></pre>"},{"location":"dev/architecture/","title":"Architecture \u2014 Multi\u2011UAV Planner","text":"<p>Purpose: Describe package structure, main components, data model, runtime data flow, extension points, and engineering notes so contributors and integrators can quickly understand how the system is organized.</p>"},{"location":"dev/architecture/#overview-high-level","title":"Overview (high level)","text":"<p>The project is organized into small focused modules with clearly separated responsibilities:</p> <ul> <li>Scene &amp; state model \u2014 persistent simulation state and basic datatypes  </li> <li>Scenario generation \u2014 randomized scenario creation (tasks, events, UAVs)  </li> <li>Path primitives &amp; Dubins utilities \u2014 geometric primitives and CS/CSC constructions  </li> <li>Path planner \u2014 single\u2011UAV transit planning and mission\u2011coverage path generation  </li> <li>Clustering &amp; assignment \u2014 task clustering and UAV\u2194task matching (multiple algorithms)  </li> <li>Simulation &amp; stepping \u2014 time\u2011stepped execution, event handling, UAV motion integration  </li> <li>Visualization \u2014 plotting and animation helpers (Matplotlib)  </li> <li>Post\u2011processing \u2014 run logging, metrics, export, timing utilities  </li> <li>Docs &amp; CI \u2014 mkdocs\u2011based docs, tests, and deployment workflows</li> </ul> <p>This separation keeps algorithms isolated from simulation bookkeeping and from visualization.</p>"},{"location":"dev/architecture/#top-level-package-layout-simplified","title":"Top-level package layout (simplified)","text":"<pre><code>src/multi_uav_planner/\n  path_model.py           # Segment, LineSegment, CurveSegment, Path\n  world_models.py         # Task, UAV, Event, World, Tolerances\n  scenario_generation.py  # ScenarioConfig, generate_scenario\n  dubins.py               # CS/CSC construction helpers\n  path_planner.py         # plan_path_to_task, plan_mission_path\n  clustering.py           # K-means clustering &amp; cluster-&gt;UAV mapping\n  assignment.py           # assignment algorithms (greedy, Hungarian, auction, SA)\n  stepping_fcts.py        # move_in_transit, perform_task, pose_update, return_to_base\n  simulation_loop.py      # simulate_mission (high-level loop)\n  post_processing.py      # RunLog, metrics, exporters, timing helpers\n  visuals/                # plotting and animation utilities\n  docs/, tests/, examples/\n</code></pre>"},{"location":"dev/architecture/#core-data-model","title":"Core data model","text":"<ul> <li>Task (base) and specializations:</li> <li><code>PointTask</code>, <code>LineTask</code>, <code>CircleTask</code>, <code>AreaTask</code> </li> <li> <p>Fields: <code>id</code>, <code>position=(x,y)</code>, <code>state</code> (0 unassigned / 1 assigned / 2 completed), optional heading enforcement, and task geometry fields.</p> </li> <li> <p>UAV</p> </li> <li> <p>Fields: <code>id</code>, <code>position=(x,y,heading)</code>, <code>speed</code>, <code>turn_radius</code> (R), <code>state</code> (0 idle / 1 transit / 2 busy / 3 damaged), <code>cluster</code> membership, <code>assigned_path</code>, <code>current_range</code>, <code>max_range</code>.</p> </li> <li> <p>Path and segments</p> </li> <li><code>Path</code> is an ordered sequence of <code>Segment</code> objects.</li> <li><code>LineSegment(start,end)</code> \u2014 straight segment.</li> <li><code>CurveSegment(center,radius,theta_s,d_theta)</code> \u2014 circular arc.</li> <li>Arc length formula:     $$     L = R \\cdot |\\Delta\\theta|.     $$</li> <li> <p>Segment parameterization (where used) is by normalized $\\(t \\in [0,1]\\)$.</p> </li> <li> <p>Event</p> </li> <li> <p>Scheduled events (NEW_TASK, UAV_DAMAGE) with <code>time</code>, <code>kind</code>, and <code>payload</code>.</p> </li> <li> <p>World</p> </li> <li>Holds <code>tasks</code>, <code>uavs</code>, <code>base</code>, <code>time</code>, <code>events</code>, tolerances, and partition sets:<ul> <li>Tasks: <code>unassigned</code>, <code>assigned</code>, <code>completed</code></li> <li>UAVs: <code>idle_uavs</code>, <code>transit_uavs</code>, <code>busy_uavs</code>, <code>damaged_uavs</code></li> </ul> </li> </ul>"},{"location":"dev/architecture/#main-runtime-flow","title":"Main runtime flow","text":"<ol> <li>Scenario generation</li> <li> <p><code>ScenarioConfig</code> \u2192 <code>generate_scenario()</code> \u2192 returns data: initial tasks, uavs, events.</p> </li> <li> <p>World initialization</p> </li> <li> <p><code>initialize_world(world, scenario)</code> populates dicts, partitions, and events.</p> </li> <li> <p>Simulation loop (<code>simulate_mission</code>)</p> </li> <li>Process scheduled events at current <code>world.time</code>.</li> <li>Optionally cluster tasks (PRBDD workflow).</li> <li>Run assignment (<code>assignment(world, algo)</code>), computing costs and committing UAV\u2192task assignments.</li> <li>Advance transit UAVs (<code>move_in_transit</code> \u2192 uses <code>pose_update</code>).</li> <li>Advance busy UAVs performing task coverage (<code>perform_task</code> \u2192 uses <code>pose_update</code>).</li> <li>Record snapshots (RunLog) for visualization/metrics.</li> <li> <p>Repeat until <code>world.done()</code> and UAVs returned to base (or abort on timeout/stall).</p> </li> <li> <p>Post\u2011processing</p> </li> <li>Compute metrics from <code>RunLog</code>: per\u2011UAV distances, state durations, task latencies, timeseries aggregates.</li> <li>Export JSON/CSV reports.</li> </ol> <p>Conceptual dataflow: - scenario \u2192 world \u2192 simulate_mission   - events \u2192 world updates   - clustering \u2192 assignment   - assignment \u2192 path planner \u2192 uav.assigned_path   - stepping \u2192 pose updates \u2192 snapshots \u2192 post_processing</p>"},{"location":"dev/architecture/#path-planning-details","title":"Path planning details","text":"<ul> <li>Planner logic for transit to a task:</li> <li>If UAV co-located and heading ok \u2192 no move.</li> <li>If straight line is feasible (heading alignment) \u2192 straight <code>LineSegment</code>.</li> <li> <p>Otherwise:</p> <ul> <li>If final heading is unconstrained: compute shortest CS (<code>cs_segments_shortest</code>).</li> <li>If final heading constrained:</li> <li>Try CS candidates that end with a straight whose heading matches target.</li> <li>Fallback to shortest CSC (<code>csc_segments_shortest</code>).</li> </ul> </li> <li> <p>Mission coverage paths per task:</p> </li> <li><code>PointTask</code> \u2192 empty path.</li> <li><code>LineTask</code> \u2192 single <code>LineSegment</code> along requested heading.</li> <li><code>CircleTask</code> \u2192 full circular sweep (<code>\u00b12\u03c0</code>) with center chosen so circle passes through task position.</li> <li><code>AreaTask</code> \u2192 boustrophedon passes with semicircular turns (turn radius = pass_spacing / 2).</li> </ul>"},{"location":"dev/architecture/#clustering-assignment","title":"Clustering &amp; assignment","text":"<ul> <li>Clustering</li> <li><code>cluster_tasks_kmeans(tasks, K)</code> performs K-means on task positions.</li> <li> <p><code>assign_clusters_to_uavs_by_proximity</code> builds squared-distance cost matrix between UAV positions and cluster centers and uses a greedy mapping.</p> </li> <li> <p>Assignment</p> </li> <li> <p><code>assignment(world, algo)</code> is the high-level driver:</p> <ul> <li>Builds cost matrix (optionally Dubins-aware using <code>plan_path_to_task</code>).</li> <li>Runs chosen algorithm:</li> <li>Greedy global (<code>greedy_global_assign_int</code>)</li> <li>Hungarian (SciPy <code>linear_sum_assignment</code>)</li> <li>Auction (\u03b5-auction)</li> <li>Simulated annealing (stochastic)</li> <li>Commits: updates <code>world</code> partitions and sets <code>uav.current_task</code>, <code>uav.assigned_path</code>, and moves UAV ids between partition sets.</li> </ul> </li> <li> <p>Cost semantics</p> </li> <li>Costs are Euclidean distances or Dubins path lengths (planner invoked per UAV-task pair); Dubins computation is costlier and a candidate for caching.</li> </ul>"},{"location":"dev/architecture/#simulation-stepping-motion-model","title":"Simulation stepping &amp; motion model","text":"<ul> <li><code>pose_update(uav, dt, atol)</code> consumes the first segment in <code>uav.assigned_path</code>:</li> <li><code>LineSegment</code>: move forward by <code>distance = uav.speed * dt</code>, interpolate along segment, clamp at end.</li> <li><code>CurveSegment</code>: compute angular advance <code>\u0394\u03b8 = distance / radius</code>, rotate the current position around the arc center by signed \u0394\u03b8, update heading, clamp at arc end.</li> <li>On segment completion, the caller pops the segment from the <code>Path</code>.</li> <li>When transit path finishes, UAV switches to busy and <code>plan_mission_path</code> creates coverage segments.</li> <li>Damage events and new tasks are handled by <code>check_for_events</code>, which updates <code>world</code> and partitions.</li> </ul>"},{"location":"dev/architecture/#visualization-postprocessing","title":"Visualization &amp; post\u2011processing","text":"<ul> <li><code>visuals.animation.animate_world</code>:</li> <li>Runs <code>simulate_mission</code> with a <code>RunLog</code> hook, then builds an animated Matplotlib visualization:<ul> <li>per\u2011UAV traces, icons, damage markers, task markers labeled <code>T{id}</code>, distance text, time title.</li> </ul> </li> <li> <p>Uses blitting for performance.</p> </li> <li> <p><code>post_processing</code>:</p> </li> <li><code>RunLog</code> captures snapshots at configurable stages (e.g., after coverage).</li> <li>Helpers compute:<ul> <li>executed distances per UAV,</li> <li>planned path lengths,</li> <li>per\u2011UAV state durations,</li> <li>per\u2011task latencies (time assigned / time completed),</li> <li>time series aggregates.</li> </ul> </li> <li>Export to JSON/CSV via <code>save_json</code> / <code>save_csv_rows</code>.</li> </ul>"},{"location":"dev/architecture/#extension-integration-points","title":"Extension &amp; integration points","text":"<ul> <li>New task types</li> <li> <p>Add a Task subclass, implement <code>plan_mission_path</code> logic, add plotting in <code>visuals.plotting_world</code>.</p> </li> <li> <p>New assignment algorithms</p> </li> <li> <p>Update <code>assignment()</code> to add new algorithm option; reuse <code>compute_cost()</code>.</p> </li> <li> <p>Performance</p> </li> <li>Cache Dubins path lengths keyed by (uav_pose, task_pose, R).</li> <li>Batch or parallelize cost computations (process pool / thread pool).</li> <li> <p>Memoize repeated planner queries.</p> </li> <li> <p>Visualization backends</p> </li> <li>Replace Matplotlib functions with Plotly/Bokeh implementations; keep <code>RunLog</code> as the stable snapshot interface.</li> </ul> <p></p> <p>Figure 1 \u2014 Module dependency diagram for Multi\u2011UAV Planner.</p>"},{"location":"dev/contributing/","title":"Contributing","text":"<p>TBD</p>"},{"location":"dev/profiling/","title":"Profiling","text":"<p>TBD</p>"},{"location":"tutorials/clustering_assignment/","title":"Clustering_Assignment","text":"<p>This tutorial shows how to:</p> <ul> <li>Cluster unassigned tasks into $ K $ spatial groups.</li> <li>Map clusters to idle UAVs by proximity (or optimally).</li> <li>Build cost matrices (Euclidean vs Dubins).</li> <li>Run different assignment strategies and update the world.</li> <li>Integrate clustering and assignment into the simulation loop.</li> </ul> <p>Prerequisites:</p> <ul> <li>Python 3.10+</li> <li>numpy, scikit-learn (for KMeans), SciPy (for Hungarian), matplotlib (optional for plots)</li> </ul>"},{"location":"tutorials/clustering_assignment/#1-why-clustering","title":"1) Why clustering?","text":"<p>Clustering is a preprocessing step that reduces the decision space by grouping nearby tasks and assigning each cluster to a distinct idle UAV. Benefits:</p> <p>Shrinks the per-UAV candidate set (faster assignment). Encourages spatial differentiation, which reduces crossing or overlapping paths (shorter total distance). Enables \u201clocal\u201d Dubins-aware costs within clusters (near-optimal in many spatial distributions).</p>"},{"location":"tutorials/clustering_assignment/#2-task-clustering-kmeans","title":"2) Task clustering: KMeans","text":"<p>Given:</p> <ul> <li>\\(U_{idle}\\) : set of idle UAV ids,</li> <li>$T_{unassigned}: set of unassigned task ids,</li> <li>Positions $X\\inR^{N\\times 2} with \\(X_i=(x_i,y_i)\\),</li> </ul> <p>Choose the number of clusters: - $ K = \\min(#U_{idle}, #T_{unassigned}) $ (ensure \\(K\\leq N\\)).</p> <p>Run KMeans:</p> <ul> <li>Labels $l_i{0,\\dots,K-1},</li> <li>Centers $ C_k = (c_k^x,c_k^y) $.</li> </ul> <p>Map clusters to UAVs:</p> <p>Build cost  cost   (squared Euclidean), Assign clusters to distinct UAVs (greedy or Hungarian), Update each UAV: u.cluster = {task ids with label == k}, u.cluster_CoG = (c^x_k, c^y_k). Minimal example:</p> <p>python from multi_uav_planner.world_models import World from multi_uav_planner.clustering import cluster_tasks</p>"},{"location":"tutorials/clustering_assignment/#world-initialized-with-tasksuavs-some-idle-uavs-and-unassigned-tasks-present","title":"World initialized with tasks/UAVs, some idle UAVs and unassigned tasks present","text":"<p>cluster_map = cluster_tasks(world) if cluster_map is None:     print(\"No clustering performed.\") else:     for uid, task_ids in cluster_map.items():         print(f\"UAV {uid}: cluster size={len(task_ids)}, CoG={world.uavs[uid].cluster_CoG}\") 3) Dynamic behaviors (events) New tasks:</p> <p>Attach the new task to the nearest cluster center (or nearest UAV\u2019s cluster center if no cluster). Update u.cluster and recompute u.cluster_CoG as the average of task positions. UAV damage:</p> <p>Empty the damaged UAV\u2019s cluster (if any) and reassign each task to the closest remaining UAV cluster center. Clear u.cluster_CoG for the damaged UAV. These behaviors are implemented in the event handlers and keep clusters consistent as the mission evolves.</p>"},{"location":"tutorials/clustering_assignment/#4-cost-models","title":"4) Cost models","text":"<p>Two options for the assignment cost $C_{i,j}:</p> <ul> <li>Euclidean (fast): $C_{i,j} = \\sqrt{(xj-xi)^2+(y_j-y_i)^2}.</li> <li>Dubins path length (kinematic): \\(C_{i,j}=\\)   is the shortest feasible transit path length (straight/CS/CSC given UAV turn radius and entry heading constraints).</li> </ul> <p>In code:</p>"},{"location":"tutorials/clustering_assignment/#from-multi_uav_plannerassignment-import-compute_cost-c-u_list-t_list-u_idx-t_idx-compute_costworld-worldidle_uavs-worldunassigned-use_dubinsfalse-or-true","title":"<pre><code>from multi_uav_planner.assignment import compute_cost\n\nC, u_list, t_list, u_idx, t_idx = compute_cost(world, world.idle_uavs, world.unassigned, use_dubins=False)  # or True\n</code></pre>","text":"<p>5) Assignment methods (overview) - GBA (Greedy): fast, simple; may be far from optimal. - HBA (Hungarian): globally optimal on the given cost matrix; heavier but robust. - AA (Auction): scalable, tunable accuracy vs speed; approximate optimality. - SA (Simulated Annealing): heuristic; can reach good solutions with time; slower. - RBDDG: global assignment using Dubins-aware costs; robust, moderate speed. - PRBDDG: cluster-first, then local greedy with Dubins-aware costs; near-optimal and fast in many spatial distributions.</p> <p>6) Running an assignment step One-shot assignment outside the full loop:</p> <p><pre><code>from multi_uav_planner.assignment import compute_cost, hungarian_assign\n\nu_ids = world.idle_uavs\nt_ids = world.unassigned\n\n# Choose cost model\nC, u_list, t_list, u_idx, t_idx = compute_cost(world, u_ids, t_ids, use_dubins=False)\n\nmatch = hungarian_assign(C, unassigned_value=-1)\nuid_to_tid = {}\nfor i, j in enumerate(match):\n    if j != -1:\n        uid_to_tid[u_list[i]] = t_list[j]\n\nprint(\"Assignments:\", uid_to_tid)\n# Apply results to the world if desired (move UAVs to transit, plan paths, etc.)\n</code></pre> Within the simulation loop:</p>"},{"location":"tutorials/clustering_assignment/#from-multi_uav_plannerscenario_generation-import-scenarioconfig-scenariotype-algorithmtype-generate_scenario-from-multi_uav_plannerworld_models-import-world-from-multi_uav_plannersimulation_loop-import-simulate_mission-cfg-scenarioconfigbase000-area_width2500-area_height2500-n_uavs4-n_tasks20-scenario_typescenariotypenone-alg_typealgorithmtypeprbdd-seed7-scenario-generate_scenariocfg-world-worldtasks-uavs-simulate_missionworld-scenario-dt03-max_time1e5-printdone-worlddone-at_base-worldat_base","title":"<pre><code>from multi_uav_planner.scenario_generation import ScenarioConfig, ScenarioType, AlgorithmType, generate_scenario\nfrom multi_uav_planner.world_models import World\nfrom multi_uav_planner.simulation_loop import simulate_mission\n\ncfg = ScenarioConfig(base=(0,0,0), area_width=2500, area_height=2500,\n                     n_uavs=4, n_tasks=20, scenario_type=ScenarioType.NONE,\n                     alg_type=AlgorithmType.PRBDD, seed=7)\nscenario = generate_scenario(cfg)\n\nworld = World(tasks={}, uavs={})\nsimulate_mission(world, scenario, dt=0.3, max_time=1e5)\nprint(\"done:\", world.done(), \"at_base:\", world.at_base())\n</code></pre>","text":""},{"location":"tutorials/clustering_assignment/#7-integration-policy-prbddg-vs-rbddg-vs-others","title":"7) Integration policy (PRBDDG vs RBDDG vs others)","text":"<p>PRBDDG (cluster-first):</p> <ul> <li>At init (or when idle UAVs exist), cluster tasks and compute centers.</li> <li>For each idle UAV, restrict candidate tasks to its cluster and assign locally (greedy) with Dubins-aware costs.</li> <li>Move UAVs to transit, optionally plan Dubins-aware transit paths immediately.</li> </ul> <p>RBDDG (global Dubins-aware):</p> <ul> <li>Use Dubins distances in the global cost matrix.</li> <li>After assignment, plan Dubins-aware transit paths immediately.</li> </ul> <p>GBA / HBA / AA / SA (default demos):</p> <ul> <li>Often use Euclidean costs for speed.</li> <li>After assignment, some demos use straight-line transit; switch to Dubins-aware transit (plan_path_to_task) for kinematic fidelity.</li> </ul>"},{"location":"tutorials/clustering_assignment/#8-rectangular-matrices","title":"8) Rectangular matrices","text":"<ul> <li>Hungarian handles rectangular matrices natively (workers \\(n\\), tasks \\(m\\)).</li> <li>Greedy and Auction handle \\(m&lt;n\\) via unassigned markers or dummy padding:<ul> <li>Greedy returns \\(\u22121\\) for unassigned workers.</li> <li>Auction pads with high-cost dummy tasks; workers mapped to dummy return \\(-1\\).</li> </ul> </li> <li>Expect idle UAVs when \\(m&lt;n\\); they may remain idle or return to base.</li> </ul>"},{"location":"tutorials/clustering_assignment/#9-validation-checklist","title":"9) Validation checklist","text":"<ul> <li>$K = \\min(#U_{idle},#T_{unassigned}) and \\(K\\leq N\\).</li> <li>KMeans input shape \\(N\\times 2\\); valid centers \\(C_k\\) returned.</li> <li>Cluster\u2192UAV mapping uses distinct UAVs and distinct clusters (no reuse).</li> <li>Cost matrix matches intended model (Euclidean/Dubins).</li> <li>Assignment respects one-to-one mapping; world updates consistent:<ul> <li>Task ids move \\(unassigned\u2192assigned\u2192completed\\).</li> <li>UAV state changes: \\(idle\u2192transit\u2192busy\u2192idle\\).</li> </ul> </li> </ul>"},{"location":"tutorials/clustering_assignment/#10-common-pitfalls","title":"10) Common pitfalls","text":"<ul> <li>\\(K&gt;N\\) (more clusters than tasks): KMeans fails; enforce \\(K\\leq N\\).</li> <li>Mismatch: cluster count not equal to number of idle UAVs (for simple proximity mapper); use Hungarian to handle non-square mappings if needed.</li> <li>Using Euclidean costs where heading/turn radius dominate: assignments can look \u201cshort\u201d but be kinematically inefficient; prefer Dubins-aware costs for final evaluations.</li> <li>Forgetting to update <code>cluster_CoG</code> after dynamic changes (NEW_TASK, UAV_DAMAGE) degrades proximity decisions.</li> </ul>"},{"location":"tutorials/clustering_assignment/#11-exercises","title":"11) Exercises","text":"<ul> <li>Cluster tasks for different seeds and visualize centers; compare two cluster\u2192UAV assignment rules (greedy vs Hungarian).</li> <li>Switch compute_cost(..., use_dubins=True) and compare assignments (GBA vs HBA) versus Euclidean costs.</li> <li>Measure end-to-end total distance and planning time across methods (PRBDDG, RBDDG, GBA, HBA, AA, SA) for 10 scenarios, as in the paper\u2019s Figures 7 and 9.</li> </ul>"},{"location":"tutorials/clustering_assignment/#12-references-and-implementation","title":"12) References and implementation","text":"<ul> <li>Clustering:<ul> <li><code>src/multi_uav_planner/clustering.py</code> (KMeans, cluster\u2192UAV mapping, high-level pipeline)</li> </ul> </li> <li>Assignment:<ul> <li><code>src/multi_uav_planner/assignment.py</code> (compute_cost, GBA/HBA/AA/SA, PRBDDG/RBDDG integration)</li> </ul> </li> <li>Transit planning:<ul> <li><code>src/multi_uav_planner/path_planner.py</code> (<code>plan_path_to_task</code> for Dubins-aware transit)</li> </ul> </li> <li>Events:<ul> <li><code>src/multi_uav_planner/events.py</code> (NEW_TASK attachment, UAV_DAMAGE redistribution)</li> </ul> </li> </ul>"},{"location":"tutorials/full_mission/","title":"Full_Mission","text":"<p>TBD</p>"},{"location":"tutorials/path_model_and_dubins/","title":"Path_Model_And_Dubins","text":"<p>This tutorial introduces the path primitives used throughout the project and shows how to construct and visualize Dubins paths. You will:</p> <ul> <li>Build line and arc segments and compose them into a path.</li> <li>Sample points along segments and compute lengths.</li> <li>Construct CS and CSC Dubins paths, check feasibility, and select the shortest.</li> <li>Plot paths and compare candidate Dubins types.</li> </ul> <p>Prerequisites:</p> <ul> <li>Python 3.10+</li> <li>matplotlib for plotting</li> <li>numpy (optional, used by some helpers)</li> </ul> <p>Optional plotting helpers reside in the visuals folder:</p> <p>visuals/plotting_dubins.py (for segment and path visualization and Dubins-specific plotting)</p>"},{"location":"tutorials/path_model_and_dubins/#1-path-primitives","title":"1) Path Primitives","text":"<p>The path model defines three core types:</p> <p>Segment interface (Segment) Straight segment (LineSegment) Circular arc segment (CurveSegment) Sequence of segments (Path) Key formulas:</p> <ul> <li>Line length: $$ L_S = \\sqrt{(x_2-x_1)^2+(y_2-y_1)^2} $$.</li> <li>Arc length: $$ L_C = R \\cdot \\Delta\\theta $$.</li> </ul> <p>Minimal usage: <pre><code>from multi_uav_planner.path_model import LineSegment, CurveSegment, Path\nfrom math import pi\n\n# Build a line from (0,0) to (120,40)\nline = LineSegment((0.0, 0.0), (120.0, 40.0))\n\n# Build a quarter-circle arc of radius 30 centered at (100,40)\narc  = CurveSegment(center=(100.0, 40.0), radius=30.0, theta_s=pi, d_theta=pi/2)\n\n# Compose into a path\npath = Path([line, arc])\n\nprint(\"Line length:\", line.length())\nprint(\"Arc length:\", arc.length())\nprint(\"Total path length:\", path.length())\n\n# Sample points along the path (uniformly per segment)\npts = path.sample(samples_per_segment=50)\nprint(\"Number of sampled points:\", len(pts))\n</code></pre></p> <p>Notes:  - <code>CurveSegment.theta_s</code> is the angle (radians) from the center to the segment\u2019s start point. - <code>CurveSegment.d_theta</code> is the signed sweep: positive counterclockwise, negative clockwise. - <code>Path.sample</code> concatenates samples per segment and removes the duplicated junction point between adjacent segments.</p>"},{"location":"tutorials/path_model_and_dubins/#2-plotting-path-primitives","title":"2) Plotting path primitives","text":"<p>Use the plotting helpers to visualize lines and arcs with direction arrows and optional circle centers.  <pre><code>import matplotlib.pyplot as plt\nfrom visuals.plotting import plot_path, PlotStyle, finalize_axes\nfrom multi_uav_planner.path_model import LineSegment, CurveSegment, Path\nfrom math import pi\n\nline = LineSegment((0, 0), (120, 40))\narc  = CurveSegment(center=(100, 40), radius=30, theta_s=pi, d_theta=pi/2)\npath = Path([line, arc])\n\nfig, ax = plt.subplots(figsize=(7, 7))\nstyle = PlotStyle(show_centers=True, arrow_every=15, arrow_scale=0.8)\nplot_path(ax, path, style)\nfinalize_axes(ax, \"Path primitives (Line + Arc)\")\nplt.show()\n</code></pre></p> <p>Style options (selected):</p> <ul> <li><code>show_centers</code>: draw arc centers</li> <li><code>arrow_every</code>: arrow cadence along segments</li> <li><code>arrow_scale</code>: arrow size</li> <li><code>linewidth</code>, <code>line_color</code>, <code>arc_color</code>: appearance overrides</li> </ul>"},{"location":"tutorials/path_model_and_dubins/#3-dubins-paths-cs-and-csc","title":"3) Dubins paths (CS and CSC)","text":"<p>Dubins paths satisfy a fixed minimum turn radius $ R $ and heading constraints and consist of straight ($ S \\() and circular (\\) C $) segments.</p> <p>Families:</p> <ul> <li>CS: one arc then straight ($ LS \\(,\\) RS $)</li> <li>CSC: two arcs with an intermediate straight ($ LSL \\(,\\) LSR \\(,\\) RSL \\(,\\) RSR $)</li> </ul> <p>Feasibility conditions:</p> <ul> <li>CS to a point: let $ d $ be the distance from the start-circle center to the target point, then CS exists iff: $ d \\geq R $.</li> <li>CSC (inner tangents): let $ d $ be the distance between start and end circle centers, then inner tangents ($ LSR \\(,\\) RSL $) exist iff: $ \\frac{2R}{d}\\leq 1 $.</li> </ul> <p>Construct CS shortest: <pre><code>from math import pi\nfrom multi_uav_planner.dubins import cs_segments_shortest\n\nstart = (50.0, 50.0, pi/6)  # (x0, y0, theta0)\nend   = (220.0, 80.0)       # (xf, yf)\nR     = 40.0\n\npath_cs = cs_segments_shortest(start, end, R)\nprint(\"CS length:\", path_cs.length())\n</code></pre></p> <p>Construct CSC shortest: <pre><code>from math import pi\nfrom multi_uav_planner.dubins import csc_segments_shortest\n\nstart = (40.0, 40.0, pi/3)     # (x0, y0, theta0)\nend   = (250.0, 140.0, -pi/6)  # (xf, yf, thetaf)\nR     = 50.0\n\npath_csc = csc_segments_shortest(start, end, R)\nprint(\"CSC length:\", path_csc.length())\n</code></pre></p>"},{"location":"tutorials/path_model_and_dubins/#4-plotting-dubins-candidates-and-highlighting-shortest","title":"4) Plotting Dubins candidates and highlighting shortest","text":"<p>Compare all feasible CS or CSC types and highlight the shortest in bold. <pre><code>import matplotlib.pyplot as plt\nfrom math import pi\nfrom multi_uav_planner.dubins import (\n    cs_segments_single, cs_segments_shortest,\n    csc_segments_single, csc_segments_shortest\n)\nfrom visuals.plotting import plot_path, PlotStyle, finalize_axes\n\n# CS comparison\nstart_cs = (50.0, 50.0, pi/6)\nend_cs   = (220.0, 80.0)\nR_cs     = 40.0\n\ncandidates_cs = {\n    \"LS\": cs_segments_single(start_cs, end_cs, R_cs, \"LS\"),\n    \"RS\": cs_segments_single(start_cs, end_cs, R_cs, \"RS\"),\n}\nbest_cs = cs_segments_shortest(start_cs, end_cs, R_cs)\n\nfig, ax = plt.subplots(figsize=(8, 6))\nfor name, p in candidates_cs.items():\n    if p:  # only plot feasible\n        plot_path(ax, p, PlotStyle(line_color=\"C1\", arc_color=\"C1\", show_centers=True))\n# bold shortest\nplot_path(ax, best_cs, PlotStyle(line_color=\"k\", arc_color=\"k\", linewidth=2.8, show_centers=False))\nfinalize_axes(ax, \"Dubins CS candidates (shortest in bold)\")\nplt.show()\n</code></pre></p> <p>CSC comparison: <pre><code>start_csc = (40.0, 40.0, pi/3)\nend_csc   = (250.0, 140.0, -pi/6)\nR_csc     = 50.0\n\ncandidates_csc = {\n    \"LSL\": csc_segments_single(start_csc, end_csc, R_csc, \"LSL\"),\n    \"LSR\": csc_segments_single(start_csc, end_csc, R_csc, \"LSR\"),\n    \"RSL\": csc_segments_single(start_csc, end_csc, R_csc, \"RSL\"),\n    \"RSR\": csc_segments_single(start_csc, end_csc, R_csc, \"RSR\"),\n}\nbest_csc = csc_segments_shortest(start_csc, end_csc, R_csc)\n\nfig, ax = plt.subplots(figsize=(8, 7))\nfor name, p in candidates_csc.items():\n    if p:\n        plot_path(ax, p, PlotStyle(line_color=\"C2\", arc_color=\"C2\", show_centers=True))\nplot_path(ax, best_csc, PlotStyle(line_color=\"k\", arc_color=\"k\", linewidth=2.8, show_centers=False))\nfinalize_axes(ax, \"Dubins CSC candidates (shortest in bold)\")\nplt.show()\n</code></pre></p>"},{"location":"tutorials/path_model_and_dubins/#5-straight-line-feasibility-checks","title":"5) Straight-line feasibility checks","text":"<p>A straight segment is valid when headings align with the line direction within tolerance, either for unconstrained (only start) or constrained entries (both start and end).</p> <p>Heading alignment:</p> <ul> <li>Line direction: $ \\theta_{line}=\\text{atan2}(y_f-y_0, x_f-x_0) $.</li> <li>Wrap-aware difference: $ \\text{ang_diff}(a,b)=((a\u2212b+\\pi)\\text{mod}2\\pi)\u2212\\pi $.</li> </ul> <p>Example check: <pre><code>import math\n\ndef straight_feasible(start, end, theta_end_or_none, ang_tol):\n    x0, y0, th0 = start\n    xf, yf = end\n    theta_line = math.atan2(yf - y0, xf - x0)\n    if theta_end_or_none is None:\n        return abs(((th0 - theta_line + math.pi) % (2*math.pi)) - math.pi) &lt;= ang_tol\n    else:\n        thf = theta_end_or_none\n        return (\n            abs(((th0 - theta_line + math.pi) % (2*math.pi)) - math.pi) &lt;= ang_tol\n            and abs(((thf - theta_line + math.pi) % (2*math.pi)) - math.pi) &lt;= ang_tol\n        )\n\nprint(straight_feasible((0,0,0.0), (10,0), None, ang_tol=1e-3))  # True if heading ~ 0\n</code></pre></p>"},{"location":"tutorials/path_model_and_dubins/#6-integration-policy-transit-path-selection","title":"6) Integration policy (transit path selection)","text":"<p>The planner (<code>path_plan_to_task</code>) applies the following policy:</p> <ul> <li>If co-located within position tolerance:<ul> <li>If entry heading unconstrained or matches within angle tolerance, return an empty path.</li> <li>Otherwise, use CSC to correct heading in place.</li> </ul> </li> <li>Unconstrained entry:<ul> <li>If straight-line heading matches within tolerance, use a straight segment.</li> <li>Else, use CS shortest.</li> </ul> </li> <li>Constrained entry:<ul> <li>If both start and end headings align to the line within tolerance, use a straight segment.</li> <li>Else, try CS and keep only those whose final straight heading matches the required entry heading; if none remain, use CSC shortest.</li> </ul> </li> </ul> <p>Minimal usage: <pre><code>from math import pi\nfrom multi_uav_planner.world_models import World, UAV\nfrom multi_uav_planner.path_planner import plan_path_to_task\n\nworld = World(tasks={}, uavs={}, base=(0,0,0))\nworld.uavs[1] = UAV(id=1, position=(50.0, 50.0, pi/6), turn_radius=60.0)\n\n# Unconstrained entry\np1 = plan_path_to_task(world, 1, (220.0, 120.0, None))\nprint(\"Transit length (unconstrained):\", p1.length())\n\n# Constrained entry (due east)\np2 = plan_path_to_task(world, 1, (220.0, 120.0, 0.0))\nprint(\"Transit length (constrained):\", p2.length())\n</code></pre></p>"},{"location":"tutorials/path_model_and_dubins/#7-continuity-and-validation","title":"7) Continuity and validation","text":"<p>Junction continuity:</p> <ul> <li>Position continuity at segment boundaries within positional tolerance.</li> <li>Tangent continuity at arc\u2192line transitions:<ul> <li>The line heading equals the arc tangent at the junction within angular tolerance.</li> </ul> </li> </ul> <p>Length correctness: - For a path with segments $ {s_i}: L = \\sum_i , L_S = \\sqrt{\\Delta x^2+\\Delta y^2}, L_C=R \\cdot |\\theta|. </p>"},{"location":"tutorials/path_model_and_dubins/#8-common-pitfalls","title":"8) Common pitfalls","text":"<ul> <li>Failing CS feasibility check $ d \\geq R $.</li> <li>Inner CSC types used when $ \\frac{2R}{d}&gt;1 $ (infeasible).</li> <li>Forgetting to normalize angles before computing signed sweeps.</li> <li>Comparing headings without wrap-aware difference (use $ ang_diff $).</li> </ul>"},{"location":"tutorials/path_model_and_dubins/#9-exercises","title":"9) Exercises","text":"<ul> <li>Plot LS and RS for multiple start headings with a fixed target and radius; compare lengths.</li> <li>Sweep $ R $ from small to large and record CS shortest length; note feasibility changes when $ d &lt; R $.</li> <li>Sweep $ \\theta_f $ for CSC and record shortest path length; visualize the curve $ L(\\theta_f) $.</li> <li>Validate junction continuity numerically for random CS/CSC candidates.</li> </ul>"},{"location":"tutorials/path_model_and_dubins/#references-and-implementation","title":"References and implementation","text":"<ul> <li><code>src/multi_uav_planner/path_model.py</code>: segments and path composition</li> <li><code>src/multi_uav_planner/dubins.py</code>: CS/CSC constructors and shortest selection</li> <li><code>src/multi_uav_planner/path_planner.py</code>: transit selection policy Classic reference: Dubins, L. E. (1957), \u201cOn curves of minimal length with a constraint on average curvature, and with prescribed initial and terminal positions and tangents.\u201d American Journal of Mathematics.</li> </ul>"},{"location":"user-guide/plotting/","title":"Plotting","text":"<p>TBD</p>"},{"location":"user-guide/scenarios/","title":"User Guide \u00b7 Scenarios","text":"<p>This page explains how to configure, generate, and inspect mission scenarios. Scenarios define the mission area, UAV fleet, task mix, and optional runtime events (new tasks, UAV damage). They are reproducible via a single seed and can be used directly with the simulation loop.</p>"},{"location":"user-guide/scenarios/#what-is-a-scenario","title":"What is a Scenario?","text":"<p>A Scenario bundles: - Mission geometry: area width/height and base pose - Fleet configuration: number of UAVs and their kinematics (speed, turn radius, range) - Task set: a random mix of Point/Line/Circle/Area tasks - Events: optional NEW_TASK and UAV_DAMAGE arrivals over time - Algorithm choice: assignment/planning strategy selector</p> <p>You primarily interact with: - <code>ScenarioConfig</code> \u2014 declarative configuration - <code>generate_scenario(cfg)</code> \u2014 deterministic generator - <code>Scenario</code> \u2014 the resulting object (tasks, uavs, base, events, alg_type) - <code>initialize_world(world, scenario)</code> \u2014 load into <code>World</code></p>"},{"location":"user-guide/scenarios/#scenarioconfig-fields-and-semantics","title":"ScenarioConfig \u00b7 Fields and Semantics","text":"<p>Core geometry - <code>base: (x, y, heading)</code> \u2014 swarm start pose - <code>area_width</code>, <code>area_height</code> \u2014 rectangular mission bounds (meters)</p> <p>Fleet - <code>n_uavs</code> \u2014 number of UAVs - <code>uav_speed</code> \u2014 meters/second - <code>turn_radius</code> \u2014 minimum turn radius - <code>max_range</code> \u2014 per-UAV distance budget; tracked as <code>current_range</code> during simulation</p> <p>Task mix - <code>n_tasks</code> \u2014 number of initial tasks - Probabilities for task types:   - <code>p_point</code>, <code>p_line</code>, <code>p_circle</code>, <code>p_area</code>   - Must satisfy $\\(p_\\text{point} + p_\\text{line} + p_\\text{circle} + p_\\text{area} = 1\\)$</p> <p>Events (optional dynamics) - <code>scenario_type: NONE | NEW_TASKS | UAV_DAMAGE | BOTH</code> - New tasks:   - <code>n_new_task</code>, <code>ts_new_task</code>, <code>tf_new_task</code> \u2014 number and time window - Damage:   - <code>n_damage</code>, <code>ts_damage</code> \u2014 number and earliest time   - Constraint: $\\(n_\\text{damage} &lt; n_\\text{uavs}\\)$</p> <p>Algorithm - <code>alg_type</code> \u2014 selects assignment/planning approach (e.g., <code>PRBDD</code>, <code>HBA</code>, etc.)</p> <p>Reproducibility - <code>seed</code> \u2014 fixed seed for all random draws</p>"},{"location":"user-guide/scenarios/#creating-a-scenario","title":"Creating a Scenario","text":"<p>Minimal example: <pre><code>from multi_uav_planner.scenario_generation import ScenarioConfig, generate_scenario, AlgorithmType, ScenarioType\n\ncfg = ScenarioConfig(\n    base=(0.0, 0.0, 0.0),\n    area_width=300.0, area_height=250.0,\n    n_uavs=3, n_tasks=20,\n    p_point=0.6, p_line=0.2, p_circle=0.1, p_area=0.1,\n    scenario_type=ScenarioType.BOTH,\n    n_new_task=5, ts_new_task=10.0, tf_new_task=120.0,\n    n_damage=2, ts_damage=30.0,\n    alg_type=AlgorithmType.PRBDD,\n    seed=42\n)\n\nscenario = generate_scenario(cfg)\n</code></pre></p>"},{"location":"user-guide/scenarios/#load-into-a-world","title":"Load into a world:","text":"<pre><code>from multi_uav_planner.world_models import World\nfrom multi_uav_planner.scenario_generation import initialize_world\n\nworld = World(tasks={}, uavs={})\ninitialize_world(world, scenario)\n</code></pre>"},{"location":"user-guide/scenarios/#task-types-geometry-defaults","title":"Task Types \u00b7 Geometry Defaults","text":"<ul> <li>PointTask</li> <li>Position: uniform in area</li> <li>Heading: optional (30% constrained in default generator)</li> <li>Intrinsic length: $\\(0\\)$</li> <li>LineTask</li> <li>Length: random in a configured range</li> <li>Coverage segment aligned with heading</li> <li>Intrinsic length: $\\(L\\)$</li> <li>CircleTask</li> <li>Radius: random in a configured range</li> <li>Side: <code>left or right</code> \u21d2 sweep $\\(\\pm 2\\pi\\)$</li> <li>Intrinsic length: $\\(2\\pi R\\)$</li> <li>AreaTask</li> <li>Zigzag passes: <code>num_passes</code>, <code>pass_length</code>, <code>pass_spacing</code>, first turn <code>side</code></li> <li>Approx coverage (without min-turn adjustment): $\\(N \\cdot L + (N - 1) \\cdot \\pi \\cdot \\frac{S}{2}\\)$</li> </ul> <p>Note: Actual mission path length depends on UAV minimum turn radius and may exceed intrinsic approximations.</p>"},{"location":"user-guide/scenarios/#events-behavior","title":"Events \u00b7 Behavior","text":"<ul> <li>NEW_TASK</li> <li>Arrives uniformly in $\\([t_s, t_f]\\)$</li> <li>Payload is a list with at least one <code>Task</code></li> <li>Inserted into <code>world.unassigned</code>; if clustering is active, task may be placed into nearest cluster</li> <li>UAV_DAMAGE</li> <li>Occurs uniformly in $\\([t_s, \\text{max\\_time}]\\)$</li> <li>Marks UAV as damaged, cancels its current assignment, and returns its task(s) to <code>unassigned</code></li> </ul> <p>Ordering - Events are sorted deterministically by <code>(time, kind, id)</code> given the <code>seed</code>.</p>"},{"location":"user-guide/scenarios/#algorithm-choice","title":"Algorithm Choice","text":"<p>Set via <code>cfg.alg_type</code>. Examples: - <code>PRBDD</code>: cluster-first greedy per UAV (proximity to cluster centers) - <code>HBA</code>: Hungarian (global optimal on a given cost matrix) - <code>GBA</code> or <code>RBDD</code>: greedy variants (global/nearest)</p> <p>Assignment cost can be Euclidean or Dubins path length, depending on planner use.</p>"},{"location":"user-guide/scenarios/#reproducibility-tips","title":"Reproducibility Tips","text":"<ul> <li>Fix <code>seed</code> in <code>ScenarioConfig</code> to reproduce task positions, headings, and event times.</li> <li>Keep code versions consistent; changes to sampling ranges or logic alter outcomes.</li> <li>For experiments, store <code>{ScenarioConfig and seed}</code> alongside logs/metrics.</li> </ul>"},{"location":"user-guide/scenarios/#visualizing-scenarios-optional","title":"Visualizing Scenarios (Optional)","text":"<p>Use plotting helpers in <code>visuals/scenario_plotting.py</code> (kept separate from core):</p> <pre><code>import matplotlib.pyplot as plt\nfrom visuals.scenario_plotting import plot_scenario_overview\n\nfig, ax = plt.subplots(figsize=(8,6))\nplot_scenario_overview(ax, scenario, title=\"Scenario Overview\")\nplt.show()\n</code></pre> <p>To inspect event timing:</p> <pre><code>from visuals.events_plotting import plot_event_timeline\nplot_event_timeline(plt.gca(), scenario.events, title=\"Events Timeline\")\n</code></pre>"},{"location":"user-guide/scenarios/#common-pitfalls-checks","title":"Common Pitfalls &amp; Checks","text":"<ul> <li>Probabilities must sum to $\\(1\\)$; otherwise the last branch absorbs the remainder.</li> <li>Damage count must satisfy $\\(n_\\text{damage} &lt; n_\\text{uavs}\\)$.</li> <li>Always initialize a <code>World</code> with <code>initialize_world(world, scenario)</code> before simulation.</li> <li>If using cluster-based assignment, ensure clustering is run before assignment (PRBDD does this automatically at simulation init).</li> </ul>"},{"location":"user-guide/scenarios/#advanced-custom-generators","title":"Advanced: Custom Generators","text":"<p>You can supply your own task generator for specific distributions.</p> <pre><code>from multi_uav_planner.world_models import PointTask\n\ndef make_custom_tasks(cfg, n=20):\n    tasks = []\n    for i in range(n):\n        x = 0.5 * cfg.area_width + 0.5 * cfg.area_width * i / n\n        y = cfg.area_height * (i % 10) / 10.0\n        tasks.append(PointTask(id=i+1, position=(x, y), state=0))\n    return tasks\n</code></pre> <p>Then construct a <code>Scenario</code> using your lists and pass it to <code>initialize_world</code>.</p>"},{"location":"user-guide/simulation/","title":"User Guide \u00b7 Simulation","text":"<p>This page documents the mission simulation loop: stages, stopping conditions, configuration knobs, and how to record metrics via hooks. You\u2019ll also find minimal recipes to run, log, and analyze simulations.</p>"},{"location":"user-guide/simulation/#overview","title":"Overview","text":"<p>The simulator advances a shared world state through discrete timesteps of size $\\(dt\\)$. At each step, it:</p> <p>1) Triggers any scheduled events (new tasks, UAV damage). 2) Assigns available UAVs to tasks using the selected algorithm. 3) Moves UAVs in transit toward task entry points. 4) Executes task coverage (mission paths). 5) Advances simulation time. 6) Plans the return to base when all tasks are completed.</p> <p>Entry points: - Function: <code>simulate_mission(world, scenario, dt=..., max_time=..., on_step=...)</code> - World model: <code>multi_uav_planner.world_models.World</code> - Scenario: <code>multi_uav_planner.scenario_generation.Scenario</code></p>"},{"location":"user-guide/simulation/#loop-stages","title":"Loop stages","text":"<p>The simulator calls the optional <code>on_step(world, stage)</code> hook at well-defined moments:</p> <ul> <li><code>init</code>: after <code>initialize_world</code> and optional clustering (for $\\(\\text{PRBDD}\\)$).</li> <li><code>triggering_events</code>: after handling NEW_TASK/UAV_DAMAGE events at the current time.</li> <li><code>assignment</code>: after running one assignment step (if any idle UAVs and unassigned tasks).</li> <li><code>after_move</code>: after moving in-transit UAVs for the tick.</li> <li><code>end_tick (post_coverage)</code>: after coverage and time advancement.</li> <li><code>planned_return</code>: when planning the return to base (once all tasks complete).</li> </ul> <p>Use these stages to log snapshots consistently.</p>"},{"location":"user-guide/simulation/#initialization","title":"Initialization","text":"<ul> <li>If <code>world.is_initialized()</code> is $\\(\\text{False}\\)$, the simulator:</li> <li>Builds a default or provided <code>Scenario</code> via <code>generate_scenario</code>.</li> <li>Loads it with <code>initialize_world(world, scenario)</code>.</li> <li>If <code>scenario.alg_type</code> is $\\(\\text{PRBDD}\\)$, calls <code>cluster_tasks(world)</code> once at start.</li> <li>Calls <code>on_step(world, \"init\")</code>.</li> </ul> <p>World invariants (validated in <code>is_initialized</code>): - Task sets partition: $\\(\\text{unassigned} \\cup \\text{assigned} \\cup \\text{completed} = \\{\\text{all task ids}\\}\\)$ and are pairwise disjoint. - UAV sets partition: $\\(\\text{idle\\_uavs} \\cup \\text{transit\\_uavs} \\cup \\text{busy\\_uavs} \\cup \\text{damaged\\_uavs} = \\{\\text{all uav ids}\\}\\)$ and are pairwise disjoint. - Base pose is a 3\u2011tuple $\\(\\left(x, y, \\theta\\right)\\)$.</p>"},{"location":"user-guide/simulation/#main-loop-per-tick","title":"Main loop (per tick)","text":"<p>Pseudocode (high level):</p> <pre><code>stall = 0\nwhile not world.done() or not world.at_base():\n    check_for_events(world, clustering=(scenario.alg_type is AlgorithmType.PRBDD))\n    on_step(world, \"triggering_events\")\n\n    if world.idle_uavs and world.unassigned:\n        assignment(world, scenario.alg_type)\n    on_step(world, \"assignment\")\n\n    transit_moved = move_in_transit(world, dt)\n    on_step(world, \"after_move\")\n\n    mission_moved = perform_task(world, dt)\n\n    if not (transit_moved or mission_moved):\n        stall += 1\n        if stall &gt;= N_stall: break\n    else:\n        stall = 0\n\n    world.time += dt\n    on_step(world, \"end_tick (post_coverage)\")\n\n    if world.time &gt; max_time: break\n    if world.done() and not world.at_base() and not world.transit_uavs and not world.busy_uavs:\n        return_to_base(world, use_dubins=(scenario.alg_type in {AlgorithmType.PRBDD, AlgorithmType.RBDD}))\n        on_step(world, \"planned_return\")\n</code></pre> <p>Notes: - Events:   - NEW_TASK inserts new tasks; if clustering is active (PRBDD), tasks are assigned to the nearest cluster center.   - UAV_DAMAGE marks a UAV as damaged, clears its path, returns its task to unassigned, and updates clusters (PRBDD). - Assignment:   - Controlled by scenario.alg_type: $\\(\\text{GBA}, \\text{HBA}, \\text{AA}, \\text{RBDDG}, \\text{PRBDDG}, \\text{SA}\\)$. - Motion:   - Transit: shortest feasible straight/CS/CSC path to task entry.   - Mission: coverage path per task (line, circle, or area zig\u2011zag). - Stall detection:   - If no movement for $\\(N_\\text{stall}\\)$ consecutive ticks, the simulation aborts to prevent deadlocks.</p>"},{"location":"user-guide/simulation/#stopping-conditions","title":"Stopping conditions","text":"<p>The loop ends when both: - $$ \\text{world.done()} = \\left(\\text{unassigned} = \\varnothing \\land \\text{assigned} = \\varnothing\\right) $$ - $$ \\text{world.at_base()} = \\text{True} $$ (all non\u2011damaged UAVs back at base within tolerances)</p> <p>Or when: - $$ \\text{world.time} &gt; \\text{max_time} $$ (safety cap), or - Stalling criterion triggers.</p> <p>Tolerances: - Position: $$ \\text{Tolerances.pos} $$ (m) - Angle: $$ \\text{Tolerances.ang} $$ (rad)</p>"},{"location":"user-guide/simulation/#configuration-knobs","title":"Configuration knobs","text":"<ul> <li><code>dt</code> (s): time step; smaller is smoother but slower.</li> <li><code>max_time</code> (s): safety time cap.</li> <li><code>N_stall</code> (ticks): consecutive no\u2011movement threshold before abort.</li> <li><code>AlgorithmType</code>: selects assignment/planning strategy.</li> <li><code>Events</code>: ScenarioType with windows $\\([t_s, t_f]\\)$ for new tasks and damage.</li> </ul>"},{"location":"user-guide/simulation/#using-on_step-for-logging","title":"Using on_step for logging","text":"<p>Attach a recorder to capture time series at chosen stages.</p> <p>Minimal snapshot recorder:</p> <pre><code>from multi_uav_planner.post_processing import RunLog\nrunlog = RunLog(stages=(\"end_tick (post_coverage)\",))\nsimulate_mission(world, scenario, dt=0.2, max_time=1500.0, on_step=runlog.hook())\nprint(len(runlog.snapshots), \"snapshots; final time:\", runlog.snapshots[-1].time)\n</code></pre> <p>Per\u2011tick metrics (remaining distance, unfinished tasks):</p> <pre><code>from multi_uav_planner.post_processing_lengths import log_step_metrics_world\nmetrics_log = []\ndef on_step(world, stage):\n    if stage == \"end_tick (post_coverage)\":\n        log_step_metrics_world(world, metrics_log)\nsimulate_mission(world, scenario, dt=0.2, on_step=on_step)\n# metrics_log holds dict rows: {\"time\":..., \"total_remaining_distance\":..., \"unfinished_tasks\":...}\n</code></pre>"},{"location":"user-guide/simulation/#measuring-planning-time-assignment-planning","title":"Measuring planning time (assignment + planning)","text":"<p>Wrap <code>assignment()</code> and <code>planner</code> functions for one run:</p> <pre><code>import time, importlib\nfrom multi_uav_planner.world_models import World\n\nreg = {\"assignment\": 0.0, \"plan_path_to_task\": 0.0, \"plan_mission_path\": 0.0}\nsim_mod   = importlib.import_module('multi_uav_planner.simulation_loop')\nassign    = importlib.import_module('multi_uav_planner.assignment')\nplanner   = importlib.import_module('multi_uav_planner.path_planner')\nsteppers  = importlib.import_module('multi_uav_planner.stepping_fcts')\n\norig_sim_assign   = sim_mod.assignment\norig_assign       = assign.assignment\norig_plan_to_task = planner.plan_path_to_task\norig_plan_mission = planner.plan_mission_path\norig_step_to      = steppers.plan_path_to_task\norig_step_miss    = steppers.plan_mission_path\n\ndef timed_assign(w, a):\n    t0 = time.perf_counter()\n    out = orig_assign(w, a)\n    reg[\"assignment\"] += time.perf_counter() - t0\n    return out\n\ndef timed_plan_to_task(w, uid, pose):\n    t0 = time.perf_counter()\n    out = orig_plan_to_task(w, uid, pose)\n    reg[\"plan_path_to_task\"] += time.perf_counter() - t0\n    return out\n\ndef timed_plan_mission(u, t):\n    t0 = time.perf_counter()\n    out = orig_plan_mission(u, t)\n    reg[\"plan_mission_path\"] += time.perf_counter() - t0\n    return out\n\n# Patch symbols used inside the loop\nsim_mod.assignment = timed_assign\nplanner.plan_path_to_task = timed_plan_to_task\nplanner.plan_mission_path = timed_plan_mission\nsteppers.plan_path_to_task = timed_plan_to_task\nsteppers.plan_mission_path = timed_plan_mission\n\nworld = World(tasks={}, uavs={})\nsimulate_mission(world, scenario, dt=0.2, max_time=1500.0)\n\n# Restore originals\nsim_mod.assignment = orig_sim_assign\nplanner.plan_path_to_task = orig_plan_to_task\nplanner.plan_mission_path = orig_plan_mission\nsteppers.plan_path_to_task = orig_step_to\nsteppers.plan_mission_path = orig_step_miss\n\nprint(\"Total planning time (s):\", sum(reg.values()))\n</code></pre>"},{"location":"user-guide/simulation/#determinism-reproducibility","title":"Determinism &amp; reproducibility","text":"<ul> <li>Fix <code>ScenarioConfig.seed</code> to reproduce task positions, UAV initialization, and event times.</li> <li>Code changes (heuristics/algorithms) can alter outcomes even with the same seed.</li> </ul>"},{"location":"user-guide/simulation/#practical-tips","title":"Practical tips","text":"<ul> <li>For algorithm comparisons without dynamics, use <code>ScenarioType.NONE</code>.</li> <li>To animate efficiently, keep a static background/world and update only UAV traces/icons and incremental task markers per frame.</li> <li>One snapshot per tick: <code>RunLog(stages=(\"end_tick (post_coverage)\",))</code> for lightweight logging.</li> </ul>"},{"location":"user-guide/simulation/#minimal-example","title":"Minimal example","text":"<pre><code>from multi_uav_planner.world_models import World\nfrom multi_uav_planner.scenario_generation import ScenarioConfig, ScenarioType, AlgorithmType, generate_scenario\nfrom multi_uav_planner.simulation_loop import simulate_mission\nfrom multi_uav_planner.post_processing import RunLog\n\ncfg = ScenarioConfig(\n    base=(0,0,0), area_width=2500, area_height=2500,\n    n_uavs=4, n_tasks=20, turn_radius=80.0, uav_speed=17.5,\n    scenario_type=ScenarioType.NONE, alg_type=AlgorithmType.PRBDD, seed=1\n)\nscenario = generate_scenario(cfg)\n\nworld = World(tasks={}, uavs={})\nrunlog = RunLog(stages=(\"end_tick (post_coverage)\",))\nsimulate_mission(world, scenario, dt=0.3, max_time=1e5, on_step=runlog.hook())\n\nprint(\"done:\", world.done(), \"at_base:\", world.at_base(), \"time:\", world.time)\nprint(\"total distance:\", sum(u.current_range for u in world.uavs.values()))\n</code></pre>"},{"location":"user-guide/simulation/#reference","title":"Reference","text":"<p>Key functions used by the loop: - Assignment: <code>multi_uav_planner.assignment.assignment(world, algo)</code> - Transit planning: <code>multi_uav_planner.path_planner.plan_path_to_task(world, uid, (x_e, y_e, theta_e_or_None))</code> - Mission planning: <code>multi_uav_planner.path_planner.plan_mission_path(uav, task)</code> - Motion: <code>multi_uav_planner.stepping_fcts.move_in_transit</code>, <code>perform_task</code>, <code>return_to_base</code> - Events: <code>multi_uav_planner.events.check_for_events</code> - Recording: <code>multi_uav_planner.post_processing.RunLog</code></p>"}]}